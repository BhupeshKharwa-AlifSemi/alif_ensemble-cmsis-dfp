/* Copyright (C) 2025 Alif Semiconductor - All Rights Reserved.
 * Use, distribution and modification of this code is permitted under the
 * terms stated in the Alif Semiconductor Software License Agreement
 *
 * You should have received a copy of the Alif Semiconductor Software
 * License Agreement with this file. If not, please write to:
 * contact@alifsemi.com, or visit: https://alifsemi.com/license
 *
 */

/******************************************************************************
 * @file     board_config.c
 * @author   Silesh C V
 * @email    silesh@alifsemi.com
 * @version  V1.0.1
 * @date     21-May-2025
 * @brief    Conductor tool (https://conductor.alifsemi.com/) board pin and clock configuration library.
 ******************************************************************************/
#include "board_config.h"
#include "pins.h"
#include "gpios.h"
#include "gpio.h"
#include "soc.h"
#include <stdint.h>
#include <stddef.h>

#define GPIO_CTRL_DB_CKEN                   (1U  << 12U)
#define GPIO_CTRL_VOLT_1V8                  (1U << 0U)

/**
  \fn          int32_t board_pins_config(void)
  \brief       Initialize board pins (multiplexing and config) as per information from pins.h.
  \return      0 on success, -1 on failure
*/
int32_t board_pins_config(void)
{
    size_t num_pins = sizeof(board_pinconf) / sizeof(board_pinconf[0]);

    for (size_t i = 0; i < num_pins; i++)
    {
        int32_t ret = pinconf_set(board_pinconf[i].port,
                          board_pinconf[i].pin,
                          board_pinconf[i].alternate_function,
                          board_pinconf[i].pad_control);

        if (ret)
        {
            return ret;
        }
    }

#if (FLEX_IO_VOLTAGE_1V8 == 1)
        VBAT->GPIO_CTRL |= GPIO_CTRL_VOLT_1V8;
#endif

    return 0;
}

/**
  \fn          int32_t board_gpios_config(void)
  \brief       Initializes pseudo-static settings for pins configured as GPIO as per information from gpios.h.
  \return      0 on success, -1 on failure
*/
int32_t board_gpios_config(void)
{

    uint32_t instance = 0;
    size_t i;
    size_t num_ports = sizeof(board_gpioconf) / sizeof(board_gpioconf[0]);

    volatile GPIO_Type *regsGPIO;
    volatile GPIO_Type *regsGPIO15 = (volatile GPIO_Type*) (LPGPIO_BASE);
    volatile uint32_t *gpio_ctrl = (volatile uint32_t*) (&CLKCTL_PER_SLV->GPIO_CTRL[0]);

    for (i = 0; i < num_ports; i++)
    {
        instance = board_gpioconf[i].port_num;
        /* LPGPIO registers */
        if (instance == 15) {
            regsGPIO15->GPIO_SWPORTA_CTL      = board_gpioconf[i].hardware_mode_lptimer_on_lpgpio;
            regsGPIO15->GPIO_SWPORTA_DR       = board_gpioconf[i].initial_state_high;
            regsGPIO15->GPIO_SWPORTA_DDR      = board_gpioconf[i].direction_output;
            regsGPIO15->GPIO_DEBOUNCE         = board_gpioconf[i].debounce_enable;
            regsGPIO15->GPIO_INTTYPE_LEVEL    = board_gpioconf[i].interrupt_edge;
            regsGPIO15->GPIO_INT_POLARITY     = board_gpioconf[i].interrupt_polarity_high_edge_rising;
            regsGPIO15->GPIO_INT_BOTHEDGE     = board_gpioconf[i].interrupt_both_edge;
            regsGPIO15->GPIO_INTMASK          = board_gpioconf[i].interrupt_enable;
            regsGPIO15->GPIO_INTEN            = board_gpioconf[i].interrupt_enable;
            regsGPIO15->GPIO_PORTA_EOI        = 0xFF;
        } else {
            regsGPIO = (GPIO_Type*)(GPIO0_BASE + (instance * GPIO_REGS_OFFSET));
            /* GPIO[instance] registers */
            regsGPIO->GPIO_SWPORTA_DR       = board_gpioconf[i].initial_state_high;
            regsGPIO->GPIO_SWPORTA_DDR      = board_gpioconf[i].direction_output;
            regsGPIO->GPIO_DEBOUNCE         = board_gpioconf[i].debounce_enable;
            regsGPIO->GPIO_INTTYPE_LEVEL    = board_gpioconf[i].interrupt_edge;
            regsGPIO->GPIO_INT_POLARITY     = board_gpioconf[i].interrupt_polarity_high_edge_rising;
            regsGPIO->GPIO_INT_BOTHEDGE     = board_gpioconf[i].interrupt_both_edge;
            regsGPIO->GPIO_INTMASK          = board_gpioconf[i].interrupt_enable;
            regsGPIO->GPIO_INTEN            = board_gpioconf[i].interrupt_enable;
            regsGPIO->GPIO_PORTA_EOI        = 0xFF;
            /* enable GPIO de-bounce clock if required */
            if (board_gpioconf[i].debounce_enable)
                *(gpio_ctrl + instance)     |= GPIO_CTRL_DB_CKEN;
            }
        }

    return 0;
}

/**
  \fn          int32_t board_clocks_config(uint32_t clocks)
  \brief       Initialize board clocks as per information generated by the conductor tool (clocks.h).
  \return      0 on success, -1 on failure
*/
int32_t board_clocks_config(uint32_t clocks)
{
    int32_t ret;
      uint32_t service_error_code     = 0U;
    /* Initialize the SE services */
    se_services_port_init();

    /* Enables the HFOSC clock */
    if (clocks & CLKEN_HFOSC_MASK) {
        ret = SERVICES_clocks_enable_clock(se_services_s_handle,
                                           CLKEN_HFOSC,
                                           true,
                                           &service_error_code);
    if(ret != SERVICES_REQ_SUCCESS){
        return ret;
        }
    }

    /* Enables the 160-MHz clock */
    if (clocks & CLKEN_CLK_160M_MASK) {
        ret = SERVICES_clocks_enable_clock(se_services_s_handle,
                                           CLKEN_CLK_160M,
                                           true,
                                           &service_error_code);
    if(ret != SERVICES_REQ_SUCCESS) {
        return ret;
        }
    }

    /* Enables the 100-MHz clock */
    if (clocks & CLKEN_CLK_100M_MASK) {
        ret = SERVICES_clocks_enable_clock(se_services_s_handle,
                                           CLKEN_CLK_100M,
                                           true,
                                           &service_error_code);
    if(ret != SERVICES_REQ_SUCCESS) {
        return ret;
        }
    }

    return 0;
}
