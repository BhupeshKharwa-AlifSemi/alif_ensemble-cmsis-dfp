<?xml version="1.0" encoding="utf-8"?>
<!--v0.2: Aligned with HWRM v0.1 but w/o IRQs-->
<device xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" schemaVersion="1.1" xs:noNamespaceSchemaLocation="CMSIS-SVD.xsd">
  <vendor>Alif Semiconductor</vendor>
  <vendorID>ALIF</vendorID>
  <name>AE8SUPERSET_CM55_HP_View</name>
  <series>E8</series>
  <version>1.0</version>
  <description>
 The families of fusion processors and microcontrollers (MCUs) from Alif Semiconductor create a scalable and
 compatible continuum of highly integrated embedded processor devices for use in low-end to high-end
 intelligent IoT end-point applications. Architected for power efficiency and long battery life, these devices
 deliver high computation and ML/AI capability, multi-layered security, computer vision, and highly interactive
 human-machine interface.
</description>
  <licenseText>
 THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED\n
 OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF\n
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.\n
 ALIF SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR\n
 CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
</licenseText>
  <cpu>
    <name>CM55</name>
    <revision>r1p0</revision>
    <endian>selectable</endian>
    <mpuPresent>true</mpuPresent>
    <fpuPresent>true</fpuPresent>
    <fpuDP>true</fpuDP>
    <dspPresent>true</dspPresent>
    <vtorPresent>true</vtorPresent>
    <nvicPrioBits>8</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
    <sauNumRegions>1</sauNumRegions>
    <pmuPresent>true</pmuPresent>
    <pmuNumEventCnt>8</pmuNumEventCnt>
  </cpu>
  <addressUnitBits>8</addressUnitBits>
  <width>32</width>
  <peripherals>
    <peripheral>
      <name>CLKCTL_SYS</name>
      <baseAddress>0x1A010000</baseAddress>
      <addressBlock>
        <offset>1280</offset>
        <size>808</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>SYS_LCTRL_ST</name>
          <description>System Lock Control Status Register</description>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCK_CLR_DIS</name>
              <description>SYS_LCTRL_CLR register behavior indicator</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Writes to the SYS_LCTRL_CLR register take effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Writes to the SYS_LCTRL_CLR register are ignored</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INT_RTR_LOCK</name>
              <description>IRQRTR lockdown interface indicator</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>IRQRTR lockdown interface is de-asserted</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>IRQRTR lockdown interface is asserted</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SYS_LCTRL_SET</name>
          <description>System Lock Control Set Register</description>
          <addressOffset>0x504</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCK_CLR_DIS</name>
              <description>Writing 0x1 to this bit sets the SYS_LCTRL_ST[LOCK_CLR_DIS] bit to 0x1
Writing 0x0 to this bit has no effect on the value of the SYS_LCTRL_ST[LOCK_CLR_DIS] bit
This bit always reads as 0x0</description>
              <bitRange>[31:31]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>INT_RTR_LOCK</name>
              <description>Writing 0x1 to this bit sets the SYS_LCTRL_ST[INT_RTR_LOCK] bit to 0x1
Writing 0x0 to this bit has no effect on the value of the SYS_LCTRL_ST[INT_RTR_LOCK] bit
This bit always reads as 0x0</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYS_LCTRL_CLR</name>
          <description>System Lock Control Clear Register</description>
          <addressOffset>0x508</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INT_RTR_LOCK</name>
              <description>Writing 0x1 to this bit sets the SYS_LCTRL_ST[INT_RTR_LOCK] bit to 0x0
Writing 0x0 to this bit has no effect on the value of the SYS_LCTRL_ST[INT_RTR_LOCK] bit
This bit always reads as 0x0</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACLK_CTRL</name>
          <description>SYST_ACLK Clock Control Register</description>
          <addressOffset>0x820</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFF00FF</resetMask>
          <fields>
            <field>
              <name>ENTRY_DELAY</name>
              <description>Configure number of idle clock cycles before clock is gated.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKSELECT_CUR</name>
              <description>Currently selected clock source for SYST_ACLK
All other values are reserved.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock gated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SYST_REFCLK</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>SYSPLL_CLK divided by ACLK_DIV0[CLKDIV]</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLKSELECT</name>
              <description>Select the clock source for SYST_ACLK
All other values are reserved.
Selecting a reserved value can cause a deadlock.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock gated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SYST_REFCLK</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>SYSPLL_CLK divided by ACLK_DIV0[CLKDIV]</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ACLK_DIV0</name>
          <description>SYST_ACLK Clock Divider 0 Register</description>
          <addressOffset>0x824</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFE0FFFF</resetMask>
          <fields>
            <field>
              <name>CLKDIV_CUR</name>
              <description>Current value of integer divider applied to SYSPLL_CLK</description>
              <bitRange>[20:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Divided by 1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Divided by 2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1F</name>
                  <description>Divided by 32</description>
                  <value>0x1F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLKDIV</name>
              <description>Select the value of the integer divider applied to SYSPLL_CLK</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Divide by 1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Divide by 2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1F</name>
                  <description>Divide by 32</description>
                  <value>0x1F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>REFCLK_CNT_READ</name>
      <groupName>REFCLK</groupName>
      <baseAddress>0x1A210000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>RD_CNTCV_LO</name>
          <description>Read-only Version of CNTCV_LO Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>COUNTVALUE_LO</name>
              <description>Read-only version of CNTCV_LO register.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RD_CNTCV_HI</name>
          <description>Read-only Version of CNTCV_HI Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>COUNTVALUE_HI</name>
              <description>Read-only version of CNTCV_HI register</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>REFCLK_CNT_CTL</name>
      <groupName>REFCLK</groupName>
      <baseAddress>0x1A220000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>160</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CNTFRQ</name>
          <description>Counter Frequency Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>CLK_FREQ</name>
              <description>Indicates the counter clock frequency in Hz. This field must be programmed with the counter clock frequency value as part of
system initialization. The value of this field is not interpreted by hardware.
Note: This register is accessed only by SE.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CNTNSAR</name>
          <description>Counter Non-Secure Access Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>NS3</name>
              <description>Non-secure access permission to registers CNTACR3, CNTVOFF3_LO, CNTVOFF3_HI, and the registers from CNT_BASE3.
Note: This bit is not available for S32KCLK_CNT_CTL.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Secure access only permitted.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Secure and Non-secure accesses permitted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NS2</name>
              <description>Non-secure access permission to registers CNTACR2, CNTVOFF2_LO, CNTVOFF2_HI, and the registers from CNT_BASE2.
Note: This bit is not available for S32KCLK_CNT_CTL.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Secure access only permitted.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Secure and Non-secure accesses permitted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NS1</name>
              <description>Non-secure access permission to registers CNTACR1, CNTVOFF1_LO, CNTVOFF1_HI, and the registers from CNT_BASE1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Secure access only permitted.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Secure and Non-secure accesses permitted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NS0</name>
              <description>Non-secure access permission to registers CNTACR0, CNTVOFF0_LO, CNTVOFF0_HI, and the registers from CNT_BASE0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Secure access only permitted.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Secure and Non-secure accesses permitted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CNTTIDR</name>
          <description>Counter Timer ID Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00003333</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>F3FEL0</name>
              <description>CNT_BASE3 privileged view indicator.
Note: This bit is not available for S32KCLK_CNT_CTL.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>CNT_BASE3 has only privileged view.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CNT_BASE3 has both privileged and unprivileged views.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>F3FVI</name>
              <description>CNT_BASE3 virtual capability indicator.
Note: This bit is not available for S32KCLK_CNT_CTL.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>CNT_BASE3 does not have virtual capability.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CNT_BASE3 has virtual capability.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>F3FI</name>
              <description>CNT_BASE3 availability indicator.
Note: This bit is not available for S32KCLK_CNT_CTL.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>CNT_BASE3 is not implemented.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CNT_BASE3 is implemented.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>F2FEL0</name>
              <description>CNT_BASE2 privileged view indicator.
Note: This bit is not available for S32KCLK_CNT_CTL.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>CNT_BASE2 has only privileged view.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CNT_BASE2 has both privileged and unprivileged views.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>F2FVI</name>
              <description>CNT_BASE2 virtual capability indicator.
Note: This bit is not available for S32KCLK_CNT_CTL.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>CNT_BASE2 does not have virtual capability.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CNT_BASE2 has virtual capability.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>F2FI</name>
              <description>CNT_BASE2 availability indicator.
Note: This bit is not available for S32KCLK_CNT_CTL.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>CNT_BASE2 is not implemented.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CNT_BASE2 is implemented.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>F1FEL0</name>
              <description>CNT_BASE1 privileged view indicator.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>CNT_BASE1 has only privileged view.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CNT_BASE1 has both privileged and unprivileged views.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>F1FVI</name>
              <description>CNT_BASE1 virtual capability indicator.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>CNT_BASE1 does not have virtual capability.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CNT_BASE1 has virtual capability.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>F1FI</name>
              <description>CNT_BASE1 availability indicator.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>CNT_BASE1 is not implemented.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CNT_BASE1 is implemented.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>F0FEL0</name>
              <description>CNT_BASE0 privileged view indicator.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>CNT_BASE0 has only privileged view.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CNT_BASE0 has both privileged and unprivileged views.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>F0FVI</name>
              <description>CNT_BASE0 virtual capability indicator.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>CNT_BASE0 does not have virtual capability.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CNT_BASE0 has virtual capability.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>F0FI</name>
              <description>CNT_BASE0 availability indicator.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>CNT_BASE0 is not implemented.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CNT_BASE0 is implemented.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>4</dimIncrement>
          <name>CNTACR[%s]</name>
          <description>CNT_BASEn Access Control Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFC0</resetMask>
          <fields>
            <field>
              <name>RWPT</name>
              <description>Read-write access control for registers CNTP_CVAL_LO, CNTP_CVAL_HI, CNTP_TVAL, and CNTP_CTL</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Read-write access allowed.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RWVT</name>
              <description>Read-write access control for registers CNTV_CVAL_LO, CNTV_CVAL_HI, CNTV_TVAL, and CNTV_CTL</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Read-write access allowed.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RVOFF</name>
              <description>Read-only access control for registers CNTVOFF_LO, and CNTVOFF_HI</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Read-only access allowed.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFRQ</name>
              <description>Read-only access control for register RD_CNTFRQ</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Read-only access allowed.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RVCT</name>
              <description>Read-only access control for registers CNTVCT_LO, and CNTVCT_HI</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Read-only access allowed.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RPCT</name>
              <description>Read-only access control for registers CNTPCT_LO, and CNTPCT_HI</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Read-only access allowed.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>4</dim>
          <dimIncrement>8</dimIncrement>
          <name>CNT_BASE_VOFF[%s]</name>
          <addressOffset>0x80</addressOffset>
          <register>
            <name>CNTVOFF_LO</name>
            <description>CNT_BASEn Virtual Offset Low Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000000</resetMask>
            <fields>
              <field>
                <name>VIRT_OFFSET_LO</name>
                <description>Bits [31:0] of the virtual offset value for CNT_BASEn. This field is the read-write version of the CNTVOFF_LO. This is the offset between real time and virtual time.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CNTVOFF_HI</name>
            <description>CNT_BASEn Virtual Offset High Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000000</resetMask>
            <fields>
              <field>
                <name>VIRT_OFFSET_HI</name>
                <description>Bits [63:32] of the virtual offset value for CNT_BASEn. This field is the read-write version of the CNTVOFF_HI. This is the offset between real time and virtual time.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>REFCLK_CNT_BASE0</name>
      <groupName>REFCLK</groupName>
      <baseAddress>0x1A230000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>64</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CNTPCT_LO</name>
          <description>Physical Count Low Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>PHYS_CNT_VAL_LO</name>
              <description>This field holds bits [31:0] of the 64-bit physical count value.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CNTPCT_HI</name>
          <description>Physical Count High Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>PHYS_CNT_VAL_HI</name>
              <description>This field holds bits [63:32] of the 64-bit physical count value.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CNTVCT_LO</name>
          <description>Virtual Count Low Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>VIRT_CNT_VAL_LO</name>
              <description>This field holds bits [31:0] of the 64-bit virtual count value.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CNTVCT_HI</name>
          <description>Virtual Count High Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>VIRT_CNT_VAL_HI</name>
              <description>This field holds bits [63:32] of the 64-bit virtual count value.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RD_CNTFRQ</name>
          <description>Counter Frequency Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>CLK_FREQ</name>
              <description>Read-only version of CNTFRQ. Indicates the counter clock frequency in Hz. This field is provided so that software can discover the counter frequency. The value of this field is not interpreted by hardware.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CNTVOFF_LO</name>
          <description>Virtual Offset Low Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>VIRT_OFFSET_LO</name>
              <description>Bits [31:0] of the timer virtual offset value. This field is the read-only version of CNTVOFFn_LO. This is the offset between real time and virtual time.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CNTVOFF_HI</name>
          <description>Virtual Offset High Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>VIRT_OFFSET_HI</name>
              <description>Bits [63:32] of the timer virtual offset value. This field is the read-only version of CNTVOFFn_HI. This is the offset between real time and virtual time.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CNTP_CVAL_LO</name>
          <description>Physical Timer Compare Value Low Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>CMP_VAL_LO</name>
              <description>This field holds bits [31:0] of the 64-bit physical timer compare value.
When CNTP_CTL[ENABLE] = 0x1, the timer condition is met when (CNTPCT_HI[31:0] to CNTPCT_LO[31:0]) - (CNTP_CVAL_HI[31:0] to CNTP_CVAL_LO[31:0]) is greater than or equal to zero. This means that CNTP_CVAL_HI and CNTP_CVAL_LO act like a 64-bit up counter timer. 
When the timer condition is met, the CNTP_CTL[ISTATUS] bit is set to 0x1, and if CNTP_CTL[IMASK] = 0x0, an interrupt is generated.
When CNTP_CTL[ENABLE] = 0x0, the timer condition is not met, but CNTPCT_HI and CNTPCT_LO continue to count.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CNTP_CVAL_HI</name>
          <description>Physical Timer Compare Value High Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>CMP_VAL_HI</name>
              <description>This field holds bits [63:32] of the 64-bit physical timer compare value.
When CNTP_CTL[ENABLE] = 0x1, the timer condition is met when (CNTPCT_HI[31:0] to CNTPCT_LO[31:0]) - (CNTP_CVAL_HI[31:0] to CNTP_CVAL_LO[31:0]) is greater than or equal to zero. This means that CNTP_CVAL_HI and CNTP_CVAL_LO act like a 64-bit up counter timer. 
When the timer condition is met, the CNTP_CTL[ISTATUS] bit is set to 0x1, and if CNTP_CTL[IMASK] = 0x0, an interrupt is generated.
When CNTP_CTL[ENABLE] = 0x0, the timer condition is not met, but CNTPCT_HI and CNTPCT_LO continue to count.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CNTP_TVAL</name>
          <description>Physical Timer Value Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>TMR_VAL</name>
              <description>Holds the timer value for the physical timer.
When reading from this register the value returned is (CNTP_CVAL_HI[31:0] to CNTP_CVAL_LO[31:0]) - (CNTPCT_HI[31:0] to CNTPCT_LO[31:0]), if CNTP_CTL[ENABLE] = 0x1. If CNTP_CTL[ENABLE] = 0x0, the value returned is unknown.
When writing to this register the 64-bit compare value (CNTP_CVAL_HI[31:0] to CNTP_CVAL_LO[31:0]) is set to (CNTPCT_HI[31:0] to CNTPCT_LO[31:0]) + CNTP_TVAL, where CNTP_TVAL is treated as a signed 32-bit integer.
When CNTP_CTL[ENABLE] = 0x1, the timer condition is met when (CNTPCT_HI[31:0] to CNTPCT_LO[31:0]) - (CNTP_CVAL_HI[31:0] to CNTP_CVAL_LO[31:0]) is greater than or equal to zero. This means that CNTP_TVAL acts like a 32-bit down counter timer. 
When the timer condition is met, the CNTP_CTL[ISTATUS] bit is set to 0x1, and if CNTP_CTL[IMASK] = 0x0, an interrupt is generated.
When CNTP_CTL[ENABLE] = 0x0, the timer condition is not met, but CNTPCT_HI and CNTPCT_LO continue to count, so the CNTP_TVAL view appears to continue to count down.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CNTP_CTL</name>
          <description>Physical Timer Control Register</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF8</resetMask>
          <fields>
            <field>
              <name>ISTATUS</name>
              <description>Timer status
This bit indicates whether the timer condition is met when CNTP_CTL[ENABLE] = 0x1. It does not take into account the CNTP_CTL[IMASK] bit value. If ISTATUS = 0x1 and CNTP_CTL[IMASK] = 0x0, then the timer interrupt is asserted. When CNTP_CTL[ENABLE] = 0x0, the ISTATUS value is unknown.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timer condition is not met.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timer condition is met.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IMASK</name>
              <description>Timer interrupt mask</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timer interrupt is not masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timer interrupt is masked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Timer enable
Setting this bit to 0x0 disables the timer output signal, but the timer value accessible from CNTP_TVAL continues to count down.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timer disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timer enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CNTV_CVAL_LO</name>
          <description>Virtual Timer Compare Value Low Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>CMP_VAL_LO</name>
              <description>This field holds bits [31:0] of the 64-bit virtual timer compare value.
When CNTV_CTL[ENABLE] = 0x1, the timer condition is met when (CNTVCT_HI[31:0] to CNTVCT_LO[31:0]) - (CNTV_CVAL_HI[31:0] to CNTV_CVAL_LO[31:0]) is greater than or equal to zero. This means that CNTV_CVAL_HI and CNTV_CVAL_LO act like a 64-bit up counter timer. 
When the timer condition is met, the CNTV_CTL[ISTATUS] bit is set to 0x1, and if CNTV_CTL[IMASK] = 0x0, an interrupt is generated.
When CNTV_CTL[ENABLE] = 0x0, the timer condition is not met, but CNTVCT_HI and CNTVCT_LO continue to count.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CNTV_CVAL_HI</name>
          <description>Virtual Timer Compare Value High Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>CMP_VAL_HI</name>
              <description>This field holds bits [63:32] of the 64-bit virtual timer compare value.
When CNTV_CTL[ENABLE] = 0x1, the timer condition is met when (CNTVCT_HI[31:0] to CNTVCT_LO[31:0]) - (CNTV_CVAL_HI[31:0] to CNTV_CVAL_LO[31:0]) is greater than or equal to zero. This means that CNTV_CVAL_HI and CNTV_CVAL_LO act like a 64-bit up counter timer. 
When the timer condition is met, the CNTV_CTL[ISTATUS] bit is set to 0x1, and if CNTV_CTL[IMASK] = 0x0, an interrupt is generated.
When CNTV_CTL[ENABLE] = 0x0, the timer condition is not met, but CNTVCT_HI and CNTVCT_LO continue to count.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CNTV_TVAL</name>
          <description>Virtual Timer Value Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>TMR_VAL</name>
              <description>Holds the timer value for the virtual timer.
When reading from this register the value returned is (CNTV_CVAL_HI[31:0] to CNTV_CVAL_LO[31:0]) - (CNTVCT_HI[31:0] to CNTVCT_LO[31:0]), if CNTV_CTL[ENABLE] = 0x1. If CNTV_CTL[ENABLE] = 0x0, the value returned is unknown.
When writing to this register the 64-bit compare value (CNTV_CVAL_HI[31:0] to CNTV_CVAL_LO[31:0]) is set to (CNTVCT_HI[31:0] to CNTVCT_LO[31:0]) + CNTV_TVAL, where CNTV_TVAL is treated as a signed 32-bit integer.
When CNTV_CTL[ENABLE] = 0x1, the timer condition is met when (CNTVCT_HI[31:0] to CNTVCT_LO[31:0]) - (CNTV_CVAL_HI[31:0] to CNTV_CVAL_LO[31:0]) is greater than or equal to zero. This means that CNTV_TVAL acts like a 32-bit down counter timer. 
When the timer condition is met, the CNTV_CTL[ISTATUS] bit is set to 0x1, and if CNTV_CTL[IMASK] = 0x0, an interrupt is generated.
When CNTV_CTL[ENABLE] = 0x0, the timer condition is not met, but CNTVCT_HI and CNTVCT_LO continue to count, so the CNTV_TVAL view appears to continue to count down.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CNTV_CTL</name>
          <description>Virtual Timer Control Register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF8</resetMask>
          <fields>
            <field>
              <name>ISTATUS</name>
              <description>Timer status
This bit indicates whether the timer condition is met when CNTV_CTL[ENABLE] = 0x1. It does not take into account the CNTV_CTL[IMASK] bit value. If ISTATUS = 0x1 and CNTV_CTL[IMASK] = 0x0, then the timer interrupt is asserted. When CNTV_CTL[ENABLE] = 0x0, the ISTATUS value is unknown.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timer condition is not met.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timer condition is met.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IMASK</name>
              <description>Timer interrupt mask</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timer interrupt is not masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timer interrupt is masked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Timer enable
Setting this bit to 0x0 disables the timer output signal, but the timer value accessible from CNTV_TVAL continues to count down.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timer disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timer enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="REFCLK_CNT_BASE0">
      <name>REFCLK_CNT_BASE1</name>
      <baseAddress>0x1A240000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="REFCLK_CNT_BASE0">
      <name>REFCLK_CNT_BASE2</name>
      <baseAddress>0x1A250000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="REFCLK_CNT_BASE0">
      <name>REFCLK_CNT_BASE3</name>
      <baseAddress>0x1A260000</baseAddress>
    </peripheral>
    <peripheral>
      <name>WDT_AP_CTRL</name>
      <groupName>WDT</groupName>
      <baseAddress>0x1A300000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4048</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>WDT_WRR</name>
          <description>Watchdog Refresh Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRR</name>
              <description>A write to this
register causes the watchdog to refresh and
start a new watch period. A read has no effect
and returns 0.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WCS</name>
          <description>Watchdog Control and Status Register</description>
          <alternateRegister>WDT_WRR</alternateRegister>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WATCHDOG_SIGNAL_STATUS_BITS</name>
              <description>A read of this bit field indicates the current state of the watchdog signals. A write to these bits has no effect.
Bit [2] reflects the status of
WDT_AP_IRQ1 and bit [1] reflects the status of WDT_AP_IRQ0.</description>
              <bitRange>[2:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WATCHDOG_ENABLE_BIT</name>
              <description>A read of this bit indicates the current enabled or disabled state of the watchdog.
This bit resets to 0 on watchdog cold reset.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The watchdog is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The watchdog is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WOR_31_0</name>
          <description>Watchdog Offset Register, lower bits</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WOR_31_0</name>
              <description>The lower 32 bits of the watchdog countdown timer
value.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WOR_63_32</name>
          <description>Watchdog Offset Register, upper bits</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WOR_48_32</name>
              <description>The upper 16 bits of the watchdog countdown timer
value.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WCV_31_0</name>
          <description>Watchdog Compare Value Register, lower bits</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WCV_31_0</name>
              <description>The lower 32 bits of the current watchdog compare value.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WCV_63_32</name>
          <description>Watchdog Compare Value Register, upper bits</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WCV_63_32</name>
              <description>The upper 32 bits of the current watchdog compare value.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_IIDR</name>
          <description>Interface Identification Register</description>
          <addressOffset>0xFCC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRODUCTID</name>
              <description>Implementation defined product identifier</description>
              <bitRange>[31:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ARCHITECTURE_VERSION</name>
              <description>WDT architecture version</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REVISION</name>
              <description>Implementation defined component revision number</description>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IMPLEMENTER</name>
              <description>Implementer JEP106 code</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="WDT_AP_CTRL">
      <name>WDT_AP_REFRESH</name>
      <baseAddress>0x1A310000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="WDT_AP_CTRL">
      <name>WDT_AP_S_CTRL</name>
      <baseAddress>0x1A320000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="WDT_AP_CTRL">
      <name>WDT_AP_S_REFRESH</name>
      <baseAddress>0x1A330000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="REFCLK_CNT_READ">
      <name>S32KCLK_CNT_READ</name>
      <baseAddress>0x1A410000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="REFCLK_CNT_CTL">
      <name>S32KCLK_CNT_CTL</name>
      <baseAddress>0x1A420000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="REFCLK_CNT_BASE0">
      <name>S32KCLK_CNT_BASE0</name>
      <baseAddress>0x1A430000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="REFCLK_CNT_BASE0">
      <name>S32KCLK_CNT_BASE1</name>
      <baseAddress>0x1A440000</baseAddress>
    </peripheral>
    <peripheral>
      <name>IRQRTR</name>
      <baseAddress>0x1A500000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4020</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>IRQRTR_CTRL</name>
          <description>IRQRTR Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR</name>
              <description>Configures the response for configuration accesses which generate a configuration access
error:</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQRTR_LD_CTRL</name>
          <description>IRQRTR Lockdown Control Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFB</resetMask>
          <fields>
            <field>
              <name>LDI_ST</name>
              <description>Indicates the current status of the lockdown interface:
NOTE: Depends on the value of the [INT_RTR_LOCK] bit in the system lock control registers {SYS_LCTRL_ST, SYS_LCTRL_SET, SYS_LCTRL_CLR}.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Lockdown interface is de-asserted</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Lockdown interface is asserted</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Indicates the lock state of the IRQRTR:</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Open lockdown state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Partial lockdown state</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Full lockdown state</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQRTR_SHD_INT_INFO</name>
          <description>IRQRTR Shared Interrupt Information Register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>ICI_DST</name>
              <description>Interrupt Controller Destination.
Each bit indicates whether the interrupt selected by the IRQRTR_SHD_INT_SEL[INT_SEL] field canbe routed to the ICI interface associated with the bit, starting with bit 0 for ICI0 to bit 3 for ICI3:</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Shared interrupt cannot be routed to the ICI[n]</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Shared interrupt can be routed to the ICI[n]</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQRTR_SHD_INT_CFG</name>
          <description>IRQRTR Shared Interrupt Configuration Register</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>ICI_EN</name>
              <description>Interrupt Controller Enable.
Each bit indicates whether the interrupt selected by the IRQRTR_SHD_INT_SEL[INT_SEL] field isrouted to the ICI interface associated with the bit, starting with bit 0 for ICI0 to bit 3 for ICI3:
Note: Bits where the respective bit in the IRQRTR_SHD_INT_INFO[ICI_DST] field is 0x0 are reserved andtreated as RAZ/WI.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Shared interrupt is not routed to the ICI[n]</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Shared interrupt is routed to the ICI[n]</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQRTR_SHD_INT_LCTRL</name>
          <description>IRQRTR Shared Interrupt Lock Control Register</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCK</name>
              <description>Controls the lock status of the interrupt selected by the IRQRTR_SHD_INT_SEL[INT_SEL] field:
This field becomes read-only when this field is set to 0x1 and the IRQRTR_LD_CTRL[LOCK] field isset to 0x2 (partial lockdown) or 0x3 (full lockdown).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Shared interrupt is not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Shared interrupt is locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQRTR_SHD_INT_SEL</name>
          <description>IRQRTR Shared Interrupt Select Register</description>
          <addressOffset>0x10C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INT_SEL</name>
              <description>Selects which interrupt the IRQRTR_SHD_INT_INFO, IRQRTR_SHD_INT_CFG and IRQRTR_SHD_INT_LCTRL registersrefer to.
When the value in this field is greater than the value in the IRQRTR_CFG[NUM_SHD_INT] field, the fields in IRQRTR_SHD_INT_INFO,IRQRTR_SHD_INT_CFG and IRQRTR_SHD_INT_LCTRL are reserved and treated as RAZ/WI.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQRTR_TMP_ST</name>
          <description>IRQRTR Tamper Status Register</description>
          <addressOffset>0xE90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFF003</resetMask>
          <fields>
            <field>
              <name>TMP_ST_VLD</name>
              <description>Indicates whether the IRQRTR_TMP_ST register contains valid data or not.
This field is 'write-1-to-clear'. Writing 0 has no effect.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>IRQRTR_TMP_ST does not contain valid data</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>IRQRTR_TMP_ST contains valid data</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TMP_ST_OVERFLW</name>
              <description>Indicates whether a tamper transaction occurred, while the
IRQRTR_TMP_ST[TMP_ST_VLD] was 0x1:
This field is 'write-1-to-clear'. Writing 0 has no effect.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No tamper transaction overflow occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Tamper transaction overflow occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TMP_TRANS_ADDR</name>
              <description>Address of the register accessed by the tamper transaction.
When TMP_ST_VLD is 0, this field is not valid.</description>
              <bitRange>[11:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQRTR_CAP</name>
          <description>IRQRTR Capability Register</description>
          <addressOffset>0xFA0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LDE_LVL</name>
              <description>Level of the Lockdown Extension implemented by the IRQRTR.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>LDE.2 (open, partial and full lockdown support).</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQRTR_CFG</name>
          <description>IRQRTR Configuration Register</description>
          <addressOffset>0xFB0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000301AA</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NUM_ICI</name>
              <description>Number of ICIs supported by the IRQRTR:</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>4 ICIs</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NUM_SHD_INT</name>
              <description>Number of shared interrupts supported by the IRQRTR:</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1AA</name>
                  <description>427 shared interrupts</description>
                  <value>0x1AA</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CGU</name>
      <baseAddress>0x1A602000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>44</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>OSC_CTRL</name>
          <description>Oscillator Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00110011</resetMask>
          <fields>
            <field>
              <name>XTAL_DEAD</name>
              <description>38.4 MHz crystal-oscillator clock monitor status</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No crystal clock dead found</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Crystal clock dead detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLKMON_ENA</name>
              <description>Enable 38.4 MHz crystal-oscillator clock monitor</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock monitor</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock monitor</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PERIPH_XTAL_SEL</name>
              <description>Select oscillator clock source for HFOSC_CLK</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select 38.4 MHz (76.8 MHz / 2) ring-oscillator clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select 38.4 MHz crystal-oscillator clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYS_XTAL_SEL</name>
              <description>Select oscillator clock source for CPUPLL_CLK, SYSPLL_CLK, and SYST_REFCLK</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select 76.8 MHz ring-oscillator clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select 38.4 MHz crystal-oscillator clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PLL_LOCK_CTRL</name>
          <description>PLL Lock Control Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000011</resetMask>
          <fields>
            <field>
              <name>PLL_CALIB</name>
              <description>PLL calibration status</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>PLL not in calibration</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>PLL in calibration</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PLL_LOCK</name>
              <description>PLL lock control</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>PLL not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>PLL locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PLL_CLK_SEL</name>
          <description>PLL Clock Select Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00110111</resetMask>
          <fields>
            <field>
              <name>ES1</name>
              <description>Select the source for RTSS_HE_CLK</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select a value specified by the ESCLK_SEL[ES1_OSC] field</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select a value specified by the ESCLK_SEL[ES1_PLL] field</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ES0</name>
              <description>Select the source for RTSS_HP_CLK</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select a value specified by the ESCLK_SEL[ES0_OSC] field</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select a value specified by the ESCLK_SEL[ES0_PLL] field</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYS</name>
              <description>Select the source for CPUPLL_CLK and SYSPLL_CLK</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select oscillator clock source</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select PLL clock source</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYSREF</name>
              <description>Select the source for SYST_REFCLK</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select oscillator clock source</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select PLL clock source</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ESCLK_SEL</name>
          <description>Clock Select Register for M55-HP and M55-HE</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000033</resetValue>
          <resetMask>0x00003333</resetMask>
          <fields>
            <field>
              <name>ES1_OSC</name>
              <description>Select oscillator clock frequency for RTSS_HE_CLK</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select 76.8 MHz ring-oscillator clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select 38.4 MHz ring-oscillator clock</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Select 76.8 MHz crystal-oscillator clock</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Select 38.4 MHz crystal-oscillator clock</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ES0_OSC</name>
              <description>Select oscillator clock frequency for RTSS_HP_CLK</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select 76.8 MHz ring-oscillator clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select 38.4 MHz ring-oscillator clock</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Select 76.8 MHz crystal-oscillator clock</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Select 38.4 MHz crystal-oscillator clock</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ES1_PLL</name>
              <description>Select PLL clock frequency for RTSS_HE_CLK</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description> Select 80 MHz PLL clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description> Select 80 MHz PLL clock</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description> Select 160 MHz PLL clock</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description> Select 160 MHz PLL clock</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ES0_PLL</name>
              <description>Select PLL clock frequency for RTSS_HP_CLK</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description> Select 100 MHz PLL clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description> Select 200 MHz PLL clock</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description> Select 400 MHz PLL clock</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description> Select 400 MHz PLL clock</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ENA</name>
          <description>Clock Enable Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x7F33F7F1</resetValue>
          <resetMask>0x7FFFF7F1</resetMask>
          <fields>
            <field>
              <name>ZAPHOD</name>
              <description>Enable ZAPHOD clock</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>JPEG</name>
              <description>Enable JPEG clock</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ISP</name>
              <description>Enable ISP clock</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OCVM</name>
              <description>Enable SRAM1 clock</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CVM</name>
              <description>Enable SRAM0 clock</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HCLK</name>
              <description>Enable SYST_HCLK clock</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PCLK</name>
              <description>Enable SYST_PCLK clock</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK76P8M</name>
              <description>Enable 76M8_CLK clock</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK38P4M</name>
              <description>Enable HFOSC_CLK</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK266M</name>
              <description>Enable 266M_CLK</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK160M</name>
              <description>Enable 160M_CLK</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HFXO</name>
              <description>Enable clock to the HFXO_OUT pin</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIV_BY_ODD_SW_RST</name>
              <description>DIV_BY_ODD SW reset</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Reset inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Reset active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK400M</name>
              <description>Enable 400MHz PLL clock</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK200M</name>
              <description>Enable 200MHz PLL clock</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ES1</name>
              <description>Enable RTSS_HE_CLK</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ES0</name>
              <description>Enable RTSS_HP_CLK</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK80M</name>
              <description>Enable 80MHz PLL clock</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK10M</name>
              <description>Enable 20MHz PLL clock</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK100M</name>
              <description>Enable 100MHz PLL clock</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK50M</name>
              <description>Enable 50MHz PLL clock</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK25M</name>
              <description>Enable 25MHz PLL clock</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CPUPLL</name>
              <description>Enable CPUPLL_CLK</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYSPLL</name>
              <description>Enable SYSPLL_CLK</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CGU_IRQ</name>
          <description>CGU Interrupt Status Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>XTAL_DEAD</name>
              <description>38.4 MHz crystal-oscillator dead. Active high, read to clear.
Note: The XTAL_DEAD interrupt is mapped to the Secure Enclave.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>MISC_CLK_CTRL</name>
          <description>Miscellaneous Clock Control Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>SEL_OSPI_CLK</name>
              <description>OSPI clock select</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>OSPI clock 200 MHz (ACLK)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>OSPI clock 133 MHz</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SHMEM_CLK_CTRL</name>
          <description>Shared Memory Clock Controllers Control Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x01FF01FF</resetMask>
          <fields>
            <field>
              <name>NIC400_CKOR</name>
              <description>Shared Memory NIC clock override (bit 24)</description>
              <bitRange>[24:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Dynamic clock (bits [23:16] specify the entry delay)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Forced clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ZAPHOD_CKOR</name>
              <description>NPU-HG clock override (bit 8)</description>
              <bitRange>[8:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Dynamic clock (bits [7:0] specify the entry delay)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Forced clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PINMUX</name>
      <baseAddress>0x1A603000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>576</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>18</dim>
          <dimIncrement>32</dimIncrement>
          <name>PINMUX_CFG[%s]</name>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>P_0</name>
            <description>Control Register for Port n, Pin 0</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00220000</resetValue>
            <resetMask>0x00FF0007</resetMask>
            <fields>
              <field>
                <name>DRV</name>
                <description>Driver type</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Push-pull</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Open drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>E</name>
                <description>Output drive strength
NOTE: Reset value is 0x3 (12 mA) for registers P4_4, P4_5, P4_6, P4_7</description>
                <bitRange>[22:21]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>2 mA</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>4 mA</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>8 mA</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>12 mA</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>P</name>
                <description>Driver disabled state control</description>
                <bitRange>[20:19]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>High-Z</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Bus keeper</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SR</name>
                <description>Slew rate</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Slow</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Fast</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMT</name>
                <description>Schmitt trigger (hysteresis) enable</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>No hysteresis</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Hysteresis enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>REN</name>
                <description>Receiver enable
NOTE: Reset value is 0x1 for registers P4_4, P4_5, P4_6, P4_7</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Receiver disabled, pin reads return 0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Receiver enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PINMUX</name>
                <description>Pin multiplexing control field
0x1-0xN: Selects other peripherals as shown in table Pin Function Multiplexing of the device series-specific Datasheet.
Un-mapped: Select GPIOn_0
NOTE: Reset value is 0x1 for registers P4_4, P4_5, P4_6, P4_7</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Selects GPIOn_0 signal from GPIOn peripheral</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>P_1</name>
            <description>Control Register for Port n, Pin 1</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00220000</resetValue>
            <resetMask>0x00FF0007</resetMask>
            <fields>
              <field>
                <name>DRV</name>
                <description>Driver type</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Push-pull</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Open drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>E</name>
                <description>Output drive strength
NOTE: Reset value is 0x3 (12 mA) for registers P4_4, P4_5, P4_6, P4_7</description>
                <bitRange>[22:21]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>2 mA</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>4 mA</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>8 mA</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>12 mA</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>P</name>
                <description>Driver disabled state control</description>
                <bitRange>[20:19]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>High-Z</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Bus keeper</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SR</name>
                <description>Slew rate</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Slow</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Fast</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMT</name>
                <description>Schmitt trigger (hysteresis) enable</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>No hysteresis</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Hysteresis enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>REN</name>
                <description>Receiver enable
NOTE: Reset value is 0x1 for registers P4_4, P4_5, P4_6, P4_7</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Receiver disabled, pin reads return 0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Receiver enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PINMUX</name>
                <description>Pin multiplexing control field
0x1-0xN: Selects other peripherals as shown in table Pin Function Multiplexing of the device series-specific Datasheet.
Un-mapped: Select GPIOn_1
NOTE: Reset value is 0x1 for registers P4_4, P4_5, P4_6, P4_7</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Selects GPIOn_1 signal from GPIOn peripheral</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>P_2</name>
            <description>Control Register for Port n, Pin 2</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00220000</resetValue>
            <resetMask>0x00FF0007</resetMask>
            <fields>
              <field>
                <name>DRV</name>
                <description>Driver type</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Push-pull</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Open drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>E</name>
                <description>Output drive strength
NOTE: Reset value is 0x3 (12 mA) for registers P4_4, P4_5, P4_6, P4_7</description>
                <bitRange>[22:21]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>2 mA</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>4 mA</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>8 mA</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>12 mA</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>P</name>
                <description>Driver disabled state control</description>
                <bitRange>[20:19]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>High-Z</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Bus keeper</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SR</name>
                <description>Slew rate</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Slow</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Fast</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMT</name>
                <description>Schmitt trigger (hysteresis) enable</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>No hysteresis</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Hysteresis enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>REN</name>
                <description>Receiver enable
NOTE: Reset value is 0x1 for registers P4_4, P4_5, P4_6, P4_7</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Receiver disabled, pin reads return 0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Receiver enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PINMUX</name>
                <description>Pin multiplexing control field
0x1-0xN: Selects other peripherals as shown in table Pin Function Multiplexing of the device series-specific Datasheet.
Un-mapped: Select GPIOn_2
NOTE: Reset value is 0x1 for registers P4_4, P4_5, P4_6, P4_7</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Selects GPIOn_2 signal from GPIOn peripheral</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>P_3</name>
            <description>Control Register for Port n, Pin 3</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00220000</resetValue>
            <resetMask>0x00FF0007</resetMask>
            <fields>
              <field>
                <name>DRV</name>
                <description>Driver type</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Push-pull</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Open drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>E</name>
                <description>Output drive strength
NOTE: Reset value is 0x3 (12 mA) for registers P4_4, P4_5, P4_6, P4_7</description>
                <bitRange>[22:21]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>2 mA</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>4 mA</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>8 mA</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>12 mA</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>P</name>
                <description>Driver disabled state control</description>
                <bitRange>[20:19]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>High-Z</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Bus keeper</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SR</name>
                <description>Slew rate</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Slow</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Fast</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMT</name>
                <description>Schmitt trigger (hysteresis) enable</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>No hysteresis</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Hysteresis enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>REN</name>
                <description>Receiver enable
NOTE: Reset value is 0x1 for registers P4_4, P4_5, P4_6, P4_7</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Receiver disabled, pin reads return 0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Receiver enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PINMUX</name>
                <description>Pin multiplexing control field
0x1-0xN: Selects other peripherals as shown in table Pin Function Multiplexing of the device series-specific Datasheet.
Un-mapped: Select GPIOn_3
NOTE: Reset value is 0x1 for registers P4_4, P4_5, P4_6, P4_7</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Selects GPIOn_3 signal from GPIOn peripheral</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>P_4</name>
            <description>Control Register for Port n, Pin 4</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00220000</resetValue>
            <resetMask>0x00FF0007</resetMask>
            <fields>
              <field>
                <name>DRV</name>
                <description>Driver type</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Push-pull</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Open drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>E</name>
                <description>Output drive strength
NOTE: Reset value is 0x3 (12 mA) for registers P4_4, P4_5, P4_6, P4_7</description>
                <bitRange>[22:21]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>2 mA</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>4 mA</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>8 mA</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>12 mA</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>P</name>
                <description>Driver disabled state control</description>
                <bitRange>[20:19]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>High-Z</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Bus keeper</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SR</name>
                <description>Slew rate</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Slow</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Fast</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMT</name>
                <description>Schmitt trigger (hysteresis) enable</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>No hysteresis</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Hysteresis enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>REN</name>
                <description>Receiver enable
NOTE: Reset value is 0x1 for registers P4_4, P4_5, P4_6, P4_7</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Receiver disabled, pin reads return 0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Receiver enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PINMUX</name>
                <description>Pin multiplexing control field
0x1-0xN: Selects other peripherals as shown in table Pin Function Multiplexing of the device series-specific Datasheet.
Un-mapped: Select GPIOn_4
NOTE: Reset value is 0x1 for registers P4_4, P4_5, P4_6, P4_7</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Selects GPIOn_4 signal from GPIOn peripheral</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>P_5</name>
            <description>Control Register for Port n, Pin 5</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00220000</resetValue>
            <resetMask>0x00FF0007</resetMask>
            <fields>
              <field>
                <name>DRV</name>
                <description>Driver type</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Push-pull</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Open drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>E</name>
                <description>Output drive strength
NOTE: Reset value is 0x3 (12 mA) for registers P4_4, P4_5, P4_6, P4_7</description>
                <bitRange>[22:21]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>2 mA</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>4 mA</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>8 mA</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>12 mA</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>P</name>
                <description>Driver disabled state control</description>
                <bitRange>[20:19]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>High-Z</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Bus keeper</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SR</name>
                <description>Slew rate</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Slow</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Fast</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMT</name>
                <description>Schmitt trigger (hysteresis) enable</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>No hysteresis</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Hysteresis enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>REN</name>
                <description>Receiver enable
NOTE: Reset value is 0x1 for registers P4_4, P4_5, P4_6, P4_7</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Receiver disabled, pin reads return 0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Receiver enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PINMUX</name>
                <description>Pin multiplexing control field
0x1-0xN: Selects other peripherals as shown in table Pin Function Multiplexing of the device series-specific Datasheet.
Un-mapped: Select GPIOn_5
NOTE: Reset value is 0x1 for registers P4_4, P4_5, P4_6, P4_7</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Selects GPIOn_5 signal from GPIOn peripheral</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>P_6</name>
            <description>Control Register for Port n, Pin 6</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00220000</resetValue>
            <resetMask>0x00FF0007</resetMask>
            <fields>
              <field>
                <name>DRV</name>
                <description>Driver type</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Push-pull</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Open drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>E</name>
                <description>Output drive strength
NOTE: Reset value is 0x3 (12 mA) for registers P4_4, P4_5, P4_6, P4_7</description>
                <bitRange>[22:21]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>2 mA</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>4 mA</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>8 mA</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>12 mA</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>P</name>
                <description>Driver disabled state control</description>
                <bitRange>[20:19]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>High-Z</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Bus keeper</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SR</name>
                <description>Slew rate</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Slow</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Fast</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMT</name>
                <description>Schmitt trigger (hysteresis) enable</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>No hysteresis</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Hysteresis enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>REN</name>
                <description>Receiver enable
NOTE: Reset value is 0x1 for registers P4_4, P4_5, P4_6, P4_7</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Receiver disabled, pin reads return 0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Receiver enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PINMUX</name>
                <description>Pin multiplexing control field
0x1-0xN: Selects other peripherals as shown in table Pin Function Multiplexing of the device series-specific Datasheet.
Un-mapped: Select GPIOn_6
NOTE: Reset value is 0x1 for registers P4_4, P4_5, P4_6, P4_7</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Selects GPIOn_6 signal from GPIOn peripheral</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>P_7</name>
            <description>Control Register for Port n, Pin 7</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00220000</resetValue>
            <resetMask>0x00FF0007</resetMask>
            <fields>
              <field>
                <name>DRV</name>
                <description>Driver type</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Push-pull</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Open drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>E</name>
                <description>Output drive strength
NOTE: Reset value is 0x3 (12 mA) for registers P4_4, P4_5, P4_6, P4_7</description>
                <bitRange>[22:21]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>2 mA</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>4 mA</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>8 mA</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>12 mA</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>P</name>
                <description>Driver disabled state control</description>
                <bitRange>[20:19]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>High-Z</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Bus keeper</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SR</name>
                <description>Slew rate</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Slow</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Fast</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMT</name>
                <description>Schmitt trigger (hysteresis) enable</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>No hysteresis</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Hysteresis enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>REN</name>
                <description>Receiver enable
NOTE: Reset value is 0x1 for registers P4_4, P4_5, P4_6, P4_7</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Receiver disabled, pin reads return 0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Receiver enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PINMUX</name>
                <description>Pin multiplexing control field
0x1-0xN: Selects other peripherals as shown in table Pin Function Multiplexing of the device series-specific Datasheet.
Un-mapped: Select GPIOn_7
NOTE: Reset value is 0x1 for registers P4_4, P4_5, P4_6, P4_7</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Selects GPIOn_7 signal from GPIOn peripheral</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>AON</name>
      <baseAddress>0x1A604000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>72</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>RTSS_HP_CTRL</name>
          <description>M55-HP Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000301</resetMask>
          <fields>
            <field>
              <name>WIC</name>
              <description>Control bits mapped to WICCONTROL[1:0] configuration signal of M55-HP. Bit [9] is mapped to WICCONTROL[1]. Bit [8] is mapped to WICCONTROL[0]. For more information, refer to Arm(R) Cortex(R)-M55 Processor Technical Reference Manual.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COLD_WAKEUP</name>
              <description>Set this bit to wake up M55-HP power domain during cold boot or waking-up from stop mode, clear it once power-on sequence is complete to enable dynamic power transitions of M55-HP.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTSS_HP_RESET</name>
          <description>M55-HP Reset Status Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>RESETSYNDROME</name>
              <description>Reset status set by hardware and cleared by software</description>
              <bitRange>[5:0]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The last reset of M55-HP was caused by POR or Secure Enclave initiated reset </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The last reset of M55-HP was caused by NSRST pin being asserted</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>The last reset of M55-HP was caused by a reset request to the power domain</description>
                  <value>0x4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RTSS_HE_CTRL</name>
          <description>M55-HE Control Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000301</resetMask>
          <fields>
            <field>
              <name>WIC</name>
              <description>Control bits mapped to WICCONTROL[1:0] configuration signal of M55-HE. Bit [9] is mapped to WICCONTROL[1]. Bit [8] is mapped to WICCONTROL[0]. For more information, refer to Arm(R) Cortex(R)-M55 Processor Technical Reference Manual.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COLD_WAKEUP</name>
              <description>Set this bit to wake up M55-HE power domain during cold boot or waking-up from stop mode, clear it once power-on sequence is complete to enable dynamic power transitions of M55-HE.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTSS_HE_RESET</name>
          <description>M55-HE Reset Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>RESETSYNDROME</name>
              <description>Reset status set by hardware and cleared by software</description>
              <bitRange>[5:0]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The last reset of M55-HE was caused by POR or Secure Enclave initiated reset </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The last reset of M55-HE was caused by NSRST pin being asserted</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>The last reset of M55-HE was caused by a reset request to the power domain</description>
                  <value>0x4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RTSS_HE_LPPERI_CKEN</name>
          <description>LP Peripherals Clock Enable Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00030F01</resetMask>
          <fields>
            <field>
              <name>GPIO_IPCLK_FORCE</name>
              <description>Force LPGPIO IP CLK</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock force disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Force peripherals function clocks on, bypass clock gating</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GPIO_PCLK_FORCE</name>
              <description>Force LPGPIO PCLK</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock force disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Force APB interface clocks on, bypass clock gating</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GPIO_CKEN</name>
              <description>Enable LPGPIO IP clock</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable LPGPIO clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable LPGPIO clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GPIO_DB_CKEN</name>
              <description>Enable LPGPIO debounce clock</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable LPGPIO debounce clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable LPGPIO debounce clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UART_CKEN</name>
              <description>Enable clock for LPUART</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSTOP_CLK_DIV</name>
          <description>System Bus Clock Divider Control Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000102</resetValue>
          <resetMask>0x00000303</resetMask>
          <fields>
            <field>
              <name>HCLK_DIVISOR</name>
              <description>SYST_HCLK clock divisor</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Divide by 1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Divide by 2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Divide by 4</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Divide by 4</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PCLK_DIVISOR</name>
              <description>SYST_PCLK clock divisor</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Divide by 1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Divide by 2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Divide by 4</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Divide by 4</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>MISC_REG1</name>
          <description>HFXO Divider Control Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x001E0000</resetMask>
          <fields>
            <field>
              <name>CLKDIV</name>
              <description>HFXO divisor</description>
              <bitRange>[20:17]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Divide by 1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Divide by 2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Divide by 4</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Divide by 8</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Divide by 16</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>Divide by 32</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>Divide by 64</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>Divide by 128</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>Divide by 1</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>Divide by 2</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>Divide by 4</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>Divide by 16</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>Divide by 64</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xD</name>
                  <description>Divide by 128</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xE</name>
                  <description>Divide by 256</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description>Divide by 1024</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_PERIPH</name>
          <description>ADC Control Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00459111</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADC24_BIAS</name>
              <description>ADC24 bias control</description>
              <bitRange>[22:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC24_PGA_GAIN</name>
              <description>ADC24 PGA gain value:</description>
              <bitRange>[19:17]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Do not use</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>6 dB</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>12 dB</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>18 dB</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>24 dB</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>30 dB</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>36 dB</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>42 dB</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC24_PGA_EN</name>
              <description>ADC24 PGA enable</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC24_OUTPUT_RATE</name>
              <description>ADC24 output rate select:
Other values should not be used.</description>
              <bitRange>[15:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b000</name>
                  <description>1 kS/s</description>
                  <value>0b000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b001</name>
                  <description>2 kS/s</description>
                  <value>0b001</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b010</name>
                  <description>4 kS/s</description>
                  <value>0b010</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b011</name>
                  <description>8 kS/s</description>
                  <value>0b011</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b100</name>
                  <description>16 kS/s</description>
                  <value>0b100</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC24_EN</name>
              <description>ADC24 enable</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC3_PGA_GAIN</name>
              <description>ADC122 PGA gain value select:
Other values should not be used.</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b000</name>
                  <description>4 dB</description>
                  <value>0b000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b001</name>
                  <description>8 dB</description>
                  <value>0b001</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b100</name>
                  <description>12 dB</description>
                  <value>0b100</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b101</name>
                  <description>16 dB</description>
                  <value>0b101</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b110</name>
                  <description>20 dB</description>
                  <value>0b110</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC3_PGA_EN</name>
              <description>ADC122 PGA enable
Note: ADC122 must be put into differential mode when PGA is enabled</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC2_PGA_GAIN</name>
              <description>ADC121 PGA gain value select:
Other values should not be used.</description>
              <bitRange>[7:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b000</name>
                  <description>4 dB</description>
                  <value>0b000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b001</name>
                  <description>8 dB</description>
                  <value>0b001</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b100</name>
                  <description>12 dB</description>
                  <value>0b100</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b101</name>
                  <description>16 dB</description>
                  <value>0b101</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b110</name>
                  <description>20 dB</description>
                  <value>0b110</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC2_PGA_EN</name>
              <description>ADC121 PGA enable
Note: ADC121 must be put into differential mode when PGA is enabled</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC1_PGA_GAIN</name>
              <description>ADC120 PGA gain value select:
Other values should not be used.</description>
              <bitRange>[3:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b000</name>
                  <description>4 dB</description>
                  <value>0b000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b001</name>
                  <description>8 dB</description>
                  <value>0b001</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b100</name>
                  <description>12 dB</description>
                  <value>0b100</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b101</name>
                  <description>16 dB</description>
                  <value>0b101</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b110</name>
                  <description>20 dB</description>
                  <value>0b110</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC1_PGA_EN</name>
              <description>ADC120 PGA enable
Note: ADC120 must be put into differential mode when PGA is enabled</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_BYPASS_ENABLE</name>
          <description>OSPI Bypass Enable</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>OSPI1_BYPASS_EN</name>
              <description>OSPI1 Bypass Enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OSPI0_BYPASS_EN</name>
              <description>OSPI0 Bypass Enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>VBAT</name>
      <baseAddress>0x1A609000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>20</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>GPIO_CTRL</name>
          <description>GPIO 1.8 V / 3.3 V Power Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000011</resetMask>
          <fields>
            <field>
              <name>GPIO_MUX_CTRL</name>
              <description>Select which LPGPIO controller has access to the GPIOV_* pins</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>LPGPIO controls the GPIOV_* pins</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>LPGPIO_FAST controls the GPIOV_* pins</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VOLT</name>
              <description>Select voltage level for the 1.8-V/3.3-V (flex) I/O pins</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>I/O pin will be used with a 3.3-V power </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>I/O pin will be used with a 1.8-V power</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIMER_CLKSEL</name>
          <description>LPTIMER Clock Select Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00003333</resetMask>
          <fields>
            <field>
              <name>SEL4</name>
              <description>LPTIMER3 clock select</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>S32K_CLK</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>128K_CLK (128 kHz)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>External clock from LPTMR3_CLK_IO pin</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>LPTIMER2 toggle output (LPTMR2_OUT)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEL3</name>
              <description>LPTIMER2 clock select</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>S32K_CLK</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>128K_CLK (128 kHz)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>External clock from LPTMR2_CLK_IO pin</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>S32K_CLK</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEL2</name>
              <description>LPTIMER1 clock select</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>S32K_CLK</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>128K_CLK (128 kHz)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>External clock from LPTMR1_CLK_IO pin</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>LPTIMER0 toggle output (LPTMR0_OUT)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEL1</name>
              <description>LPTIMER0 clock select</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>S32K_CLK</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>128K_CLK (128 kHz)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>External clock from LPTMR0_CLK_IO pin</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>S32K_CLK</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_CTRL</name>
          <description>Power Control Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x03031333</resetValue>
          <resetMask>0x03033333</resetMask>
          <fields>
            <field>
              <name>VREG_AUX_2_1V8_EN</name>
              <description>Enable for AUX regulator 2</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VREG_AUX_1_1V8_EN</name>
              <description>Enable for AUX regulator 1</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UPHY_ISO</name>
              <description>Enable isolation for USB PHY</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UPHY_PWR_MASK</name>
              <description>Mask off the power for USB PHY</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Power not masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Power masked off</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DPHY_VPH_1P8_PWR_BYP_VAL</name>
              <description>dphy_vph_1p8_pwr_byp_val</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPHY_VPH_1P8_PWR_BYP_EN</name>
              <description>dphy_vph_1p8_pwr_byp_en</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DPHY_PLL_ISO</name>
              <description>Enable isolation for MIPI PLL</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DPHY_PLL_PWR_MASK</name>
              <description>Mask off the power for MIPI PLL</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Power not masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Power masked off</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RX_DPHY_ISO</name>
              <description>Enable isolation for MIPI RX DPHY</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RX_DPHY_PWR_MASK</name>
              <description>Mask off the power for MIPI RX DPHY</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Power not masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Power masked off</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TX_DPHY_ISO</name>
              <description>Enable isolation for MIPI TX DPHY</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TX_DPHY_PWR_MASK</name>
              <description>Mask off the power for MIPI TX DPHY</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Power not masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Power masked off</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RET_CTRL</name>
          <description>Memory Retention Control Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0003FFF3</resetValue>
          <resetMask>0x0003FFF3</resetMask>
          <fields>
            <field>
              <name>OCVM_RET_FORCE</name>
              <description>Memory retention force for SRAM1 RET</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Force enabling the memory retention</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>No force</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OCVM_RET_MASK</name>
              <description>Memory retention force for SRAM1 RET</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No mask</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Disable the memory retention</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CVM_RET4_FORCE</name>
              <description>Memory retention force for SRAM0 RET4</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Force enabling the memory retention</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>No force</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CVM_RET4_MASK</name>
              <description>Memory retention force for SRAM0 RET4</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No mask</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Disable the memory retention</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CVM_RET3_FORCE</name>
              <description>Memory retention force for SRAM0 RET3</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Force enabling the memory retention</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>No force</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CVM_RET3_MASK</name>
              <description>Memory retention force for SRAM0 RET3</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No mask</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Disable the memory retention</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CVM_RET2_FORCE</name>
              <description>Memory retention force for SRAM0 RET2</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Force enabling the memory retention</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>No force</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CVM_RET2_MASK</name>
              <description>Memory retention force for SRAM0 RET2</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No mask</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Disable the memory retention</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CVM_RET1_FORCE</name>
              <description>Memory retention force for SRAM0 RET1</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Force enabling the memory retention</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>No force</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CVM_RET1_MASK</name>
              <description>Memory retention force for SRAM0 RET1</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No mask</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Disable the memory retention</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HETCM_RET2_FORCE</name>
              <description>Memory retention force for M55-HE TCM RET2</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Force enabling the memory retention</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>No force</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HETCM_RET2_MASK</name>
              <description>Memory retention mask for M55-HE TCM RET2</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No mask</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Disable the memory retention</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HETCM_RET1_FORCE</name>
              <description>Memory retention force for M55-HE TCM RET1</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Force enabling the memory retention</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>No force</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HETCM_RET1_MASK</name>
              <description>Memory retention mask for M55-HE TCM RET1</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No mask</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Disable the memory retention</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKRAM_RET_FORCE</name>
              <description>Memory retention force for Utility SRAM</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Force enabling the memory retention</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>No force</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKRAM_RET_MASK</name>
              <description>Memory retention mask for Utility SRAM</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No mask</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Disable the memory retention</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_CLK_EN</name>
          <description>LPRTC Clock Enable Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>CLK_EN</name>
              <description>Enable SYST_PCLK and S32K_CLK for LPRTC. This bit must be set before any programming to LPRTC.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable LPRTC clocks</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable LPRTC clocks</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>ANA</name>
      <baseAddress>0x1A60A000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>68</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>MISC_CTRL</name>
          <description>VBAT Misc Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>SEL_32K</name>
              <description>Select 32KHz clock source</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Select Ring-Oscillator (LFRC)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Select Crystal-Oscillator (LFXO)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>WKUP_CTRL</name>
          <description>VBAT Wake-up Source Control Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000011</resetValue>
          <resetMask>0x00FF0FFF</resetMask>
          <fields>
            <field>
              <name>LPGPIO</name>
              <description>Each bit controls enable/disable of a wake-up source from LPGPIO</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable wake-up source</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable wake-up source</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPTIMER</name>
              <description>Each bit controls enable/disable of a wake-up source from LPTIMER</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable wake-up source</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable wake-up source</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BROWN_OUT</name>
              <description>Controls enable/disable of wake-up source from Brown-Out Detect (Falling Edge).
This register bit is also used to clear the wake-up source by SE CPU.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable and Clear wake-up source</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable wake-up source</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPCMP</name>
              <description>Controls enable/disable of wake-up source from LPCMP</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable wake-up source</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable wake-up source</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RTCA</name>
              <description>Controls enable/disable of wake-up source from LPRTC</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable wake-up source</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable wake-up source</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_REG1</name>
          <description>DC/DC Control Register 1</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xA14DE693</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRIM_CRAMP</name>
              <description>Feed forward ramp capacitor adjust</description>
              <bitRange>[31:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RAMP_CONT</name>
              <description>Select VDD_MAIN feed forward ramp current.
For VDD_MAIN = 3.6 V:
Min: 000 = 6 uA
Max: 111 = 13 uA 
Step: 1 uA
This current is proportional to VDD_MAIN voltage.</description>
              <bitRange>[29:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_MIN_TON</name>
              <description>If = 1, disables the minimum 'ON time' of HS FET (PMOS), and minimum 'ON time' of LS FET (NMOS).</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_SS_DLY_CONT</name>
              <description>Trim EN_SS signal delay:
 Min is 0000: 0 clock cycles delay
 Max is 1111: 15 clock cycles delay
Clock is DC-DC clock divided by 8 (~250 kHz for nominal settings)</description>
              <bitRange>[25:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_DRV_DLY_CONT</name>
              <description>Trim EN_DRV signal delay:
 Min is 0000 = 0 clock cycles delay
 Max is 1111 = 15 clock cycles delay
Clock is DC-DC clock divided by 8 (~250 kHz for nominal settings)</description>
              <bitRange>[21:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DCDC_EN_XTAL_CLK</name>
              <description>Switch DC-DC PWM clock from internal 2-MHz oscillator to 2-MHz crystal oscillator when = 1.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DCDC_CTRL_FET</name>
              <description>Selects the drive strength of DC-DC NFET power transistor</description>
              <bitRange>[16:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DCDC_OSC2M_IBIAS</name>
              <description>Trim DC-DC 2-MHz internal oscillator:
 Min is 0000: 1.5 MHz
Max is 1111: 3.75 MHz
Step = ~0.15 MHz</description>
              <bitRange>[12:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DCDC_TRIM_VOUT</name>
              <description>Select DC-DC regulation reference voltage (in % from default VOUT):</description>
              <bitRange>[8:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>-19%</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>-18%</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x10</name>
                  <description>-17%</description>
                  <value>0x10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x18</name>
                  <description>-16%</description>
                  <value>0x18</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x20</name>
                  <description>-15%</description>
                  <value>0x20</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x28</name>
                  <description>-14%</description>
                  <value>0x28</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x30</name>
                  <description>-13%</description>
                  <value>0x30</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x38</name>
                  <description>-12%</description>
                  <value>0x38</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>-11%</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>-10%</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x11</name>
                  <description>-8%</description>
                  <value>0x11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x19</name>
                  <description>-7%</description>
                  <value>0x19</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x21</name>
                  <description>-6%</description>
                  <value>0x21</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x29</name>
                  <description>-5%</description>
                  <value>0x29</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x31</name>
                  <description>-4%</description>
                  <value>0x31</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x39</name>
                  <description>-3%</description>
                  <value>0x39</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>-2%</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>-1%</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x12</name>
                  <description>0% (default 0.76 V DC-DC VOUT)</description>
                  <value>0x12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1A</name>
                  <description>+1%</description>
                  <value>0x1A</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x22</name>
                  <description>+2%</description>
                  <value>0x22</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2A</name>
                  <description>+3%</description>
                  <value>0x2A</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x32</name>
                  <description>+4%</description>
                  <value>0x32</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3A</name>
                  <description>+5%</description>
                  <value>0x3A</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>+6%</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>+7%</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x13</name>
                  <description>+8%</description>
                  <value>0x13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1B</name>
                  <description>+9%</description>
                  <value>0x1B</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x23</name>
                  <description>+10%</description>
                  <value>0x23</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2B</name>
                  <description>+11%</description>
                  <value>0x2B</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x33</name>
                  <description>+12%</description>
                  <value>0x33</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3B</name>
                  <description>+13%</description>
                  <value>0x3B</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_LS_ON</name>
              <description>Force low-side Power FET to be on (NMOS Power FET), PWM signal will be kept low.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DCDC_EN_CLAMP_LO</name>
              <description>Enable Vcomp clamp for voltages less than 400 mV: </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Disable clamp</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Enable clamp</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DCDC_EN_CLAMP_HI</name>
              <description>Enable Vcomp clamp for voltages over 1.3 V:</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Disable clamp</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Enable clamp</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_REG2</name>
          <description>DC/DC Control Register 2</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0B014444</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DCDC_XTAL_DIV_EN</name>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable DC-DC high-frequency XTAL frequency divider.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DCDC_XTAL_DIV_CONT</name>
              <description>High-frequency XTAL frequency divider division value:
 Fout = Fxtal / (2 x DCDC_XTAL_DIV_CONT)</description>
              <bitRange>[30:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DCDC_PFM_EN</name>
              <description>When cleared to 0, DC-DC operates in PWM mode. When set to 1, DC-DC operates in PFM mode (low quiescent current power saving mode). The DC-DC mode change is immediate.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DIS_MIN_TOFF</name>
              <description>Disable minimum Toff</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIM_GAIN_LSENSE</name>
              <description>Trim Current Sense Gain. 
 bit 4: sign bit (1: Positive, 0: Negative)
Min: 01111: -25%
 Max: 11111: +25%
 Step: 1.6%</description>
              <bitRange>[21:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIM_ONESHOT_CAP</name>
              <description>Trim one-shot capacitor</description>
              <bitRange>[16:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_LDO_CONT</name>
              <description>MIPI PHY LDO (LDO-6) output voltage control: 
Step: 20 mV</description>
              <bitRange>[14:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b0000</name>
                  <description>1.6 V</description>
                  <value>0b0000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1111</name>
                  <description>1.9 V</description>
                  <value>0b1111</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ONESHOT_L_CONT</name>
              <description>One-shot control</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STANDBY_MODE</name>
              <description>When set to 1, HFRC will be divided by the value in VBAT_ANA_REG2[OSC_76M_DIV_CTRL_STBY] field. Bit STANDBY_AUTO_SWITCH_EN bit must be 0.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STANDBY_AUTO_SWITCH_EN</name>
              <description>When set to 1, HFRC will be divided by the value in VBAT_ANA_REG2[OSC_76M_DIV_CTRL_ACTIVE] when the device is active and the HFRC will be divided by the value in VBAT_ANA_REG2[OSC_76M_DIV_CTRL_STBY] when the device is in standby. When cleared to 0, HFRC divider selection is controlled by VBAT_ANA_REG2.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIM_RCOMP</name>
              <description>Trim for loop filter resistor. </description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>shorts out loop resistor</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>enables loop resistor</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRIM_ZCD</name>
              <description>Trim for PFM ZCD comparator offset voltage</description>
              <bitRange>[4:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIM_SS</name>
              <description>Trim for soft start timing:
Step: 5 us</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b000</name>
                  <description>10 us </description>
                  <value>0b000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b111</name>
                  <description>45 us </description>
                  <value>0b111</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>VBAT_ANA_REG1</name>
          <description>VBAT Analog Control Register 1</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x06441F80</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BOR_THRESH</name>
              <description>Control for BOR threshold level:
Step: 24 mV</description>
              <bitRange>[31:29]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b000</name>
                  <description>1.53 mV</description>
                  <value>0b000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b111</name>
                  <description>1.802 mV</description>
                  <value>0b111</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BOR_HYST</name>
              <description>Control for BOR hysteresis:
Step: 22.857 mV</description>
              <bitRange>[28:26]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b000</name>
                  <description>0 mV</description>
                  <value>0b000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b111</name>
                  <description>160 mV</description>
                  <value>0b111</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BOR_EN</name>
              <description>Enables brown-out reset circuit.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XTAL32K_CAP_CONT</name>
              <description>Shunt capacitor control for 32-kHz XTAL oscillator: 
 Step: 0.25 pF</description>
              <bitRange>[24:19]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b000000</name>
                  <description>2 pF</description>
                  <value>0b000000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b111111</name>
                  <description>16 pF</description>
                  <value>0b111111</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>XTAL32K_GM_CONT</name>
              <description>gM control for 32-kHz XTAL oscillator: </description>
              <bitRange>[18:15]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b0000</name>
                  <description>no gM (off) </description>
                  <value>0b0000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1111</name>
                  <description>max gM</description>
                  <value>0b1111</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPCOMP_CLK32K_EN</name>
              <description>Enables 32-kHz clock to LPCMP comparator.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XTAL32K_KICK</name>
              <description>Starts 32-kHz XTAL oscillator.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XTAL32K_EN</name>
              <description>Enables 32-kHz XTAL oscillator.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RET_LDO_VDD_MAIN_SHUNT_EN</name>
              <description>Enables 38-Mohm shunt resistor on LDO-2.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RET_LDO_VDDMAIN_EN</name>
              <description>Enables LDO-2 for SRAM0, SRAM1, SE SRAM, and M55-HE TCM retention.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RET_LDO_VBAT_SHUNT_EN</name>
              <description>Enables 38-Mohm shunt resistor on LDO-0.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RET_LDO_VBAT_EN</name>
              <description>Enables LDO-0 for AON Utility SRAM retention.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RET_LDO_CONT_3_0</name>
              <description>Controls both LDO-0 and LDO-2 output voltages:
Step: 22.2 mV</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b0000</name>
                  <description>500 mV</description>
                  <value>0b0000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1111</name>
                  <description>833 mV</description>
                  <value>0b1111</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OSC_RC_32K_FREQ_CONT</name>
              <description>Controls NTAT current into 32-kHz RC oscillator.
Average step size is 1%, but nonlinear: 0.5% step at low codes and ~1.8% steps at high codes.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b0000</name>
                  <description>-5%</description>
                  <value>0b0000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1111</name>
                  <description>+10%</description>
                  <value>0b1111</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>VBAT_ANA_REG2</name>
          <description>VBAT Analog Control Register 2</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x000C0630</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMP_LP0_HYST</name>
              <description>Sets LPCMP hysteresis level. 6-mV steps.</description>
              <bitRange>[31:29]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>0 mV</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>45 mV</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COMP_LP0_IN_M_SEL</name>
              <description>Selects input to negative terminal of LPCMP:</description>
              <bitRange>[28:27]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Internal AON Vref (0.8 V)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>VREF_IN0 pin</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>VREF_IN1 pin</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>VREF_IN2 pin</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COMP_LP0_IN_P_SEL</name>
              <description>Selects input to positive terminal of LPCMP:</description>
              <bitRange>[26:25]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description> LPCMP_IN0 pin</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>LPCMP_IN1 pin</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>LPCMP_IN2 pin</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>LPCMP_IN3 pin</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COMP_LP_EN</name>
              <description>Enables LPCMP.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ANA_PERIPH_LDO_EN</name>
              <description>Enable Analog Peripherals LDO (LDO-5).</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ANA_PERIPH_BG_ENA</name>
              <description>Enable precision bandgap for analog peripherals.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OSC_76M_DIV_CTRL_STBY</name>
              <description>76-MHz oscillator divider control in STANDBY mode.</description>
              <bitRange>[21:19]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description> 76.8 MHz</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>38.4 MHz</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>19.2 MHz</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>4.8 MHz</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description> 1.2 MHz</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description> 600 kHz</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description> 300 kHz</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>75 kHz</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OSC_76MRC_CTRL_51</name>
              <description>Control for 76-MHz RC oscillator frequency (bits [5-1]). Used with bit OSC_76MRC_CTRL_0 (bit[0]).
Step: 1.0%</description>
              <bitRange>[18:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b00000</name>
                  <description> -31% (bit OSC_76MRC_CTRL_0 = 0)</description>
                  <value>0b00000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b11111</name>
                  <description> +32% (bit OSC_76MRC_CTRL_0 = 1)</description>
                  <value>0b11111</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OSC_76M_DIV_CTRL_ACTIVE</name>
              <description>76-MHz oscillator divider control in GO, READY, and IDLE modes.</description>
              <bitRange>[13:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description> 76.8 MHz</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>38.4 MHz</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>19.2 MHz</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>9.6 MHz</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description> 4.8 MHz</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description> 2.4 MHz</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description> 1.2 MHz</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>600 kHz</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OSC_76MRC_CTRL_0</name>
              <description>Control for 76-MHz RC oscillator frequency, LSB. Used with [OSC_76MRC_CTRL_51] field. 1% steps.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DIG_LDO_CONT</name>
              <description>LDO-4 output voltage control:
Step: 20 mV</description>
              <bitRange>[9:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b0000</name>
                  <description> 1.58 V</description>
                  <value>0b0000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1111</name>
                  <description> 1.88 V</description>
                  <value>0b1111</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIG_LDO_18_EN</name>
              <description>Enables 1.8-V digital LDO (LDO-4).
 Used for MRAM and EFUSE.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMUBG_VREF_CONT</name>
              <description>Calibration for PMU bandgap (desired 1.0 V):
Step: 1%</description>
              <bitRange>[4:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b0000</name>
                  <description>+8%</description>
                  <value>0b0000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1111</name>
                  <description>-7%</description>
                  <value>0b1111</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>VBAT_ANA_REG3</name>
          <description>VBAT Analog Control Register 3</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x7C448004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LPCOMP_CLK_SEL</name>
              <description>Selects clock source for LPCMP:</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description> 32-kHz XTAL oscillator (LFXO)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>32-kHz RC oscillator (LFRC)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AON_LDO_CONT</name>
              <description>AON LDO (LDO-1) output voltage trim:
Step: 10.67 mV</description>
              <bitRange>[30:27]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b0000</name>
                  <description> 660 mV</description>
                  <value>0b0000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1111</name>
                  <description> 820 mV</description>
                  <value>0b1111</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AON_BG_CONT</name>
              <description>AON bandgap voltage trim (desired 0.8 V), bits [4-1]:
Step: 9.67 mV
Bit [0] is [7] AON_BG_CONT0.</description>
              <bitRange>[26:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MRAM_VTRIM</name>
              <description>MRAM offset trim</description>
              <bitRange>[22:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MRAM_CTRIM</name>
              <description>MRAM curvature trim</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MRAM_VREF_EN</name>
              <description>Enables MRAM VREF block</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_THRESH</name>
              <description>Control for BOD threshold level:
Step: 24 mV</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b000</name>
                  <description>1.634 V</description>
                  <value>0b000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b111</name>
                  <description>1.802 V</description>
                  <value>0b111</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BOD_HYST</name>
              <description>Control for BOD hysteresis:
Step: 22.857 mV</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b000</name>
                  <description>0 mV</description>
                  <value>0b000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b111</name>
                  <description>160 mV</description>
                  <value>0b111</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BOD_EN</name>
              <description>Enables brown-out detector.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AON_BG_CONT0</name>
              <description>AON bandgap voltage trim (desired 0.8 V), bit [0].
For bits [4-1], see field [26-23] AON_BG_CONT.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LDO_MAIN_CONT</name>
              <description>PMU 1.8-V LDO (LDO-3) output voltage control:
Step = 21.43 mV</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b000</name>
                  <description> 1.71 V</description>
                  <value>0b000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b111</name>
                  <description> 1.86 V</description>
                  <value>0b111</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>STOP_MODE</name>
      <baseAddress>0x1A60F000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>VBAT_STOP_MODE_REG</name>
          <description>VBAT Stop Mode Control and Status Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000111</resetMask>
          <fields>
            <field>
              <name>DC_DC_STAT</name>
              <description>DC-DC Status
Reflects the real-time status of DC-DC power</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DC-DC is ON</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DC-DC is OFF</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STOP_MODE_STAT</name>
              <description>Stop Mode Status
- HW sets this bit when DC-DC was turned off
- SW clears this bit by writing 0x1</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>STOP_MODE_CTRL</name>
              <description>Stop Mode Control
- SW sets this bit to enter stop mode
- HW clears this bit when there is a wake-up event</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>MHU_A32_M55HP_0_RX</name>
      <baseAddress>0x40000000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>32</dimIncrement>
          <name>MHU_RX_CHANNEL_CFG[%s]</name>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>MHU_CH_ST</name>
            <description>Channel (n) Status Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FLAG_x</name>
                <description>Channel flag status
Each bit can be used as individual flag or bits can be grouped. The usage depends upon the transport protocol used. 
Bits in this register are set by writing 1 to the corresponding bit in the MHU_CHn_SET register.
Bits in this register are cleared by writing 1 to the corresponding bit the MHU_CHn_CLRregister.
 If software:
- Sets a bit that is already set, the bit remains set.
- Clears a bit that is already cleared, the bit remains cleared.
- Sets and clears a bit at the same time, the bit remains set.
It is strongly recommended that software follows the transport protocols defined in
Section MHU Functional Description.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MHU_CH_ST_MSK</name>
            <description>Channel (n) Status Masked Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FLAG_MSK_x</name>
                <description>Channel flag status after the mask is applied.
When this field is nonzero, the interrupt for the channel is asserted. 
 The value (VALUE) in this register is: 
Value = MHU_CHn_ST &amp; ( ~MHU_CHn_MSK_ST), at the point theread occurs.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MHU_CH_CLR</name>
            <description>Channel Clear Register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FLAG_CLR_x</name>
                <description>Channel flag clear
 Write 1 to a bit clears the corresponding bit in the MHU_CHn_ST and MHU_CHn_ST_MSK.
Writing 0 has no effect. 
Each bit always reads as 0.</description>
                <bitRange>[31:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MHU_CH_MSK_ST</name>
            <description>Channel (n) Mask Status Register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FLAG_MSK_x</name>
                <description>Channel flag mask
When a bit is unmasked, the corresponding bits in the MHU_CHn_ST and MHU_CHn_ST_MSKregisters have the same value.
When a bit is masked, the corresponding bit in the MHU_CHn_ST_MSK register alwaysreads as 0.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Flag bit is unmasked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Flag bit is masked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>MHU_CH_MSK_SET</name>
            <description>Channel (n) Mask Set Register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FLAG_MSK_SET_x</name>
                <description>Channel flag mask set
Writing 1 to a bit sets the corresponding bit in the MHU_CHn_MSK_ST register.
Writing 0 has no effect.
Each bit always reads as 0.</description>
                <bitRange>[31:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MHU_CH_MSK_CLR</name>
            <description>Channel (n) Mask Clear Register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FLAG_MSK_CLR_x</name>
                <description>Channel flag mask clear
Write 1 to a bit clears the corresponding bit in the MHU_CHn_MSK_ST register.
Writing 0 has no effect.
Each bit always reads as 0.</description>
                <bitRange>[31:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>MHU_CFG</name>
          <description>Module Configuration Register</description>
          <addressOffset>0xF80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CFG_DEF</name>
              <description>Number of channels</description>
              <bitRange>[6:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>2 channels</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_INT_ST</name>
          <description>Interrupt Status Register</description>
          <addressOffset>0xF90</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHCOMB</name>
              <description>Channel Combined interrupt status
There is no corresponding bit in the MHU_INT_CLR register. To clear this interrupt, softwaremust clear the underlying interrupt.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No interrupt has occurred on any channel.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>An interrupt has occurred on at least one channel.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R2NR</name>
              <description>Ready to Not Ready interrupt status</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Ready to Not Ready interrupt has not occurred.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Ready to Not Ready interrupt has occurred.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NR2R</name>
              <description>Not Ready to Ready interrupt status</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not Ready to Ready interrupt has not occurred.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Not Ready to Ready interrupt has occurred.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_INT_CLR</name>
          <description>Interrupt Clear Register</description>
          <addressOffset>0xF94</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>R2NR</name>
              <description>Clear Ready to Not Ready interrupt
Write 1 to clear the interrupt.
 Writing 0 has no effect.</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>NR2R</name>
              <description>Clear Not Ready to Ready interrupt
Write 1 to clear the interrupt. 
Writing 0 has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_INT_EN</name>
          <description>Interrupt Enable Register</description>
          <addressOffset>0xF98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHCOMB</name>
              <description>Channel Combined interrupt enable</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Combined interrupt is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Combined interrupt is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R2NR</name>
              <description>Ready to Not Ready interrupt enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disables the generation of Ready to Not Ready interrupt.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables the generation of Ready to Not Ready interrupt.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NR2R</name>
              <description>Not Ready to Ready interrupt enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disables the generation of Not Ready to Ready interrupt.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables the generation of Not Ready to Ready interrupt.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_CHCOMB_INT_ST0</name>
          <description>Channel Combined Interrupt Status Register for Channels 0-31</description>
          <addressOffset>0xFA0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH_INT_ST_x</name>
              <description>Interrupt status for 0-31 channels
Each bit indicates whether a channel has a pending interrupt or not.
A bit relating to an unimplemented channel is Reserved and treated as RAZ/WI.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_CHCOMB_INT_ST1</name>
          <description>Channel Combined Interrupt Status Register for Channels 32-63</description>
          <addressOffset>0xFA4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH_INT_ST_x</name>
              <description>Interrupt status for 32-63 channels
Each bit indicates whether a channel has a pending interrupt or not.
A bit relating to an unimplemented channel is Reserved and treated as RAZ/WI.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_CHCOMB_INT_ST2</name>
          <description>Channel Combined Interrupt Status Register for Channels 64-95</description>
          <addressOffset>0xFA8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH_INT_ST_x</name>
              <description>Interrupt status for 64-95 channels
Each bit indicates whether a channel has a pending interrupt or not.
A bit relating to an unimplemented channel is Reserved and treated as RAZ/WI.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_CHCOMB_INT_ST3</name>
          <description>Channel Combined Interrupt Status Register for Channels 96-123</description>
          <addressOffset>0xFAC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH_INT_ST_x</name>
              <description>Interrupt status for 96-123 channels
Each bit indicates whether a channel has a pending interrupt or not.
A bit relating to an unimplemented channel is Reserved and treated as RAZ/WI.</description>
              <bitRange>[27:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_IIDR</name>
          <description>Implementer Identification Register</description>
          <addressOffset>0xFC8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0760043B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRODUCT_ID</name>
              <description>MHU part ID</description>
              <bitRange>[31:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VARIANT</name>
              <description>Major revision of the MHU</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REVISION</name>
              <description>Minor revisions of the MHU</description>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IMPLEMENTER</name>
              <description>Contains the JEP106 code:
[11-8] JEP106 continuation code of implementer
[7] Always 0
[6-0] JEP106 identity code of implementer</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_AIDR</name>
          <description>Architecture Identification Register</description>
          <addressOffset>0xFCC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000011</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ARCH_MAJOR_REV</name>
              <description>MHU architecture major revision
Others: Reserved</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MHUv2</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ARCH_MINOR_REV</name>
              <description>MHU architecture minor revision
Others: Reserved</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Minor revision 0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Minor revision 1</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_PID4</name>
          <description>Peripheral ID 4 Register</description>
          <addressOffset>0xFD0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SIZE</name>
              <description>Number of 4KB occupied by the System ID block.
This field is deprecated.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DES_2</name>
              <description>JEP continuation</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_PID0</name>
          <description>Peripheral ID 0 Register</description>
          <addressOffset>0xFE0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000076</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PART_0</name>
              <description>Bits [7:0] of part ID.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_PID1</name>
          <description>Peripheral ID 1 Register</description>
          <addressOffset>0xFE4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000B0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DES_0</name>
              <description>Bits [3:0] of JEP 106 identity.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PART_1</name>
              <description>Bits [11:8] of part ID.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_PID2</name>
          <description>Peripheral ID 2 Register</description>
          <addressOffset>0xFE8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0000000B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REVISION</name>
              <description>Major revision of the System ID block.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>JEDEC</name>
              <description>Indicates the use of JEDEC JEP106 identification scheme.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DES_1</name>
              <description>Bits [6:4] of JEP 106 identity.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_PID3</name>
          <description>Peripheral ID 3 Register</description>
          <addressOffset>0xFEC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REVAND</name>
              <description>Minor revision of the System ID block.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMOD</name>
              <description>Customer modification field.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_CID0</name>
          <description>Component ID 0 Register</description>
          <addressOffset>0xFF0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0000000D</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRMBL_0</name>
              <description>Preamble 0</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_CID1</name>
          <description>Component ID 1 Register</description>
          <addressOffset>0xFF4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000F0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLASS</name>
              <description>Class of the component.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PRMBL_1</name>
              <description>Preamble 1</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_CID2</name>
          <description>Component ID 2 Register</description>
          <addressOffset>0xFF8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRMBL_2</name>
              <description>Preamble 2</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_CID3</name>
          <description>Component ID 3 Register</description>
          <addressOffset>0xFFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000B1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRMBL_3</name>
              <description>Preamble 3</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>MHU_M55HP_A32_0_TX</name>
      <baseAddress>0x40010000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>32</dimIncrement>
          <name>MHU_TX_CHANNEL_CFG[%s]</name>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>MHU_CH_ST</name>
            <description>Channel (n) Status Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FLAG_x</name>
                <description>Channel flag status
Each bit can be used as individual flag or bits can be grouped. The usage depends upon the transport protocol used. 
Bits in this register are set by writing 1 to the corresponding bit in the MHU_CHn_SET register.
Bits in this register are cleared by writing 1 to the corresponding bit the MHU_CHn_CLRregister.
 If software:
- Sets a bit that is already set, the bit remains set.
- Clears a bit that is already cleared, the bit remains cleared.
- Sets and clears a bit at the same time, the bit remains set.
It is strongly recommended that software follows the transport protocols defined in
Section MHU Functional Description.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MHU_CH_SET</name>
            <description>Channel (n) Set Register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FLAG_SET_x</name>
                <description>Channel flag set
 Write 1 to a bit sets the corresponding bit in the MHU_CHn_ST. 
Writing 0 has no effect. 
Each bit always reads as 0.</description>
                <bitRange>[31:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MHU_CH_INT_ST</name>
            <description>Channel (n) Interrupt Status Register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CH_CLR</name>
                <description>Channel Clear Interrupt status bit
CH_CLR bit is:
 Set to 1 when the Receiver writes to MHU_CHn_CLR registers. 
Note: If the Sender domain is not powered on, or is held in reset at the point the write occurs, then there is no requirement for the field to be set to 1. 
 Set to 0 when the Sender writes 1 to the MHU_CHn_INT_CLR[CH_CLR] bit.
 Setting MHU_CHn_INT_ST [CH_CLR] bit to 1 takes priority of setting the bit to 0.
The value of the MHU_CHn_INT_EN[CH_CLR] bit has no effect on the value of MHU_CHn_INT_ST register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>No Channel Clear interrupt has occurred.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>A Channel Clear interrupt has occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>MHU_CH_INT_CLR</name>
            <description>Channel (n) Interrupt Clear Register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CH_CLR</name>
                <description>Clears MHU_CHn_INT_ST[CH_CLR] bit.
Write 1 to clear the interrupt. 
Writing 0 has no effect.
This field always reads as 0.</description>
                <bitRange>[0:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MHU_CH_INT_EN</name>
            <description>Channel (n) Interrupt Enable Register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CH_CLR</name>
                <description>Channel Clear interrupt enable</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Channel Clear interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Channel Clear interrupt enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>MHU_CFG</name>
          <description>Module Configuration Register</description>
          <addressOffset>0xF80</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CFG_DEF</name>
              <description>Number of channels</description>
              <bitRange>[6:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>2 channels</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_RESP_CFG</name>
          <description>Response Configuration Register</description>
          <addressOffset>0xF84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NR_RESP</name>
              <description>Response generated when the Sender attempts to access any register of a channel, when
MHU_ACCESS_REQUEST[ACC_REQ] bit is 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Access is treated as RAZ/WI with no error generated.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Access is treated as RAZ/WI and an error is generated.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_ACCESS_REQUEST</name>
          <description>Access Request Register</description>
          <addressOffset>0xF88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACC_REQ</name>
              <description>Access Request</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receiver is not requested to be ready to receive transfer.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receiver is requested to be ready to receive transfer.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_ACCESS_READY</name>
          <description>Access Ready Register</description>
          <addressOffset>0xF8C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACC_RDY</name>
              <description>Access Ready</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receiver is not ready to receive transfer.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receiver is ready to receive transfer.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_INT_ST</name>
          <description>Interrupt Status Register</description>
          <addressOffset>0xF90</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHCOMB</name>
              <description>Channel Combined interrupt status
There is no corresponding bit in the MHU_INT_CLR register. To clear this interrupt, softwaremust clear the underlying interrupt.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No interrupt has occurred on any channel.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>An interrupt has occurred on at least one channel.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R2NR</name>
              <description>Ready to Not Ready interrupt status</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Ready to Not Ready interrupt has not occurred.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Ready to Not Ready interrupt has occurred.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NR2R</name>
              <description>Not Ready to Ready interrupt status</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not Ready to Ready interrupt has not occurred.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Not Ready to Ready interrupt has occurred.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_INT_CLR</name>
          <description>Interrupt Clear Register</description>
          <addressOffset>0xF94</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>R2NR</name>
              <description>Clear Ready to Not Ready interrupt
Write 1 to clear the interrupt.
 Writing 0 has no effect.</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>NR2R</name>
              <description>Clear Not Ready to Ready interrupt
Write 1 to clear the interrupt. 
Writing 0 has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_INT_EN</name>
          <description>Interrupt Enable Register</description>
          <addressOffset>0xF98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHCOMB</name>
              <description>Channel Combined interrupt enable</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Combined interrupt is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Combined interrupt is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R2NR</name>
              <description>Ready to Not Ready interrupt enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disables the generation of Ready to Not Ready interrupt.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables the generation of Ready to Not Ready interrupt.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NR2R</name>
              <description>Not Ready to Ready interrupt enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disables the generation of Not Ready to Ready interrupt.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables the generation of Not Ready to Ready interrupt.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_CHCOMB_INT_ST0</name>
          <description>Channel Combined Interrupt Status Register for Channels 0-31</description>
          <addressOffset>0xFA0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH_INT_ST_x</name>
              <description>Interrupt status for 0-31 channels
Each bit indicates whether a channel has a pending interrupt or not.
A bit relating to an unimplemented channel is Reserved and treated as RAZ/WI.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_CHCOMB_INT_ST1</name>
          <description>Channel Combined Interrupt Status Register for Channels 32-63</description>
          <addressOffset>0xFA4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH_INT_ST_x</name>
              <description>Interrupt status for 32-63 channels
Each bit indicates whether a channel has a pending interrupt or not.
A bit relating to an unimplemented channel is Reserved and treated as RAZ/WI.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_CHCOMB_INT_ST2</name>
          <description>Channel Combined Interrupt Status Register for Channels 64-95</description>
          <addressOffset>0xFA8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH_INT_ST_x</name>
              <description>Interrupt status for 64-95 channels
Each bit indicates whether a channel has a pending interrupt or not.
A bit relating to an unimplemented channel is Reserved and treated as RAZ/WI.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_CHCOMB_INT_ST3</name>
          <description>Channel Combined Interrupt Status Register for Channels 96-123</description>
          <addressOffset>0xFAC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH_INT_ST_x</name>
              <description>Interrupt status for 96-123 channels
Each bit indicates whether a channel has a pending interrupt or not.
A bit relating to an unimplemented channel is Reserved and treated as RAZ/WI.</description>
              <bitRange>[27:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_IIDR</name>
          <description>Implementer Identification Register</description>
          <addressOffset>0xFC8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0760043B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRODUCT_ID</name>
              <description>MHU part ID</description>
              <bitRange>[31:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VARIANT</name>
              <description>Major revision of the MHU</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REVISION</name>
              <description>Minor revisions of the MHU</description>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IMPLEMENTER</name>
              <description>Contains the JEP106 code:
[11-8] JEP106 continuation code of implementer
[7] Always 0
[6-0] JEP106 identity code of implementer</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_AIDR</name>
          <description>Architecture Identification Register</description>
          <addressOffset>0xFCC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000011</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ARCH_MAJOR_REV</name>
              <description>MHU architecture major revision
Others: Reserved</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MHUv2</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ARCH_MINOR_REV</name>
              <description>MHU architecture minor revision
Others: Reserved</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Minor revision 0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Minor revision 1</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_PID4</name>
          <description>Peripheral ID 4 Register</description>
          <addressOffset>0xFD0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SIZE</name>
              <description>Number of 4KB occupied by the System ID block.
This field is deprecated.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DES_2</name>
              <description>JEP continuation</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_PID0</name>
          <description>Peripheral ID 0 Register</description>
          <addressOffset>0xFE0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000076</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PART_0</name>
              <description>Bits [7:0] of part ID.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_PID1</name>
          <description>Peripheral ID 1 Register</description>
          <addressOffset>0xFE4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000B0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DES_0</name>
              <description>Bits [3:0] of JEP 106 identity.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PART_1</name>
              <description>Bits [11:8] of part ID.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_PID2</name>
          <description>Peripheral ID 2 Register</description>
          <addressOffset>0xFE8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0000000B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REVISION</name>
              <description>Major revision of the System ID block.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>JEDEC</name>
              <description>Indicates the use of JEDEC JEP106 identification scheme.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DES_1</name>
              <description>Bits [6:4] of JEP 106 identity.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_PID3</name>
          <description>Peripheral ID 3 Register</description>
          <addressOffset>0xFEC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REVAND</name>
              <description>Minor revision of the System ID block.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMOD</name>
              <description>Customer modification field.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_CID0</name>
          <description>Component ID 0 Register</description>
          <addressOffset>0xFF0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0000000D</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRMBL_0</name>
              <description>Preamble 0</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_CID1</name>
          <description>Component ID 1 Register</description>
          <addressOffset>0xFF4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000F0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLASS</name>
              <description>Class of the component</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PRMBL_1</name>
              <description>Preamble 1</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_CID2</name>
          <description>Component ID 2 Register</description>
          <addressOffset>0xFF8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRMBL_2</name>
              <description>Preamble 2</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_CID3</name>
          <description>Component ID 3 Register</description>
          <addressOffset>0xFFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000B1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRMBL_3</name>
              <description>Preamble 3</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="MHU_A32_M55HP_0_RX">
      <name>MHU_A32_M55HP_1_RX</name>
      <baseAddress>0x40020000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="MHU_M55HP_A32_0_TX">
      <name>MHU_M55HP_A32_1_TX</name>
      <baseAddress>0x40030000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="MHU_A32_M55HP_0_RX">
      <name>MHU_SECPU_M55HP_0_RX</name>
      <baseAddress>0x40040000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="MHU_M55HP_A32_0_TX">
      <name>MHU_M55HP_SECPU_0_TX</name>
      <baseAddress>0x40050000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="MHU_A32_M55HP_0_RX">
      <name>MHU_SECPU_M55HP_1_RX</name>
      <baseAddress>0x40060000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="MHU_M55HP_A32_0_TX">
      <name>MHU_M55HP_SECPU_1_TX</name>
      <baseAddress>0x40070000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="MHU_A32_M55HP_0_RX">
      <name>MHU_M55HE_M55HP_0_RX</name>
      <baseAddress>0x40080000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="MHU_M55HP_A32_0_TX">
      <name>MHU_M55HP_M55HE_0_TX</name>
      <baseAddress>0x40090000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="MHU_A32_M55HP_0_RX">
      <name>MHU_M55HE_M55HP_1_RX</name>
      <baseAddress>0x400A0000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="MHU_M55HP_A32_0_TX">
      <name>MHU_M55HP_M55HE_1_TX</name>
      <baseAddress>0x400B0000</baseAddress>
    </peripheral>
    <peripheral>
      <name>DMA1_SEC</name>
      <groupName>DMA</groupName>
      <baseAddress>0x400C0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>DMA_DSR</name>
          <description>DMA Manager Status Register </description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DNS</name>
              <description>This bit provides the security status of the DMA manager thread.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DMA manager operates in the secure state.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA manager operates in the non-secure state.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAKEUP_EVENT</name>
              <description>When the DMA manager thread executes a DMAWFE instruction, it waits for the following event to occur:</description>
              <bitRange>[8:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>event[0].</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>event[1].</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>event[2].</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1F</name>
                  <description>event[31].</description>
                  <value>0x1F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DMA_STATUS</name>
              <description>This bit field presents the operating state of the DMA manager.
For more information, see Section Thread Operating States.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Stopped.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Executing.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Cache miss.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Updating PC.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Waiting for event.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description>Faulting.</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_DPC</name>
          <description>DMA Program Counter Register </description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PC_MGR</name>
              <description>Program counter for the DMA manager thread.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_INTEN</name>
          <description>Interrupt Enable Register </description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EVENT_IRQ_SELECT</name>
              <description>Program the appropriate bit to control how the DMAC responds when it executes DMASEV.
Bit [N] = 0x0: If the DMAC executes DMASEV for the event-interrupt resource N then the DMAC signals event N to all of the threads. 
Bit [N] = 0x1: If the DMAC executes DMASEV for the event-interrupt resource N then the DMAC sets IRQ[N] high.
Note: For more information about selecting an event number, see Section DMASEV.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_INT_EVENT_RIS</name>
          <description>Event-Interrupt Raw Status Register </description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMASEV_ACTIVE</name>
              <description>This bit field returns the status of the event-interrupt resources.
- Bit [N] = 0x0: Event N is inactive or IRQ[N] is low.
- Bit [N] = 0x1: Event N is active or IRQ[N] is high.
Note: When the DMAC executes a DMASEV N instruction to send event N, the DMA_INTEN register controls whether the DMAC:
- Signals an interrupt using the appropriate IRQ.
- Sends the event to all of the threads (see DMA_INTEN register).
Note: The DMAC clears bit [N] when either:
- The DMA_INTEN register is programmed to process the event and the DMAC executes a DMAWFE instruction for that event.
- The DMA_INTEN register is programmed to signal an interrupt and the user write to the corresponding bit in the DMA_INTCLR register.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_INTMIS</name>
          <description>Interrupt Status Register </description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IRQ_STATUS</name>
              <description>This bit field provides the status of the interrupts that are active in the DMAC.
- Bit [N] = 0x0: Interrupt N is inactive and therefore IRQ[N] is low.
- Bit [N] = 0x1: Interrupt N is active and therefore IRQ[N] is high.
Note: User must use the DMA_INTCLR register to set bit [N] to 0x0.
Note: Bit [N] is 0x0 if the DMA_INTEN register programs DMASEV to signal an event.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_INTCLR</name>
          <description>Interrupt Clear Register </description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IRQ_CLR</name>
              <description>Controls the clearing of the IRQ outputs:
- Bit [N] = 0x0: The status of IRQ[N] does not change.
- Bit [N] = 0x1: The DMAC sets IRQ[N] low if the DMA_INTEN register programs the DMAC to signal an interrupt.
Otherwise, the status of IRQ[N] does not change (see DMA_INTEN register).</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_FSRD</name>
          <description>Fault Status DMA Manager Register </description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FS_MGR</name>
              <description>This bit provides the fault status of the DMA manager.
Refer to the DMA_FTRD register for more information about the type of fault that occured.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The DMA manager thread is not in the Faulting state.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The DMA manager thread is in the Faulting state.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_FSRC</name>
          <description>Fault Status DMA Channel Register </description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FAULT_STATUS</name>
              <description>Each bit provides the fault status of the corresponding channel.
- Bit [N] = 0x0: No fault is present on DMA channel N.
- Bit [N] = 0x1: DMA channel N is in the Faulting or Faulting completing state.
Refer to the DMA_FTRD register for more information about the type of fault that occured. </description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_FTRD</name>
          <description>Fault Type DMA Manager Register </description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DBG_INSTR</name>
              <description>If the DMA manager aborts, this bit indicates whether the erroneous instruction was read from the system memory or from the debug interface.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Instruction that generated an abort was read from system memory.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Instruction that generated an abort was read from the debug interface.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INSTR_FETCH_ERR</name>
              <description>This bit indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA manager performs an instruction fetch.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>OKAY response.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>EXOKAY, SLVERR, or DECERR response.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MGR_EVNT_ERR</name>
              <description>This bit indicates whether the DMA manager was attempting to execute DMAWFE or DMASEV with inappropriate security permissions.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The DMA manager has appropriate security to execute DMAWFE or DMASEV.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The DMA manager thread in the non-secure state attempted to execute either:
- DMAWFE to wait for a secure event.
- DMASEV to create a secure event or secure interrupt.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DMAGO_ERR</name>
              <description>This bit indicates whether the DMA manager was attempting to execute DMAGO with inappropriate security permissions.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The DMA manager has appropriate security to execute DMAGO.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The DMA manager thread in the non-secure state attempted to execute DMAGO to create a DMA channel operating in the secure state.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OPERAND_INVALID</name>
              <description>This bit indicates whether the DMA manager was attempting to execute an instruction operand that was not valid for the configuration of the DMAC.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Valid operand.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Invalid operand.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UNDEF_INSTR</name>
              <description>This bit indicates whether the DMA manager was attempting to execute an undefined instruction.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Defined instruction.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Undefined instruction.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>DMA_FTR[%s]</name>
          <description>Fault Type for DMA Channel (n) Register </description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCKUP_ERR</name>
              <description>This bit indicates whether the DMA channel has locked-up because of resource starvation.
This fault is an imprecise abort.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DMA channel has adequate resources.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA channel has locked-up because of insufficient resources.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBG_INSTR</name>
              <description>If the DMA channel aborts, this bit indicates whether the erroneous instruction was read from the system memory or from the debug interface.
This fault is an imprecise abort but the bit is only valid when a precise abort occurs.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Instruction that generated an abort was read from system memory.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Instruction that generated an abort was read from the debug interface.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATA_READ_ERR</name>
              <description>This bit indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel thread performs a data read.
This fault is an imprecise abort.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>OKAY response.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>EXOKAY, SLVERR, or DECERR response.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATA_WRITE_ERR</name>
              <description>This bit indicates the AXI response that the DMAC receives on the BRESP bus, after the DMA channel thread performs a data write.
This fault is an imprecise abort.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>OKAY response.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>EXOKAY, SLVERR, or DECERR response.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INSTR_FETCH_ERR</name>
              <description>This bit indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel thread performs an instruction fetch.
This fault is a precise abort.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>OKAY response.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>EXOKAY, SLVERR, or DECERR response.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ST_DATA_UNAVAILABLE</name>
              <description>This bit indicates whether the MFIFO did not contain the data to enable the DMAC to perform the DMAST.
This fault is a precise abort.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MFIFO contains all the data to enable the DMAST to complete.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Previous DMALDs have not put enough data in the MFIFO to enable the DMAST to complete.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MFIFO_ERR</name>
              <description>This bit indicates whether the MFIFO prevented the DMA channel thread from executing DMALD or DMAST. Depending on the instruction:
- DMALD
 0x0: MFIFO contains sufficient space.
0x1: MFIFO is too small to hold the data that DMALD requires.
- DMAST
 0x0: MFIFO contains sufficient data.
0x1: MFIFO is too small to store the data to enable DMAST to complete.
This fault is an imprecise abort.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CH_RDWR_ERR</name>
              <description>This bit indicates whether a DMA channel thread, in the non-secure state, attempts to program the DMA_CCRn register to perform a secure read or secure write.
This fault is a precise abort.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>A DMA channel thread in the non-secure state is not violating the security permissions.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>A DMA channel thread in the non-secure state attempted to perform a secure read or secure write.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CH_PERIPH_ERR</name>
              <description>This bit indicates whether a DMA channel thread, in the non-secure state, attempts to execute DMAWFP, DMALDP, DMASTP, or DMAFLUSHP with inappropriate security permissions.
This fault is a precise abort.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>A DMA channel thread in the non-secure state is not violating the security permissions.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>A DMA channel thread in the non-secure state attempted to execute either:
- DMAWFP to wait for a secure peripheral.
- DMALDP or DMASTP to notify a secure peripheral.
- DMAFLUSHP to flush a secure peripheral.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CH_EVNT_ERR</name>
              <description>This bit indicates whether the DMA channel thread attempts to execute DMAWFE or DMASEV with inappropriate security permissions.
This fault is a precise abort.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>A DMA channel thread in the non-secure state is not violating the security permissions.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>A DMA channel thread in the non-secure state attempted to execute either:
- DMAWFE to wait for a secure event.
- DMASEV to create a secure event or secure interrupt.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OPERAND_INVALID</name>
              <description>This bit indicates whether the DMA channel thread was attempting to execute an instruction operand that was not valid for the configuration of the DMAC.
This fault is a precise abort.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Valid operand.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Invalid operand.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UNDEF_INSTR</name>
              <description>This bit indicates whether the DMA channel thread was attempting to execute an undefined instruction.
This fault is a precise abort.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Defined instruction.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Undefined instruction.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>8</dim>
          <dimIncrement>8</dimIncrement>
          <name>DMA_CHANNEL_RT_INFO[%s]</name>
          <addressOffset>0x100</addressOffset>
          <register>
            <name>DMA_CSR</name>
            <description>Channel Status for DMA Channel (n) Register </description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNS</name>
                <description>The channel non-secure bit provides the security of the DMA channel.
Note: For more information, see Section DMAGO</description>
                <bitRange>[21:21]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>DMA channel operates in the secure state.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>DMA channel operates in the non-secure state.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DMAWFP_PERIPH</name>
                <description>When the DMA channel thread executes DMAWFP, this bit indicates whether the periph operand was set.
For more information, see Section DMAWFP.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>DMAWFP executed with the periph operand not set.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>DMAWFP executed with the periph operand set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DMAWFP_B_NS</name>
                <description>When the DMA channel thread executes DMAWFP, this bit indicates whether the burst or single operand were set.
For more information, see Section DMAWFP.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>DMAWFP executed with the single operand set.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>DMAWFP executed with the burst operand set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WAKEUP_NUMBER</name>
                <description>If the DMA channel is in the Waiting for event state, or the Waiting for peripheral state, then these bits indicate the event or peripheral number that the channel is waiting for.</description>
                <bitRange>[8:4]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>DMA channel is waiting for event, or peripheral, 0.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>DMA channel is waiting for event, or peripheral, 1.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>DMA channel is waiting for event, or peripheral, 2.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1F</name>
                    <description>DMA channel is waiting for event, or peripheral, 31.</description>
                    <value>0x1F</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CHANNEL_STATUS</name>
                <description>The channel status encoding is:
For more information, see Section Thread Operating States.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Stopped.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Executing.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Cache miss.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Updating PC.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x4</name>
                    <description>Waiting for event.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x5</name>
                    <description>At barrier.</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x7</name>
                    <description>Waiting for peripheral.</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x8</name>
                    <description>Killing.</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x9</name>
                    <description>Completing.</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xE</name>
                    <description>Faulting completing.</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xF</name>
                    <description>Faulting.</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>DMA_CPC</name>
            <description>Channel PC for DMA Channel (n) Register </description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PC_CHNL</name>
                <description>Program counter for the DMA channel n thread, where n depends on the address of the register.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>8</dim>
          <dimIncrement>32</dimIncrement>
          <name>DMA_RT_CHANNEL_CFG[%s]</name>
          <addressOffset>0x400</addressOffset>
          <register>
            <name>DMA_SAR</name>
            <description>Source Address for DMA Channel (n) Register </description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SRC_ADDR</name>
                <description>Address of the source data for DMA channel n, where n depends on the address of the register.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMA_DAR</name>
            <description>Destination Address for DMA Channel (n) Register </description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DST_ADDR</name>
                <description>Address for the destination data for DMA channel n, where n depends on the address of the register.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMA_CCR</name>
            <description>Channel Control for DMA Channel (n) Register </description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00800200</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ENDIAN_SWAP_SIZE</name>
                <description>This bit field defines whether data can be swapped between little-endian (LE) and byte-invariant big-endian (BE-8) formats, and if so, also defines the natural width of the data independently of the source and destination transaction sizes.
This enables unaligned data streams to use the full bus-width, and to be correctly transformed, irrespective of the source and destination address alignments. The format is identical to AxSIZE, except that 0x0 indicates that no swap must occur.
For more information, see Section Endian Swap Size Restrictions.</description>
                <bitRange>[30:28]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>No swap, 8-bit data.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Swap bytes within 16-bit data.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Swap bytes within 32-bit data.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Swap bytes within 64-bit data.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x4</name>
                    <description>Swap bytes within 128-bit data.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DST_CACHE_CTRL</name>
                <description>Programs the state of AWCACHE[3,1:0] a when the DMAC writes the destination data.
- Bit [27]
 0x0: AWCACHE[3] is low.
0x1: AWCACHE[3] is high.
- Bit [26]
 0x0: AWCACHE[1] is low.
0x1: AWCACHE[1] is high.
- Bit [25]
 0x0: AWCACHE[0] is low.
0x1: AWCACHE[0] is high.
Note: AWCACHE[2] is tied low by the DMAC. Setting AWCACHE[3,1] = 0x2 violates the AXI protocol. See the AMBA AXI and ACE Protocol Specification.</description>
                <bitRange>[27:25]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DST_PROT_CTRL</name>
                <description>Programs the state of AWPROT[2:0] when the DMAC writes the destination data.
- Bit [24]
 0x0: AWPROT[2] is low.
0x1: AWPROT[2] is high.
- Bit [23]
 0x0: AWPROT[1] is low.
0x1: AWPROT[1] is high.
- Bit [22]
 0x0: AWPROT[0] is low.
0x1: AWPROT[0] is high.
Note: Only DMA channels in the secure state can program AWPROT[1] low, that is, a secure access. If a DMA channel in the non-secure state attempts to set AWPROT[1] low, then the DMA channel aborts.</description>
                <bitRange>[24:22]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DST_BURST_LEN</name>
                <description>For each burst, these bits program the number of data transfers that the DMAC performs when it writes the destination data.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction is the product of dst_burst_len and dst_burst_size.
Note: These bits control the state of AWLEN[3:0].</description>
                <bitRange>[21:18]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>1 Data transfer.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>2 Data transfers.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>3 Data transfers.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xF</name>
                    <description>16 Data transfers.</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DST_BURST_SIZE</name>
                <description>For each beat within a burst, it programs the number of bytes that the DMAC writes to the destination.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction is the product of dst_burst_len and dst_burst_size.
Note: These bits control the state of AWSIZE[2:0].</description>
                <bitRange>[17:15]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Writes 1 byte per beat.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Writes 2 bytes per beat.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Writes 4 bytes per beat.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Writes 8 bytes per beat.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x4</name>
                    <description>Writes 16 bytes per beat.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DST_INC</name>
                <description>Programs the burst type that the DMAC performs when it writes the destination data.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Fixed-address burst. The DMAC signals AWBURST[0] low.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Incrementing-address burst. The DMAC signals AWBURST[0] high.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SRC_CACHE_CTRL</name>
                <description>Set the bits to control the state of ARCACHE[2:0] when the DMAC reads the source data.
- Bit [13]
 0x0: ARCACHE[2] is low.
0x1: ARCACHE[2] is high.
- Bit [12]
 0x0: ARCACHE[1] is low.
0x1: ARCACHE[1] is high.
- Bit [11]
 0x0: ARCACHE[0] is low.
0x1: ARCACHE[0] is high.
Note: The DMAC ties ARCACHE[3] low. Setting ARCACHE[2:1] = 0b10 violates the AXI protocol. See the AMBA AXI and ACE Protocol Specification.</description>
                <bitRange>[13:11]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SRC_PROT_CTRL</name>
                <description>Programs the state of ARPROT[2:0] when the DMAC reads the source data.
 - Bit [10]: 
0x0 = ARPROT[2] is low.
0x1 = ARPROT[2] is high.
 - Bit [9]: 
0x0 = ARPROT[1] is low. 
0x1 = ARPROT[1] is high.
 - Bit [8]: 
0x0 = ARPROT[0] is low. 
0x1 = ARPROT[0] is high.
Note: Only DMA channels in the secure state can program ARPROT[1] low, that is, a secure access. If a DMA channel in the non-secure state attempts to set ARPROT[1] low, the DMA channel aborts.</description>
                <bitRange>[10:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SRC_BURST_LEN</name>
                <description>For each burst, these bits program the number of data transfers that the DMAC performs when it reads the source data.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction is the product of SRC_BURST_LEN and SRC_BURST_SIZE bit fields.
Note: These bits control the state of ARLEN[3:0].</description>
                <bitRange>[7:4]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>1 Data transfer.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>2 Data transfers.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>3 Data transfers.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x7</name>
                    <description>16 Data transfers.</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SRC_BURST_SIZE</name>
                <description>For each beat within a burst, it programs the number of bytes that the DMAC reads from the source.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction is the product of src_burst_len and src_burst_size.
Note: These bits control the state of ARSIZE[2:0].</description>
                <bitRange>[3:1]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Reads 1 byte per beat.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Reads 2 bytes per beat.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Reads 4 bytes per beat.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Reads 8 bytes per beat.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x4</name>
                    <description>Reads 16 bytes per beat.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SRC_INC</name>
                <description>Programs the burst type that the DMAC performs when it reads the source data.
Note: The DMAC does not generate:
- Locked or exclusive accesses.
- WRAP transfers. Therefore, ARBURST[1] and AWBURST[1] are always low.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Fixed-address burst. The DMAC signals ARBURST[0] low.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Incrementing-address burst. The DMAC signals ARBURST[0] high.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>DMA_LC0</name>
            <description>Loop Counter 0 for DMA Channel (n) Register </description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LOOP_COUNTER_ITERATIONS</name>
                <description>The number of loop counter iterations.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMA_LC1</name>
            <description>Loop Counter 1 for DMA Channel (n) Register </description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LOOP_COUNTER_ITERATIONS</name>
                <description>The number of loop counter iterations.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>DMA_DBGSTATUS</name>
          <description>Debug Status Register </description>
          <addressOffset>0xD00</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMA_DBGSTATUS</name>
              <description>The debug status encoding is:</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Idle.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Busy.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_DBGCMD</name>
          <description>Debug Command Register </description>
          <addressOffset>0xD04</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMA_DBGCMD</name>
              <description>The debug encoding is as follows:</description>
              <bitRange>[1:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Execute the instruction that the DMA_DBGINST0 and DMA_DBGINST1 registers contain.</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_DBGINST0</name>
          <description>Debug Instruction Register 0 </description>
          <addressOffset>0xD08</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INSTRUCTION_BYTE_1</name>
              <description>Instruction byte 1.</description>
              <bitRange>[31:24]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>INSTRUCTION_BYTE_0</name>
              <description>Instruction byte 0.</description>
              <bitRange>[23:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CHANNEL_NUMBER</name>
              <description>DMA channel number:
Note: When set to 0x1, this bit field selects the DMA channel to debug.</description>
              <bitRange>[10:8]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DMA channel 0.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA channel 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>DMA channel 2.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>DMA channel 7.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEBUG_THREAD</name>
              <description>The debug thread encoding is as follows:</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DMA manager thread.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA channel.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_DBGINST1</name>
          <description>Debug Instruction Register 1 </description>
          <addressOffset>0xD0C</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INSTRUCTION_BYTE_5</name>
              <description>Instruction byte 5.</description>
              <bitRange>[31:24]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>INSTRUCTION_BYTE_4</name>
              <description>Instruction byte 4.</description>
              <bitRange>[23:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>INSTRUCTION_BYTE_3</name>
              <description>Instruction byte 3.</description>
              <bitRange>[15:8]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>INSTRUCTION_BYTE_2</name>
              <description>Instruction byte 2.</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_CR0</name>
          <description>Configuration Register 0 </description>
          <addressOffset>0xE00</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x003FF071</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NUM_EVENTS</name>
              <description>Number of interrupt outputs that the DMAC provides.</description>
              <bitRange>[21:17]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1F</name>
                  <description>32 interrupt outputs, IRQ[31:0].</description>
                  <value>0x1F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NUM_PERIPH_REQ</name>
              <description>Number of peripheral request interfaces that the DMAC provides.</description>
              <bitRange>[16:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1F</name>
                  <description>32 peripheral request interfaces.</description>
                  <value>0x1F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NUM_CHNLS</name>
              <description>Number of DMA channels that the DMAC supports.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>8 DMA channels.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MGR_NS_AT_RST</name>
              <description>Indicates DMA manager is in the secure state when the DMAC exited from reset.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DMA manager is in the secure state.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA manager is in the non-Secure state.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BOOT_EN</name>
              <description>Indicates the srunning state when the DMAC exited from reset.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Stopped state and waits for an instruction from the Secure APB interface.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Running state.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PERIPH_REQ</name>
              <description>Supports peripheral requests.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The DMAC provides the number of peripheral request interfaces that the NUM_PERIPH_REQ field specifies.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_CR1</name>
          <description>Configuration Register 1 </description>
          <addressOffset>0xE04</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000035</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NUM_ICACHE_LINES</name>
              <description>Number of an i-cache lines:</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>4 i-cache lines.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ICACHE_LEN</name>
              <description>The length of an i-cache line:</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>32 Bytes (8 words).</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_CR2</name>
          <description>Configuration Register 2 </description>
          <addressOffset>0xE08</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BOOT_ADDR</name>
              <description>This bit field provides the value of boot_addr[31:0] when the DMAC exits from reset.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_CR3</name>
          <description>Configuration Register 3 </description>
          <addressOffset>0xE0C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INS</name>
              <description>Provides the security state of an event-interrupt resource.
- Bit [N] = 0x0: Event&lt;N&gt; or irq[N] is in the secure state.
- Bit [N] = 0x1: Event&lt;N&gt; or irq[N] is in the non-secure state.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_CR4</name>
          <description>Configuration Register 4 </description>
          <addressOffset>0xE10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PNS</name>
              <description>Provides the security state of the peripheral request interfaces.
- Bit [N] = 0x0: Peripheral request interface N is in the secure state.
- Bit [N] = 0x1: Peripheral request interface N is in the non-secure state.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_CRD</name>
          <description>DMA Configuration Register </description>
          <addressOffset>0xE14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x01F73733</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA_BUFFER_DEP</name>
              <description>The number of the lines that the data buffer contains.</description>
              <bitRange>[29:20]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1F</name>
                  <description>32 lines.</description>
                  <value>0x1F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RD_Q_DEP</name>
              <description>The depth of the read queue.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>8 lines.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RD_CAP</name>
              <description>Read issuing capability that programs the number of the outstanding read transactions.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>4 outstanding read transactions.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WR_Q_DEP</name>
              <description>The depth of the write queue.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>8 lines.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WR_CAP</name>
              <description>Write issuing capability that programs the number of the outstanding write transactions.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>4 outstanding write transactions.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATA_WIDTH</name>
              <description>The data bus width of the AXI master interface.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>64-bit.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_WD</name>
          <description>Watchdog Register </description>
          <addressOffset>0xE80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WD_IRQ_ONLY</name>
              <description>This bit controls how the DMAC responds when it detects a lock-up condition.
For more information, see Section Watchdog Abort.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The DMAC aborts all of the contributing DMA channels and sets IRQ_ABORT high.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The DMAC sets IRQ_ABORT high.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_PERIPH_ID_0</name>
          <description>Peripheral ID Register 0</description>
          <addressOffset>0xFE0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000030</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>PART_NUMBER_0</name>
              <description>Part number 0 value</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_PERIPH_ID_1</name>
          <description>Peripheral ID Register 1</description>
          <addressOffset>0xFE4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000013</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>DESIGNER_0</name>
              <description>Designer ID part 0</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PART_NUMBER_1</name>
              <description>Part number value 1</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_PERIPH_ID_2</name>
          <description>Peripheral ID Register 2</description>
          <addressOffset>0xFE8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000034</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>REVISION</name>
              <description>Revision ID:</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>r0p0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>r1p0</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>r1p1</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>r1p2</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DESIGNER_1</name>
              <description>Designer ID part 1</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_PERIPH_ID_3</name>
          <description>Peripheral ID Register 3</description>
          <addressOffset>0xFEC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>INTEGRATION_CFG</name>
              <description>Indicates DMAC integration configuration</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_PCELL_ID_0</name>
          <description>Component Identification Register 0</description>
          <addressOffset>0xFF0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0000000D</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>PCELL_ID_0</name>
              <description>Component ID part 0</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_PCELL_ID_1</name>
          <description>Component Identification Register 1</description>
          <addressOffset>0xFF4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000F0</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>PCELL_ID_1</name>
              <description>Component ID part 1</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_PCELL_ID_2</name>
          <description>Component Identification Register 2</description>
          <addressOffset>0xFF8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0000000D</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>PCELL_ID_2</name>
              <description>Component ID part 2</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_PCELL_ID_3</name>
          <description>Component Identification Register 3</description>
          <addressOffset>0xFFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000B1</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>PCELL_ID_3</name>
              <description>Component ID part 3</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="DMA1_SEC">
      <name>DMA1_NS</name>
      <baseAddress>0x400E0000</baseAddress>
    </peripheral>
    <peripheral>
      <name>NPU_HP</name>
      <baseAddress>0x400E1000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>NPUHP_ID</name>
          <description>ID Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x10104201</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ARCH_MAJOR_REV</name>
              <description>This is the major architecture version number, a in the architecture version a.b</description>
              <bitRange>[31:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ARCH_MINOR_REV</name>
              <description>This is the minor architecture version number, b in the architecture version a.b</description>
              <bitRange>[27:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ARCH_PATCH_REV</name>
              <description>This is the patch number of the architecture version a.b</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PRODUCT_MAJOR</name>
              <description>This is the X-part of the ML00X product number</description>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VERSION_MAJOR</name>
              <description>This is the n for the R-part of an RnPn release number</description>
              <bitRange>[11:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VERSION_MINOR</name>
              <description>This is the n for the P-part of an RnPn release number</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VERSION_STATUS</name>
              <description>This is the version of the product</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_STATUS</name>
          <description>Status Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000008</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IRQ_HISTORY_MASK</name>
              <description>IRQ history mask.
This is used for debug purposes. Each IRQ or event operation provides a 16-bit mask which is
logically OR-ed into these bits.
The bits can be cleared via their counterparts in the NPUHP_CMD[CLEAR_IRQ_HISTORY] field.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FAULTING_CHANNEL</name>
              <description>Faulting channel on a bus abort.
Read operations: 
 Write operations: </description>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Cmd</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>IFM</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Weights</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Bias and Scale</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Mem2Mem</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>OFM</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>Mem2Mem</description>
                  <value>0x9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FAULTING_INTERFACE</name>
              <description>Faulting interface on bus abort. </description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>AXI-M0 </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>AXI-M1</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ECC_FAULT</name>
              <description>ECC state for internal RAMs.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No fault </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ECC fault signalled. Can only be cleared by reset.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WD_FAULT</name>
              <description>Weight decoder state.
Note: This bit is never set in this product.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No fault </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Weight decoder decompression fault signalled. Can only be cleared by reset.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PMU_IRQ_RAISED</name>
              <description>PMU IRQ status.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>PMU IRQ not raised</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>PMU IRQ raised. Can be cleared via the NPUHP_CMD[CLEAR_IRQ] field.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_END_REACHED</name>
              <description>Command stream end status.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>End not reached</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>End reached. Can be cleared by writing NPUHP_QBASE0 / NPUHP_QBASE1 or NPUHP_QSIZE when NPU is in stopped state.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_PARSE_ERROR</name>
              <description>Command stream parsing error status.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Command stream parsing error detected. Can only be cleared by reset.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESET_STATUS</name>
              <description>Reset status.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>NPU is not being reset and can be accessed as normal.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Reset is ongoing and only this register can be read (other registers read as 0 and writes are ignored).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUS_STATUS</name>
              <description>Bus status.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>OK</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Bus abort detected and processing halted (NPU has reached IDLE state and does not start to process any more commands / AXI transactions). Can only be cleared by reset.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IRQ_RAISED</name>
              <description>Raw IRQ status. </description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>IRQ not raised</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>IRQ raised. Can be cleared via the NPUHP_CMD[CLEAR_IRQ] field.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STATE</name>
              <description>NPU state.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Stopped </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Running</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_CMD</name>
          <description>Command Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000000C</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLEAR_IRQ_HISTORY</name>
              <description>Clears the IRQ history mask.
When bit [k] is set, then the corresponding bit [k] of the NPUHP_STATUS[IRQ_HISTORY_MASK] field is cleared.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP_REQUEST</name>
              <description>Write 1 to this bit to request STOP after completing any already-started commands.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POWER_Q_ENABLE</name>
              <description>Write 1 to this bit to enable power off using Power Q-interface.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLOCK_Q_ENABLE</name>
              <description>Write 1 to this bit to enable clock off using Clock Q-interface and enable the master clock gate.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR_IRQ</name>
              <description>Write 1 to clear the IRQ status in the STATUS register.
Writing 0 has no effect.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRANSITION_TO_RUNNING_STATE</name>
              <description>Write 1 to transition the NPU to running state.
Writing 0 has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_RESET</name>
          <description>Reset Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PENDING_CSL</name>
              <description>Current security level </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Secure </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Non-secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PENDING_CPL</name>
              <description>Current privilege level </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>User </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Privileged</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_QBASE0</name>
          <description>Queue Base Register 0</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QBASE0</name>
              <description>Lower bytes of the base address value for the command stream (4-byte-aligned)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_QBASE1</name>
          <description>Queue Base Register 1</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QBASE1</name>
              <description>Upper bytes of the base address value for the command stream (4-byte-aligned)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_QREAD</name>
          <description>Queue Read Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QREAD</name>
              <description>The read offset (in bytes) of the current command under execution. Multiple of 4 in the range 0 to 16 MB.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_QCONFIG</name>
          <description>Queue Configuration Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QCONFIG</name>
              <description>AXI configuration for the command stream in the range 0-3. Same encoding as for NPUHP_REGIONCFG.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_QSIZE</name>
          <description>Queue Size Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QSIZE</name>
              <description>Size (in bytes) of the next command stream to be executed by the NPU. Multiple of 4 in the range 0 to 16 MB.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PROT</name>
          <description>Protection Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACTIVE_CSL</name>
              <description>Current security level </description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Secure </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Non-secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ACTIVE_CPL</name>
              <description>Current privilege level </description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>User </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Privileged</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_CONFIG</name>
          <description>Module Configuration Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00003008</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRODUCT</name>
              <description>Product configuration</description>
              <bitRange>[31:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CUSTOM_DMA</name>
              <description>Custom DMA configuration</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Custom DMA not implemented</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SHRAM_SIZE</name>
              <description>Total size of internal SHRAM</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x30</name>
                  <description>48KB</description>
                  <value>0x30</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_STREAM_VERSION</name>
              <description>Command stream version accepted by this NPU</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MACS_PER_CC</name>
              <description>MACs/clock cycle</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>256</description>
                  <value>0x8</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_LOCK</name>
          <description>Lock Register</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCK</name>
              <description>32-bit value for the lock configuration.
To try to claim the lock, write a non-zero ID value and read back to see if the value was
accepted.
To release the lock (that contains your non-zero ID value), write 0 to the lock register.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_REGIONCFG</name>
          <description>Region Configuration Register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REGION7</name>
              <description>Region 7 configuration</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGION6</name>
              <description>Region 6 configuration</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGION5</name>
              <description>Region 5 configuration</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGION4</name>
              <description>Region 4 configuration</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGION3</name>
              <description>Region 3 configuration</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGION2</name>
              <description>Region 2 configuration</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGION1</name>
              <description>Region 1 configuration</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGION0</name>
              <description>Region 0 configuration</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_AXI_LIMIT0</name>
          <description>AXI Limit Register 0</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MAX_OUTSTANDING_WRITE_M1</name>
              <description>Maximum number of [outstanding AXI write transactions - 1] in range 0 to 15</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAX_OUTSTANDING_READ_M1</name>
              <description>Maximum number of [outstanding AXI read transactions - 1] in range 0 to 31</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEMTYPE</name>
              <description>Memory type</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Device Non-Bufferable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Device Bufferable</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Normal, Non-Cacheable, Non-Bufferable</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Normal, Non-Cacheable, Bufferable</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Write Through, No Allocate</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>Write Through, Read Allocate</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>Write Through, Write Allocate</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>Write Through, Read and Write Allocate</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>Write Back, No Allocate</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>Write Back, Read Allocate</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>Write Back, Write Allocate</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>Write Back, Read and Write Allocate</description>
                  <value>0xB</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MAX_BEATS</name>
              <description>Burst split alignment</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>64 bytes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>128 bytes</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>256 bytes</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_AXI_LIMIT1</name>
          <description>AXI Limit Register 1</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MAX_OUTSTANDING_WRITE_M1</name>
              <description>Maximum number of [outstanding AXI write transactions - 1] in range 0 to 15</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAX_OUTSTANDING_READ_M1</name>
              <description>Maximum number of [outstanding AXI read transactions - 1] in range 0 to 31</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEMTYPE</name>
              <description>Memory type</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Device Non-Bufferable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Device Bufferable</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Normal, Non-Cacheable, Non-Bufferable</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Normal, Non-Cacheable, Bufferable</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Write Through, No Allocate</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>Write Through, Read Allocate</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>Write Through, Write Allocate</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>Write Through, Read and Write Allocate</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>Write Back, No Allocate</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>Write Back, Read Allocate</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>Write Back, Write Allocate</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>Write Back, Read and Write Allocate</description>
                  <value>0xB</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MAX_BEATS</name>
              <description>Burst split alignment</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>64 bytes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>128 bytes</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>256 bytes</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_AXI_LIMIT2</name>
          <description>AXI Limit Register 2</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MAX_OUTSTANDING_WRITE_M1</name>
              <description>Maximum number of [outstanding AXI write transactions - 1] in range 0 to 15</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAX_OUTSTANDING_READ_M1</name>
              <description>Maximum number of [outstanding AXI read transactions - 1] in range 0 to 31</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEMTYPE</name>
              <description>Memory type</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Device Non-Bufferable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Device Bufferable</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Normal, Non-Cacheable, Non-Bufferable</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Normal, Non-Cacheable, Bufferable</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Write Through, No Allocate</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>Write Through, Read Allocate</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>Write Through, Write Allocate</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>Write Through, Read and Write Allocate</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>Write Back, No Allocate</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>Write Back, Read Allocate</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>Write Back, Write Allocate</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>Write Back, Read and Write Allocate</description>
                  <value>0xB</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MAX_BEATS</name>
              <description>Burst split alignment</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>64 bytes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>128 bytes</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>256 bytes</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_AXI_LIMIT3</name>
          <description>AXI Limit Register 3</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MAX_OUTSTANDING_WRITE_M1</name>
              <description>Maximum number of [outstanding AXI write transactions - 1] in range 0 to 15</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAX_OUTSTANDING_READ_M1</name>
              <description>Maximum number of [outstanding AXI read transactions - 1] in range 0 to 31</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEMTYPE</name>
              <description>Memory type</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Device Non-Bufferable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Device Bufferable</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Normal, Non-Cacheable, Non-Bufferable</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Normal, Non-Cacheable, Bufferable</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Write Through, No Allocate</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>Write Through, Read Allocate</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>Write Through, Write Allocate</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>Write Through, Read and Write Allocate</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>Write Back, No Allocate</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>Write Back, Read Allocate</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>Write Back, Write Allocate</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>Write Back, Read and Write Allocate</description>
                  <value>0xB</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MAX_BEATS</name>
              <description>Burst split alignment</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>64 bytes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>128 bytes</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>256 bytes</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_BASEP0</name>
          <description>Base Pointer Register 0</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_WORD</name>
              <description>The low word of the 64-bit address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_BASEP1</name>
          <description>Base Pointer Register 1</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_WORD</name>
              <description>The high word of the 64-bit address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_BASEP2</name>
          <description>Base Pointer Register 2</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_WORD</name>
              <description>The low word of the 64-bit address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_BASEP3</name>
          <description>Base Pointer Register 3</description>
          <addressOffset>0x8C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_WORD</name>
              <description>The high word of the 64-bit address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_BASEP4</name>
          <description>Base Pointer Register 4</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_WORD</name>
              <description>The low word of the 64-bit address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_BASEP5</name>
          <description>Base Pointer Register 5</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_WORD</name>
              <description>The high word of the 64-bit address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_BASEP6</name>
          <description>Base Pointer Register 6</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_WORD</name>
              <description>The low word of the 64-bit address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_BASEP7</name>
          <description>Base Pointer Register 7</description>
          <addressOffset>0x9C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_WORD</name>
              <description>The high word of the 64-bit address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_BASEP8</name>
          <description>Base Pointer Register 8</description>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_WORD</name>
              <description>The low word of the 64-bit address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_BASEP9</name>
          <description>Base Pointer Register 9</description>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_WORD</name>
              <description>The high word of the 64-bit address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_BASEP10</name>
          <description>Base Pointer Register 10</description>
          <addressOffset>0xA8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_WORD</name>
              <description>The low word of the 64-bit address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_BASEP11</name>
          <description>Base Pointer Register 11</description>
          <addressOffset>0xAC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_WORD</name>
              <description>The high word of the 64-bit address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_BASEP12</name>
          <description>Base Pointer Register 12</description>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_WORD</name>
              <description>The low word of the 64-bit address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_BASEP13</name>
          <description>Base Pointer Register 13</description>
          <addressOffset>0xB4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_WORD</name>
              <description>The high word of the 64-bit address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_BASEP14</name>
          <description>Base Pointer Register 14</description>
          <addressOffset>0xB8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_WORD</name>
              <description>The low word of the 64-bit address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_BASEP15</name>
          <description>Base Pointer Register 15</description>
          <addressOffset>0xBC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_WORD</name>
              <description>The high word of the 64-bit address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMCR</name>
          <description>Performance Monitor Control Register</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00002000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NUM_EVENT_CNT</name>
              <description>Number of PMU event counters (4 event counters are available)</description>
              <bitRange>[15:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MASK_EN</name>
              <description>Allows to enable/disable PMU by command stream operation NPU_OP_PMU_MASK. Note that the [CNT_EN] field in this register must be enabled for the PMU to be active.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CYCLE_CNT_RST</name>
              <description>Reset PMU cycle counter.
Writing 1 to this field resets the cycle counter. If the cycle counter is active, it will continue
counting after reset.</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>EVENT_CNT_RST</name>
              <description>Reset PMU event counter.
Writing 1 to this field resets all event counters. If any counter is active, it will continue counting
after reset.</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CNT_EN</name>
              <description>Enable PMU.
This is the master switch. When the switch is disabled, the PMU is always off. Writing 1 to this field enables PMU operation.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMCNTENSET</name>
          <description>Performance Monitor Count Enable Set Register</description>
          <addressOffset>0x184</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE_CNT</name>
              <description>Enable PMU cycle counter.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the cycle counter is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the cycle counter is enabled. When written, it enables the cycle counter.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_3</name>
              <description>Enable PMU event counter 3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter is enabled. When written, it enables the event counter.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_2</name>
              <description>Enable PMU event counter 2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter is enabled. When written, it enables the event counter.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_1</name>
              <description>Enable PMU event counter 1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter is enabled. When written, it enables the event counter.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_0</name>
              <description>Enable PMU event counter 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter is enabled. When written, it enables the event counter.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMCNTENCLR</name>
          <description>Performance Monitor Count Enable Clear Register</description>
          <addressOffset>0x188</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE_CNT</name>
              <description>Disable PMU cycle counter.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the cycle counter is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the cycle counter is enabled. When written, it disables the cycle counter.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_3</name>
              <description>Disable PMU event counter 3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter is enabled. When written, it disables the event counter.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_2</name>
              <description>Disable PMU event counter 2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter is enabled. When written, it disables the event counter.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_1</name>
              <description>Disable PMU event counter 1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter is enabled. When written, it disables the event counter.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_0</name>
              <description>Disable PMU event counter 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter is enabled. When written, it disables the event counter.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMOVSSET</name>
          <description>Performance Monitor Overflow Status Set Register</description>
          <addressOffset>0x18C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE_CNT_OVF</name>
              <description>Set overflow for PMU cycle counter.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the cycle counter has not overflowed. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the cycle counter has overflowed. When written, it sets the overflow bit to 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_3_OVF</name>
              <description>Set overflow for PMU event counter 3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter has not overflowed. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter has overflowed. When written, it sets the overflow bit to 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_2_OVF</name>
              <description>Set overflow for PMU event counter 2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter has not overflowed. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter has overflowed. When written, it sets the overflow bit to 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_1_OVF</name>
              <description>Set overflow for PMU event counter 1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter has not overflowed. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter has overflowed. When written, it sets the overflow bit to 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_0_OVF</name>
              <description>Set overflow for PMU event counter 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter has not overflowed. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter has overflowed. When written, it sets the overflow bit to 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMOVSCLR</name>
          <description>Performance Monitor Overflow Status Clear Register</description>
          <addressOffset>0x190</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE_CNT_OVF</name>
              <description>Clear overflow for PMU cycle counter.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the cycle counter has not overflowed. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the cycle counter has overflowed. When written, it clears the overflow bit to 0.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_3_OVF</name>
              <description>Clear overflow for PMU event counter 3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter has not overflowed. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter has overflowed. When written, it clears the overflow bit to 0.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_2_OVF</name>
              <description>Clear overflow for PMU event counter 2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter has not overflowed. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter has overflowed. When written, it clears the overflow bit to 0.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_1_OVF</name>
              <description>Clear overflow for PMU event counter 1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter has not overflowed. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter has overflowed. When written, it clears the overflow bit to 0.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_0_OVF</name>
              <description>Clear overflow for PMU event counter 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter has not overflowed. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter has overflowed. When written, it clears the overflow bit to 0.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMINTSET</name>
          <description>Performance Monitor Interrupt Set Register</description>
          <addressOffset>0x194</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE_CNT_INT</name>
              <description>Enable overflow interrupt request for PMU cycle counter.
interrupt request.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the cycle counter overflow interrupt request is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the cycle counter overflow interrupt request is enabled. When written, it enables the cycle count overflow</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_3_INT</name>
              <description>Enable overflow interrupt request for PMU event counter 3.
interrupt request.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter overflow interrupt request is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter overflow interrupt request is enabled. When written, it enables the event count overflow</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_2_INT</name>
              <description>Enable overflow interrupt request for PMU event counter 2.
interrupt request.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter overflow interrupt request is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter overflow interrupt request is enabled. When written, it enables the event count overflow</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_1_INT</name>
              <description>Enable overflow interrupt request for PMU event counter 1.
interrupt request.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter overflow interrupt request is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter overflow interrupt request is enabled. When written, it enables the event count overflow</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_0_INT</name>
              <description>Enable overflow interrupt request for PMU event counter 0.
interrupt request.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter overflow interrupt request is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter overflow interrupt request is enabled. When written, it enables the event count overflow</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMINTCLR</name>
          <description>Performance Monitor Interrupt Clear Register</description>
          <addressOffset>0x198</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE_CNT_INT</name>
              <description>Disable overflow interrupt request for PMU cycle counter.
overflow interrupt request.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the cycle counter overflow interrupt-request is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the cycle counter overflow interrupt-request is enabled. When written, it disables the cycle count</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_3_INT</name>
              <description>Disable overflow interrupt request for PMU event counter 3.
overflow interrupt request.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter overflow interrupt-request is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter overflow interrupt-request is enabled. When written, it disables the event count</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_2_INT</name>
              <description>Disable overflow interrupt request for PMU event counter 2.
overflow interrupt request.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter overflow interrupt-request is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter overflow interrupt-request is enabled. When written, it disables the event count</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_1_INT</name>
              <description>Disable overflow interrupt request for PMU event counter 1.
overflow interrupt request.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter overflow interrupt-request is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter overflow interrupt-request is enabled. When written, it disables the event count</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_0_INT</name>
              <description>Disable overflow interrupt request for PMU event counter 0.
overflow interrupt request.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter overflow interrupt-request is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter overflow interrupt-request is enabled. When written, it disables the event count</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMCCNTR_LO</name>
          <description>Performance Monitor Cycle Count Low Register</description>
          <addressOffset>0x1A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE_CNT_LO</name>
              <description>Cycle count low</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMCCNTR_HI</name>
          <description>Performance Monitor Cycle Count High Register</description>
          <addressOffset>0x1A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE_CNT_HI</name>
              <description>Cycle count high</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMCAXI_CHAN</name>
          <description>Performance Monitor AXI Channel Select Register</description>
          <addressOffset>0x1AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BW_CH_SEL_EN</name>
              <description>Enable bandwidth channel selector</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>AXI BW events measured for all channels</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>AXI BW events measured for channel specified by [CH_SEL]</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AXI_CNT_SEL</name>
              <description>Select AXI counter to monitor for latency measurements
A maximum of two separate outstanding transaction queues can be connected to each AXI
interface. The counters are used to express the maximum number of outstanding jobs per queue.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>AXI counter 0 (AXI port 0, outstanding counter 0)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>AXI counter 1 (AXI port 0, outstanding counter 1)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>AXI counter 2 (AXI port 1, outstanding counter 0)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>AXI counter 3 (AXI port 1, outstanding counter 1)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CH_SEL</name>
              <description>Select channel to monitor for bandwidth or latency measurements
Read operations:
 Write operations: </description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Cmd </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>IFM </description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Weights </description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Bias and Scale</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Mem2Mem</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>OFM </description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>Mem2Mem</description>
                  <value>0x9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMEVCNTR0</name>
          <description>Performance Monitor Event Count Register 0</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EV_CNTR</name>
              <description>Event counter value</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMEVCNTR1</name>
          <description>Performance Monitor Event Count Register 1</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EV_CNTR</name>
              <description>Event counter value</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMEVCNTR2</name>
          <description>Performance Monitor Event Count Register 2</description>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EV_CNTR</name>
              <description>Event counter value</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMEVCNTR3</name>
          <description>Performance Monitor Event Count Register 3</description>
          <addressOffset>0x30C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EV_CNTR</name>
              <description>Event counter value</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMEVTYPER0</name>
          <description>Performance Monitor Event Type Register 0</description>
          <addressOffset>0x380</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EV_TYPE</name>
              <description>Event type.
For field encoding (list of supported PMU events), refer to the Arm(R) Ethos(TM)-U55 NPU Technical Reference Manual.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMEVTYPER1</name>
          <description>Performance Monitor Event Type Register 1</description>
          <addressOffset>0x384</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EV_TYPE</name>
              <description>Event type.
For field encoding (list of supported PMU events), refer to the Arm(R) Ethos(TM)-U55 NPU Technical Reference Manual.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMEVTYPER2</name>
          <description>Performance Monitor Event Type Register 2</description>
          <addressOffset>0x388</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EV_TYPE</name>
              <description>Event type.
For field encoding (list of supported PMU events), refer to the Arm(R) Ethos(TM)-U55 NPU Technical Reference Manual.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMEVTYPER3</name>
          <description>Performance Monitor Event Type Register 3</description>
          <addressOffset>0x38C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EV_TYPE</name>
              <description>Event type.
For field encoding (list of supported PMU events), refer to the Arm(R) Ethos(TM)-U55 NPU Technical Reference Manual.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PID4</name>
          <description>Peripheral ID Register 4</description>
          <addressOffset>0xFD0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PID4</name>
              <description>Byte 4 of Peripheral ID (lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PID5</name>
          <description>Peripheral ID Register 5</description>
          <addressOffset>0xFD4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PID5</name>
              <description>Byte 5 of Peripheral ID (lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PID6</name>
          <description>Peripheral ID Register 6</description>
          <addressOffset>0xFD8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PID6</name>
              <description>Byte 6 of Peripheral ID (lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PID7</name>
          <description>Peripheral ID Register 7</description>
          <addressOffset>0xFDC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PID7</name>
              <description>Byte 7 of Peripheral ID (lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PID0</name>
          <description>Peripheral ID Register 0</description>
          <addressOffset>0xFE0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000080</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PID0</name>
              <description>Byte 0 of Peripheral ID (lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PID1</name>
          <description>Peripheral ID Register 1</description>
          <addressOffset>0xFE4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000B5</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PID1</name>
              <description>Byte 1 of Peripheral ID (lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PID2</name>
          <description>Peripheral ID Register 2</description>
          <addressOffset>0xFE8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0000000B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PID2</name>
              <description>Byte 2 of Peripheral ID (lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PID3</name>
          <description>Peripheral ID Register 3</description>
          <addressOffset>0xFEC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PID3</name>
              <description>Byte 3 of Peripheral ID (lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_CID0</name>
          <description>Component ID Register 0</description>
          <addressOffset>0xFF0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0000000D</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CID0</name>
              <description>Byte 0 of Component ID (lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_CID1</name>
          <description>Component ID Register 1</description>
          <addressOffset>0xFF4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000F0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CID1</name>
              <description>Byte 1 of Component ID (lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_CID2</name>
          <description>Component ID Register 2</description>
          <addressOffset>0xFF8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CID2</name>
              <description>Byte 2 of Component ID (lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_CID3</name>
          <description>Component ID Register 3</description>
          <addressOffset>0xFFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000B1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CID3</name>
              <description>Byte 3 of Component ID (lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>EVTRTR1</name>
      <baseAddress>0x400E2000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>148</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <dim>32</dim>
          <dimIncrement>4</dimIncrement>
          <name>EVTRTR1_DMA_CTRL[%s]</name>
          <description>DMA/Event Router Control and Status Register (n)</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACK_TYPE</name>
              <description>DMA handshake type status for DMA peripheral</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Peripheral completes the REQ-ACK handshake with DMA controller. Event Router passing through REQ-ACK between DMA controller and peripheral.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Event Router completes the REQ-ACK handshake with DMA controller. Peripheral raises DMA request without responding to ACK from DMA controller.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENA</name>
              <description>DMA channel enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable DMA channel</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable DMA channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>EVTRTR1_DMA_REQ_CTRL</name>
          <description>DMA Request Control Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00001000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CB</name>
              <description>Enable DMA request on DMACBREQ</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CS</name>
              <description>Enable DMA request on DMACSREQ</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLB</name>
              <description>Enable DMA request on DMACLBREQ</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLS</name>
              <description>Enable DMA request on DMACLSREQ</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>EVTRTR1_DMA_ACK_TYPE0</name>
          <description>DMA Handshake Type Register 0</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00FF0000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACK</name>
              <description>Select DMA handshake type for DMA group #0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>M55HP_CFG</name>
      <baseAddress>0x400F0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>20</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>HP_DMA_CTRL</name>
          <description>DMA1 Boot Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x00010001</resetMask>
          <fields>
            <field>
              <name>SW_RST</name>
              <description>Software reset for DMA1</description>
              <bitRange>[16:16]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No reset</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Reset DMA1. This bit is self-cleared.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BOOT_MANAGER</name>
              <description>When DMA1 exits from reset, this bit controls the security state of the DMA manager thread</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Assigns DMA manager to the secure state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Assigns DMA manager to the non-secure state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HP_DMA_IRQ</name>
          <description>DMA1 Boot IRQ Non-Secure Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BOOT_IRQ</name>
              <description>Controls the security state of an event-interrupt resource, when DMA1 exits from reset</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DMA1 assigns event x or IRQ[x] to the secure state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA1 assigns event x or IRQ[x] to the non-secure state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HP_DMA_PERIPH</name>
          <description>DMA1 Boot Peripheral Non-Secure Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BOOT_PERIPH</name>
              <description>Controls the security state of a peripheral request interface, when DMA1 exits from reset</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DMA1 assigns peripheral request interface x to the secure state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA1 assigns peripheral request interface x to the non-secure state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HP_DMA_SEL</name>
          <description>DMA1 Select Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFF000000</resetMask>
          <fields>
            <field>
              <name>FLT_ENA</name>
              <description>This field provides glitch filtering for the GPIO9_[7-0] signals that are mapped to DMA1 inputs [31-24] DMA1 (M55-HP) Requests Mapping).
For each bit:</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable glitch-filter for GPIO input</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable glitch-filter for GPIO input</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HP_CLK_ENA</name>
          <description>Peripheral Clock Enable Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x80000011</resetMask>
          <fields>
            <field>
              <name>WRAP_DIS</name>
              <description>Enable wrap cleaner</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Enable wrap cleaner</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Disable wrap cleaner</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DMA_CKEN</name>
              <description>Enable clock for DMA1 and EVTRTR1</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NPU_CKEN</name>
              <description>Enable clock for NPU-HP</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>WDT_HP_CTRL</name>
      <groupName>WDT</groupName>
      <baseAddress>0x40100000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>WDT_WDOGLOAD</name>
          <description>Watchdog Load Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WDOGLOAD</name>
              <description>When
this bit field is written, the count is immediately restarted from the new value.
 The minimum
valid value for this field is 0x1.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WDOGVALUE</name>
          <description>Watchdog Value Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WDOGVALUE</name>
              <description>This bit field gives the current value of the decrementing counter.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WDOGCONTROL</name>
          <description>Watchdog Control Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INTEN</name>
              <description>Enables the interrupt event, WDT_IRQ. 
 Reloads the counter from the value in WDT_WDOGLOAD register when the interrupt is enabled, afterpreviously being disabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The counter and the interrupt are disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The counter and the interrupt are enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WDOGINTCLR</name>
          <description>Watchdog Clear Interrupt Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>WDOGINTCLR</name>
              <description>A write of any value clears the watchdog interrupt, and reloads
the counter from the value in WDT_WDOGLOAD register.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WDOGRIS</name>
          <description>Watchdog Raw Interrupt Status Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RAW_WATCHDOG_INTERRUPT</name>
              <description>Enables the raw interrupt status from the counter. This value is
AND-ed with the value of WDT_WDOGCONTROL[INTEN] bit to create the masked interrupt.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WDOGMIS</name>
          <description>Watchdog Interrupt Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WATCHDOG_INTERRUPT</name>
              <description>Enables the masked interrupt status from the counter. This value is the logical AND of the raw interrupt status with the WDT_WDOGCONTROL[INTEN] bit, and isthe value of the WDT_IRQ.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WDOGLOCK</name>
          <description>Watchdog Lock Register</description>
          <addressOffset>0xC00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ENABLE_REGISTER_WRITES</name>
              <description>Enable write access to all other registers by writing 0x1ACC_E551. Disable write access by
writing any other value.</description>
              <bitRange>[31:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGISTER_WRITE_ENABLE_STATUS</name>
              <description>Write access status:</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Write access to all other registers is enabled. </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Write access to all other registers is disabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WDOGPERIPHID4</name>
          <description>Peripheral ID Register 4</description>
          <addressOffset>0xFD0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BLOCK_COUNT</name>
              <description>Block count</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>JEP106_C_CODE</name>
              <description>JEP106 continuation code value</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WDOGPERIPHID0</name>
          <description>Peripheral ID Register 0</description>
          <addressOffset>0xFE0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000024</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PART_NUMBER_7_0</name>
              <description>Part number</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WDOGPERIPHID1</name>
          <description>Peripheral ID Register 1</description>
          <addressOffset>0xFE4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000B8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>JEP106_ID_3_0</name>
              <description>JEP106 identity code [3:0]</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PART_NUMBER_11_8</name>
              <description>Part number</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WDOGPERIPHID2</name>
          <description>Peripheral ID Register 2</description>
          <addressOffset>0xFE8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0000001B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REVISION</name>
              <description>Revision of the TZC-400</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>JEDEC_USED</name>
              <description>Indicates that the TZC-400 uses a manufacturer identity code allocated by JEDEC according to JEP106.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>JEP106_ID_6_4</name>
              <description>JEP106 identity code [6:4]</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WDOGPERIPHID3</name>
          <description>Peripheral ID Register 3</description>
          <addressOffset>0xFEC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ECO_REVISION_NUMBER</name>
              <description>ECO revision number</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CUSTOMER_MODIFICATION_NUMBER</name>
              <description>Customer modification number</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WDOGPCELLID0</name>
          <description>Component ID Register 0</description>
          <addressOffset>0xFF0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0000000D</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMPONENT_ID_0</name>
              <description>Component ID 0</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WDOGPCELLID1</name>
          <description>Component ID Register 1</description>
          <addressOffset>0xFF4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000F0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMPONENT_ID_1</name>
              <description>Component ID 1</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WDOGPCELLID2</name>
          <description>Component ID Register 2</description>
          <addressOffset>0xFF8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMPONENT_ID_2</name>
              <description>Component ID 2</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WDOGPCELLID3</name>
          <description>Component ID Register 3</description>
          <addressOffset>0xFFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000B1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMPONENT_ID_3</name>
              <description>Component ID 3</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="WDT_HP_CTRL">
      <name>WDT_HP_REFRESH</name>
      <baseAddress>0x40101000</baseAddress>
    </peripheral>
    <peripheral>
      <name>LPRTC</name>
      <baseAddress>0x42000000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>40</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>LPRTC_CCVR</name>
          <description>Current Counter Value Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CURRENT_COUNTER_VALUE</name>
              <description>When read, this register contains the current value of the internal counter. This value is always read coherently.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPRTC_CMR</name>
          <description>Counter Match Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_MATCH</name>
              <description>When the internal counter matches this value, an interrupt is generated, provided interrupt generation is enabled.
When appropriate, this value is written coherently. Only when all the bytes are written, the value of this register is used by the interrupt detection logic.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPRTC_CLR</name>
          <description>Counter Load Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_LOAD</name>
              <description>Loaded into the counter as counter load value, which is written coherently.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPRTC_CCR</name>
          <description>Counter Control Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LPRTC_PSCLR_EN</name>
              <description>Controls the usage of the prescaler feature.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disables the prescaler.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables the prescaler.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPRTC_WEN</name>
              <description>Controls the wrap enable. Forces the counter to wrap to 0 when a match occurs, instead of waiting until the maximum count is reached.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disables the wrap.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables the wrap.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPRTC_EN</name>
              <description>Controls counting in the counter.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disables the counter.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables the counter.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPRTC_MASK</name>
              <description>Controls the interrupt mask. Determines whether an internally generated interrupt shall assert the IRQ line.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Unmasks the interrupt.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Masks the interrupt.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPRTC_IEN</name>
              <description>Controls the interrupt enable.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disables the interrupt generation.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables the interrupt generation.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>LPRTC_STAT</name>
          <description>Interrupt Status Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LPRTC_STAT</name>
              <description>Masked interrupt status.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Interrupt is inactive. The IRQ line is not asserted.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Interrupt is active. The IRQ line is asserted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>LPRTC_RSTAT</name>
          <description>Interrupt Raw Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LPRTC_RSTAT</name>
              <description>Raw interrupt status.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Interrupt is inactive.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Interrupt is active.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>LPRTC_EOI</name>
          <description>End-of-Interrupt Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LPRTC_EOI</name>
              <description>By reading this bit, the match interrupt is cleared. Performing a read-to-clear on interrupt, the interrupt is cleared at the end of the read.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPRTC_COMP_VERSION</name>
          <description>Component Version Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x3230372A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LPRTC_COMP_VERSION</name>
              <description>Component version</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPRTC_CPSR</name>
          <description>Counter Prescaler Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00008000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_PRESCALER_VALUE</name>
              <description>Counter prescaler value. This bit field is used to prescale the rate at which the LPRTC counter updates. The prescaler value is in the range 1-65536. By default, the counter increments at a 1 Hz rate when the prescaler is enabled and precise 32.768 kHz clock source is used.
When appropriate, this bit field is written coherently. Only when all the bytes are written, the register is used by the prescaler counter logic.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPRTC_CPCVR</name>
          <description>Current Prescaler Counter Value Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CURRENT_PRESCALER_COUNTER_VALUE</name>
              <description>When read, this bit field provides the current value of the internal prescaler counter. This value is always read coherently.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPTIMER</name>
      <baseAddress>0x42001000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>192</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>4</dim>
          <dimIncrement>20</dimIncrement>
          <name>LPTIMER_CHANNEL_CFG[%s]</name>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>LPTIMER_LOADCOUNT</name>
            <description>Timer (n) Load Count Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIMERN_LOADCOUNT</name>
                <description>Value to be loaded into Timer (n). This is the value from which counting commences. Any value written to this register is loaded into the associated timer.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LPTIMER_CURRENTVAL</name>
            <description>Timer (n) Current Value Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x80000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIMERN_CURRENTVALUE</name>
                <description>Current Value of Timer (n)</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LPTIMER_CONTROLREG</name>
            <description>Timer (n) Control Register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000010</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIMER_0N100PWM_EN</name>
                <description>0% and 100% PWM duty cycle mode for Timer (n).
Hardcoded to enabled state to reduce software overhead.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIMER_PWM</name>
                <description>Pulse Width Modulation of Timer (n) toggle output.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>PWM is disabled (normal toggle)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>PWM is enabled (PWM toggle)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIMER_INTERRUPT_MASK</name>
                <description>Timer interrupt mask for Timer (n).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Timer (n) interrupt is unmasked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Timer (n) interrupt is masked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIMER_MODE</name>
                <description>Timer mode for Timer (n).
Note: All bits of the LPTIMERn_LOADCOUNT register must be set to 1 before enabling Timer (n) in free-running mode.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Free-running count</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>User-defined count</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIMER_ENABLE</name>
                <description>Timer enable bit for Timer (n).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Timer (n) is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Timer (n) is enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>LPTIMER_EOI</name>
            <description>Timer (n) End-of-Interrupt Register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIMERN_EOI</name>
                <description>End-of-Interrupt for Timer (n).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LPTIMER_INTSTAT</name>
            <description>Timer (n) Interrupt Status Register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIMERN_INTSTATUS</name>
                <description>Interrupt status for Timer (n) after mask:</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Timer (n) interrupt is inactive. IRQ line is not asserted.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Timer (n) interrupt is active. IRQ line is asserted.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>LPTIMERS_INTSTATUS</name>
          <description>Timers Interrupt Status Register</description>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIMERS_INTSTATUS</name>
              <description>Interrupt status of all timers after mask, where:
Bit 3: LPTIMER3
Bit 2: LPTIMER2
Bit 1: LPTIMER1
Bit 0: LPTIMER0
For each bit:</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timer (n) interrupt is inactive. IRQ line is not asserted.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timer (n) interrupt is active. IRQ line is asserted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>LPTIMERS_EOI</name>
          <description>Timers End-of-Interrupt Register</description>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIMERS_EOI</name>
              <description>End-of-Interrupt for all timers, where:
Bit 3: LPTIMER3
Bit 2: LPTIMER2
Bit 1: LPTIMER1
Bit 0: LPTIMER0</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPTIMERS_RAWINTSTATUS</name>
          <description>Timers Raw Interrupt Status Register</description>
          <addressOffset>0xA8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIMERS_RAWINTSTAT</name>
              <description>Raw interrupt status of all timers, where:
Bit 3: LPTIMER3
Bit 2: LPTIMER2
Bit 1: LPTIMER1
Bit 0: LPTIMER0
For each bit:</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Raw Timer (n) interrupt is inactive.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Raw Timer (n) interrupt is active.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>LPTIMERS_COMP_VERSION</name>
          <description>LPTIMER Component Version</description>
          <addressOffset>0xAC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x3231322A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIMERS_COMP_VERSION</name>
              <description>LPTIMER version number</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>4</dimIncrement>
          <name>LPTIMER_LOADCOUNT2[%s]</name>
          <description>Timer (n) Load Count2 Register</description>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIMERN_LOADCOUNT2</name>
              <description>Value to be loaded into Timer (n) when toggle output changes from 0 to 1. This value determines the width of the high period of the toggle output.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPGPIO</name>
      <groupName>GPIO</groupName>
      <baseAddress>0x42002000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>272</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>GPIO_SWPORTA_DR</name>
          <description>GPIO Port Data Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_SWPORTA_DR</name>
              <description>The values written to this field are output on the GPIO signals if the corresponding GPIO_SWPORTA_DDR[GPIO_SWPORTA_DDR] field is set to 1.
The value read back is equal to the last value written to this field.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_SWPORTA_DDR</name>
          <description>GPIO Port Data Direction Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_SWPORTA_DDR</name>
              <description>The values written to this field independently control the data direction of the corresponding GPIO signal.
The direction is input after system reset by default.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Input direction</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Output direction</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_SWPORTA_CTL</name>
          <description>GPIO Port Data Source Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_SWPORTA_CTL</name>
              <description>For GPIO: Only bit [0] is valid. Bit [0] setting specifies whether the data source for the entire port (all pins) is hardware (AUX port) or software (normal operation). When hardware mode is selected, this enables the 'bit manipulation' feature on the GPIO port, as per the configuration in the bit manipulation registers.
 For LPGPIO: All bits [7-0] are valid. Individual bit values specify whether the data source for the corresponding pins is hardware (AUX port) or software (normal operation). When hardware mode is selected, this enables the LPTIMER I/O signals to be routed on the LPGPIO pins through the AUX port.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Software mode. Output data and direction control for the pins are sourced from GPIO_SWPORTA_DR and GPIO_SWPORTA_DDR registers, respectively. Input data can be read from the GPIO_EXT_PORTA register.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Hardware mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_INTEN</name>
          <description>GPIO Port Interrupt Enable Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_INTEN</name>
              <description>Writing a 1 to a bit of this field configures the corresponding GPIO to become an interrupt signal. 
Interrupts are disabled on the corresponding bits if the corresponding bit of GPIO_SWPORTA_DDR[GPIO_SWPORTA_DDR] field is set to 1 (output).
The generation of interrupts are disabled by default. </description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Interrupt is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Interrupt is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_INTMASK</name>
          <description>GPIO Port Interrupt Mask Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_INTMASK</name>
              <description>Writing a 1 to a bit in this field masks the interrupt generation capability for this corresponding GPIO signal. Otherwise interrupts are allowed through. The unmasked status is read as well as the resultant status after masking.
 All interrupt bits are unmasked by default. </description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Interrupt bits are unmasked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Interrupt bits are masked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_INTTYPE_LEVEL</name>
          <description>GPIO Port Interrupt Level Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_INTTYPE_LEVEL</name>
              <description>Writing a 0 to a bit of this field configures the interrupt type to be level-sensitive. Otherwise, it is edge-sensitive.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Interrupt is level sensitive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Interrupt is edge sensitive</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_INT_POLARITY</name>
          <description>GPIO Port Interrupt Polarity Register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_INT_POLARITY</name>
              <description>Writing a 0 to a bit of this field configures the interrupt type to Falling edge or Active-low sensitive. Otherwise, it is Rising edge or Active-high sensitive.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Active-low polarity / Falling edge</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Active-high polarity / Rising edge</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_INTSTATUS</name>
          <description>GPIO Port Interrupt Status Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_INTSTATUS</name>
              <description>Interrupt status after masks</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_RAW_INTSTATUS</name>
          <description>GPIO Port Raw Interrupt Status Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_RAW_INTSTATUS</name>
              <description>Raw interrupt status. This status is before masks.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_DEBOUNCE</name>
          <description>GPIO Port Debounce Enable Register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_DEBOUNCE</name>
              <description>Writing a 1 to a bit in this field enables the debouncing circuitry. A signal must be valid for two periods of the debounce clock before it is internally processed.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No debounce</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable debounce</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_PORTA_EOI</name>
          <description>GPIO Port End Of Interrupt Register</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_PORTA_EOI</name>
              <description>Writing a 1 to a bit of this field, clears the corresponding interrupt. </description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No interrupt clear</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clear Interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_EXT_PORTA</name>
          <description>GPIO External Port Read Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_EXT_PORTA</name>
              <description>This register provides either the data on the GPIO pins or the contents of the GPIO_SWPORTA_DR, depending on the value of GPIO_SWPORTA_DDR.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_LS_SYNC</name>
          <description>Synchronization Level Register</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_LS_SYNC</name>
              <description>Writing a 1 to this bit results in all level-sensitive interrupts being synchronized to PCLK_INTR.
 They are not synchronized to PCLK_INTR by default.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No synchronization to PCLK_INTR</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Synchronize to PCLK_INTR</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_INT_BOTHEDGE</name>
          <description>GPIO Port Interrupt Both Edge Type Register</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_INT_BOTHEDGE</name>
              <description>Writing a 1 to a bit of this field enables the generation of interrupts on both the Rising edge and the Falling edge of an external input signal.
The values programmed in the registers GPIO_INTTYPE_LEVEL and GPIO_INT_POLARITY for this particular bit are not considered when the corresponding bit of this field is set to 1.
Writing a 0 to a bit of this field makes the interrupt type to depend on the value of the corresponding bits in the GPIO_INTTYPE_LEVEL and GPIO_INT_POLARITY registers.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Single edge sensitive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Both edge sensitive</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_VER_ID_CODE</name>
          <description>GPIO Version ID Register</description>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>GPIO_VER_ID_CODE</name>
              <description>Module version ID code</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_CONFIG_REG2</name>
          <description>Module Configuration Register 2</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00039CE7</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ENCODED_ID_PWIDTH_D</name>
              <description>Reserved for multi-port configuration</description>
              <bitRange>[19:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ENCODED_ID_PWIDTH_C</name>
              <description>Reserved for multi-port configuration</description>
              <bitRange>[14:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ENCODED_ID_PWIDTH_B</name>
              <description>Reserved for multi-port configuration</description>
              <bitRange>[9:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ENCODED_ID_PWIDTH_A</name>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>Port is 8 bits wide</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_CONFIG_REG1</name>
          <description>Module Configuration Register 1</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x003F70F2</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INTERRUPT_BOTH_EDGE_TYPE</name>
              <description>The value of this bit defines the interrupt generation type.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Interrupt generation on both rising and falling edge</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENCODED_ID_WIDTH</name>
              <description>The value of this field defines the encoded ID width.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GPIO_ID</name>
              <description>The value of this bit defines the GPIO ID.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>GPIO_ID not included</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADD_ENCODED_PARAMS</name>
              <description>The value of this bit defines the encoded parameters.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Encoded parameters added</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEBOUNCE</name>
              <description>The value of this bit defines the debounce capability.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Included debounce capability</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PORTA_INTR</name>
              <description>The value of this bit defines the Port A interrupts configuration.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>PORT A is required to be used as an interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HW_PORTD</name>
              <description>Reserved for multi-port configuration</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_PORTC</name>
              <description>Reserved for multi-port configuration</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_PORTB</name>
              <description>Reserved for multi-port configuration</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_PORTA</name>
              <description>The value of this bit defines the Port A hardware configuration.
 : GPIOs - Port A has no external auxiliary hardware signals</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>LPGPIO - Port A has external auxiliary hardware signals</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PORTD_SINGLE_CTL</name>
              <description>Reserved for multi-port configuration</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PORTC_SINGLE_CTL</name>
              <description>Reserved for multi-port configuration</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PORTB_SINGLE_CTL</name>
              <description>Reserved for multi-port configuration</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PORTA_SINGLE_CTL</name>
              <description>The value of this bit defines the Port A single source configuration.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Port A is controlled from two sources - LPGPIO</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Port A is controlled from a single source - GPIOs</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NUM_PORTS</name>
              <description>The value of this field defines the number of ports.</description>
              <bitRange>[3:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Number of ports is 1</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>APB_DATA_WIDTH</name>
              <description>The value of this field defines the APB data width.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>APB data width is 32 bits</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_BIT_MAN_CTRL</name>
          <description>Bit Manipulation Control Register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>AUX_PORTA_OUT</name>
              <description>Direct control value to output port. This value is directly reflected on the device pins.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_BIT_MAN_CTRL_W1C</name>
          <description>Bit Manipulation Control Register - Write 1 to Clear</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>AUX_PORTA_OUT_W1C</name>
              <description>Write 1 to clear (to 0) an output pin. Write 0: no action on output pin. Reads return last value written to this register.</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_BIT_MAN_CTRL_W1F</name>
          <description>Bit Manipulation Control Register - Write 1 to Toggle</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>AUX_PORTA_OUT_W1F</name>
              <description>Write 1 to toggle (flip) an output pin. Write 0: no action on output pin. Reads return last value written to this register.</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>oneToToggle</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_BIT_MAN_CTRL_W1S</name>
          <description>Bit Manipulation Control Register - Write 1 to Set</description>
          <addressOffset>0x10C</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>AUX_PORTA_OUT_W1S</name>
              <description>Write 1 to set (to 1) an output pin. Write 0: no action on output pin. Reads return last value written to this register.</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPCMP</name>
      <baseAddress>0x42003000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>LPCOMP_CTRL</name>
          <description>LPCMP Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFF000003</resetMask>
          <fields>
            <field>
              <name>COMP_LP0_CTRL</name>
              <description>LPCMP Control Register
bit[31:29]: comp_lp0_hyst
bit[28:27]: comp_lp0_in_m_sel
bit[26:25]: comp_lp0_in_p_sel
bit[24] : comp_lp_en (0=disable, 1=enable)</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LPCOMP_CLK_SEL</name>
              <description>LPCMP Control Register - lpcomp_clk_sel
bit[1]: Select clk</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LPCOMP_CLK32_EN</name>
              <description>LPCMP Control Register - lpcomp_clk32_en
bit[0]: Enable clk32 (0=disable, 1=enable)</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BOR_BOD</name>
      <baseAddress>0x42004000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>BROWNOUT_CTRL</name>
          <description>BOR and BOD Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFE007F00</resetMask>
          <fields>
            <field>
              <name>BROWNOUT_RESET</name>
              <description>Brownout Reset Control
bit[31:29] : brownout_reset_thresh
bit[28:26] : brownout_reset_hyst
bit[25] : brownout_reset_en (0=disable, 1=enable)</description>
              <bitRange>[31:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BROWNOUT_DET</name>
              <description>Brownout Detect Control
bit[14:12] : brownout_det_thresh
bit[11:9] : brownout_det_hyst
bit[8] : brownout_det_en (0=disable, 1=enable)</description>
              <bitRange>[14:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPGPIO_CTRL</name>
      <baseAddress>0x42007000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>32</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>LPGPIO_CTRL_[%s]</name>
          <description>LPGPIO I/O Buffer Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000022</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>DRIVER</name>
              <description>Driver configuration
- Bit[7] selects driver mode:
0x0: Push-pull
0x1: Open drain
- Bits[6-5] select driver strength:
0x0: 2 mA
0x1: 4 mA (default)
0x2: 8 mA
0x3: 12 mA
- Bits[4-3] select driver disabled state:
0x0: Hi-Z
0x1: Pull-up
0x2: Pull-down
0x3: Bus keeper
- Bit[2] selects slew rate: 
Note: Applicable only to 1.8-V I/Os (non-Flex)
0x0: Slow
0x1: Fast</description>
              <bitRange>[7:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RECEIVER</name>
              <description>Receiver configuration
- Bit[1] Schmitt trigger (hysteresis) enable:
0x0: Disabled
0x1: Enabled
- Bit[0] receiver enable:
0x0: Disabled
0x1: Enabled</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPSPI0</name>
      <groupName>SPI</groupName>
      <baseAddress>0x43000000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>240</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>LPSPI_CTRLR0</name>
          <description>Control Register 0</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x01070000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SSTE</name>
              <description>Slave Select Toggle Enable.
While operating in LPSPI mode with clock phase (SCPH) set to 0x0, this bit controls the behavior of the slave select line between data frames.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The slave select line will stay low and LPSPI_SCLK will run continuously for the duration of the transfer</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The slave select line will toggle between consecutive data frames, with the serial clock (LPSPI_SCLK) being held to its default value while the slave select line is high</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFS_32</name>
              <description>Data Frame Size in 32-bit transfer mode.
Selects the data frame size in 32-bit transfer mode. When the data frame size is programmed to be less than 32 bits, the receive data is automatically right-justified by the receive logic, with the upper bits of the receive FIFO zero-padded.
User must right-justify transmit data before writing into the transmit FIFO. The transmit logic ignores the upper unused bits when transmitting the data.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>04-bit serial data transfer</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>05-bit serial data transfer</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>06-bit serial data transfer</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>07-bit serial data transfer</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>08-bit serial data transfer</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>09-bit serial data transfer</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>10-bit serial data transfer</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>11-bit serial data transfer</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>12-bit serial data transfer</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>13-bit serial data transfer</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xD</name>
                  <description>14-bit serial data transfer</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xE</name>
                  <description>15-bit serial data transfer</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description>16-bit serial data transfer</description>
                  <value>0xF</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x10</name>
                  <description>17-bit serial data transfer</description>
                  <value>0x10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x11</name>
                  <description>18-bit serial data transfer</description>
                  <value>0x11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x12</name>
                  <description>19-bit serial data transfer</description>
                  <value>0x12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x13</name>
                  <description>20-bit serial data transfer</description>
                  <value>0x13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x14</name>
                  <description>21-bit serial data transfer</description>
                  <value>0x14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x15</name>
                  <description>22-bit serial data transfer</description>
                  <value>0x15</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x16</name>
                  <description>23-bit serial data transfer</description>
                  <value>0x16</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x17</name>
                  <description>24-bit serial data transfer</description>
                  <value>0x17</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x18</name>
                  <description>25-bit serial data transfer</description>
                  <value>0x18</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x19</name>
                  <description>26-bit serial data transfer</description>
                  <value>0x19</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1A</name>
                  <description>27-bit serial data transfer</description>
                  <value>0x1A</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1B</name>
                  <description>28-bit serial data transfer</description>
                  <value>0x1B</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1C</name>
                  <description>29-bit serial data transfer</description>
                  <value>0x1C</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1D</name>
                  <description>30-bit serial data transfer</description>
                  <value>0x1D</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1E</name>
                  <description>31-bit serial data transfer</description>
                  <value>0x1E</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1F</name>
                  <description>32-bit serial data transfer</description>
                  <value>0x1F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CFS</name>
              <description>Control Frame Size.
Selects the length of the control word for the Microwire frame format.</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>01-bit Control Word</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>02-bit Control Word</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>03-bit Control Word</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>04-bit Control Word</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>05-bit Control Word</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>06-bit Control Word</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>07-bit Control Word</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>08-bit Control Word</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>09-bit Control Word</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>10-bit Control Word</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>11-bit Control Word</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>12-bit Control Word</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>13-bit Control Word</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xD</name>
                  <description>14-bit Control Word</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xE</name>
                  <description>15-bit Control Word</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description>16-bit Control Word</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRL</name>
              <description>Shift Register Loop.
Used for testing purposes only. When internally active, connects the transmit shift register output to the receive shift register input. Can be used in both serial slave and serial master mode. </description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Normal Mode Operation</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Test Mode Operation</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TMOD</name>
              <description>Transfer Mode.
Selects the mode of transfer for serial communication. This field does not affect the transfer duplicity. Only indicates whether the receive or transmit data are valid.
In Transmit Only mode, data received from the external device is not valid and is not stored in the receive FIFO memory; it is overwritten on the next transfer.
In Receive Only mode, transmitted data are not valid. After the first write to the transmit FIFO, the same word is retransmitted for the duration of the transfer.
In Transmit and Receive mode, both transmit and receive data are valid. The transfer continues until the transmit FIFO is empty. Data received from the external device are stored into the receive FIFO memory, where it can be accessed by the host processor.
In EEPROM-read mode, receive data is not valid while control data is being transmitted. When all control data is sent to the EEPROM, receive data becomes valid and transmit data becomes invalid. All data in the transmit FIFO is considered control data in this mode. This transfer mode is only valid when the LPSPI is programmed as master device.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit and Receive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit Only mode</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Receive Only mode</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>EEPROM Read mode</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SCPOL</name>
              <description>Serial Clock Polarity.
Valid when the Frame Format (FRF) bit is set to Motorola SPI. Used to select the polarity of the inactive serial clock, which is held inactive when the LPSPI master is not actively transferring data on the serial bus.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Inactive state of serial clock is low</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Inactive state of serial clock is high</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SCPH</name>
              <description>Serial Clock Phase.
Valid when the FRF bit is set to Motorola SPI. The serial clock phase selects the relationship of the serial clock with the slave select signal.
When SCPH = 0, data are captured on the first edge of the serial clock. When SCPH = 1, the serial clock starts toggling one cycle after the slave select line is activated, and data are captured on the second edge of the serial clock.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Serial clock toggles in middle of first bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Serial clock toggles at start of first bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FRF</name>
              <description>Frame Format.
Selects which serial protocol transfers the data.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Motorola SPI frame format</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Texas Instruments SSP frame format</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>National Semiconductors Microwire frame format</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>LPSPI_CTRLR1</name>
          <description>Control Register 1</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NDF</name>
              <description>Number of Data Frames.
When the LPSPI_CTRLR0[TMOD] = 0x2 or LPSPI_CTRLR0[TMOD] = 0x3, this bit field sets the number of data frames to be continuously received by the LPSPI. The LPSPI continues to receive serial data until the number of data frames received is equal to this register value plus 1, which enables the user to receive up to 64KB of data in a continuous transfer. When the SPI is programmed as a serial slave,
the transfer continues for as long as the slave is selected.
Therefore, this bit field serves no purpose and is not present when
the SPI is programmed as a serial slave.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPSPI_ENR</name>
          <description>LPSPI Enable Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPI_EN</name>
              <description>LPSPI Enable.
Enables and disables all LPSPI operations. When disabled, all serial transfers are halted immediately. Transmit and receive FIFO buffers are cleared when the device is disabled. It is impossible to program some of the LPSPI control registers when enabled. When disabled, the LPSPI sleep output is set (after delay) to inform the system that it is safe to remove the LPSPI_CLK, thus saving power consumption in the system.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disables LPSPI</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables LPSPI</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>LPSPI_MWCR</name>
          <description>Microwire Control Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MHS</name>
              <description>Microwire Handshaking.
 Relevant only when the LPSPI is programmed as a serial master device. When configured as a serial slave, this bit has no functionality. Used to enable and disable the busy/ready handshaking interface for the Microwire protocol. When enabled, the LPSPI checks for a READY status from the target slave, after the transfer of the last data/control bit, before clearing the BUSY status in the LPSPI_SR[BUSY] bit.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Handshaking interface is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Handshaking interface is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MDD</name>
              <description>Microwire Control.
Defines the direction of the data word when the Microwire serial protocol is used. When this bit is set to 0, the data word is received by the LPSPI module from the external serial device. When this bit is set to 1, the data word is transmitted from the LPSPI module to the external serial device.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>LPSPI receives data</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>LPSPI transmits data</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MWMOD</name>
              <description>Microwire Transfer Mode.
Defines whether the Microwire transfer is sequential or non-sequential. When sequential mode is used, only one control word is needed to transmit or receive a block of data words. When non-sequential mode is used, there must be a control word for each data word that is transmitted or received.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Non-Sequential Transfer</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Sequential Transfer</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>LPSPI_SER</name>
          <description>Slave Enable Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SER</name>
              <description>Slave Select Enable Flag.
Each bit in this bit field corresponds to a slave select line from the LPSPI master. When a bit in this bit field is set to 0x1, the corresponding slave select line from the master is activated when a serial transfer begins. It should be noted that setting or clearing bits in this bit field have no effect on the corresponding slave select outputs until a transfer is started. Before beginning a transfer, user should enable the bit in this field that corresponds to the slave device with which the master wants to communicate. When not operating in broadcast mode, only one bit in this field should be set.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not Selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Selected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>LPSPI_BAUDR</name>
          <description>Baud Rate Select Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCKDV</name>
              <description>LPSPI Clock Divider.
This field contains the MSB 15 bits of the 16-bit LPSPI_CLK divider value. The LSB for LPSPI_CLK divider is always set to 0 and is unaffected by a write operation, which ensures the divider is always set to an even value. If this field is set to all 0s, the serial output clock (LPSPI_SCLK) is disabled. The frequency of the LPSPI_SCLK is derived from the following equation:
 FLPSPI_SCLK = FLPSPI_CLK/SCKDV
Where SCKDV is any even value between 2 and 65534.
 For example, for FLPSPI_CLK = 3.6864 MHz and SCKDV = 1b'1:
SCKDV = 2 and FLPSPI_SCLK= 3.6864/2 = 1.8432 MHz.
For more information, see Section SPI Clock Ratios.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPSPI_TXFTLR</name>
          <description>Transmit FIFO Threshold Level Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TFT</name>
              <description>Transmit FIFO Threshold.
Controls the level of entries (or below) at which the transmit FIFO controller triggers an interrupt. The FIFO depth is 16. If the value in this bit field is set greater than or equal to the depth of the FIFO, this bit field is not written and retains its current value. When the number of transmit FIFO entries is less than or equal to this value, the transmit FIFO empty interrupt is triggered.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPSPI_RXFTLR</name>
          <description>Receive FIFO Threshold Level Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFT</name>
              <description>Receive FIFO Threshold.
Controls the level of entries (or above) at which the receive FIFO controller triggers an interrupt. The FIFO depth is 16. If the value in this bit field is set greater than the depth of the FIFO, this bit field is not written and retains its current value. When the number of receive FIFO entries is greater than or equal to this value + 1, the receive FIFO full interrupt is triggered.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPSPI_TXFLR</name>
          <description>Transmit FIFO Level Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXTFL</name>
              <description>Transmit FIFO Level.
Contains the number of valid data entries in the transmit FIFO.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPSPI_RXFLR</name>
          <description>Receive FIFO Level Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXTFL</name>
              <description>Receive FIFO Level.
Contains the number of valid data entries in the receive FIFO.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPSPI_SR</name>
          <description>Status Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000006</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DCOL</name>
              <description>Data Collision Error.
 Relevant only when the LPSPI is programmed as a master device. This bit is set if slave select input is asserted by other master, when the LPSPI master is in the middle of the transfer. This informs the processor that the last data transfer was halted before completion. This bit is cleared when read.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No Error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit Data Collision Error</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFF</name>
              <description>Receive FIFO Full.
When the receive FIFO is completely full, this bit is set. When the receive FIFO contains one or more empty location, this bit is cleared.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO is not full</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO is full</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFNE</name>
              <description>Receive FIFO Not Empty.
Set when the receive FIFO contains one or more entries and is cleared when the receive FIFO is empty. This bit can be polled by software to completely empty the receive FIFO.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO is empty</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO is not empty</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TFE</name>
              <description>Transmit FIFO Empty.
When the transmit FIFO is completely empty, this bit is set. When the transmit FIFO contains one or more valid entries, this bit is cleared. This bit field does not request an interrupt.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO is not empty</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO is empty</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TFNF</name>
              <description>Transmit FIFO Not Full.
Set when the transmit FIFO contains one or more empty locations, and is cleared when the FIFO is full.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO is full</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO is not full</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUSY</name>
              <description>LPSPI Busy Flag.
When set, indicates that a serial transfer is in progress; when cleared indicates that the LPSPI is idle or disabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>LPSPI is idle or disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>LPSPI is actively transferring data</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>LPSPI_IMR</name>
          <description>Interrupt Mask Register</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000003F</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MSTIM</name>
              <description>Multi-Master Contention Interrupt Mask.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Multi-Master Contention interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Multi-Master Contention interrupt is not masked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFIM</name>
              <description>Receive FIFO Full Interrupt Mask.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Full interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Full interrupt is not masked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXOIM</name>
              <description>Receive FIFO Overflow Interrupt Mask.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Overflow interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Overflow interrupt is not masked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXUIM</name>
              <description>Receive FIFO Underflow Interrupt Mask.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Underflow interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Underflow interrupt is not masked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXOIM</name>
              <description>Transmit FIFO Overflow Interrupt Mask.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Overflow interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Overflow interrupt is not masked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXEIM</name>
              <description>Transmit FIFO Empty Interrupt Mask.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Empty interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Empty interrupt is not masked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>LPSPI_ISR</name>
          <description>Interrupt Status Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MSTIS</name>
              <description>Multi-Master Contention Interrupt Status. </description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Multi-Master Contention interrupt is not active after masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Multi-Master Contention interrupt is active after masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFIS</name>
              <description>Receive FIFO Full Interrupt Status.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Full interrupt is not active after masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Full interrupt is active after masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXOIS</name>
              <description>Receive FIFO Overflow Interrupt Status.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Overflow interrupt is not active after masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Overflow interrupt is active after masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXUIS</name>
              <description>Receive FIFO Underflow Interrupt Status.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Underflow interrupt is not active after masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Underflow interrupt is active after masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXOIS</name>
              <description>Transmit FIFO Overflow Interrupt Status.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Overflow interrupt is not active after masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Overflow interrupt is active after masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXEIS</name>
              <description>Transmit FIFO Empty Interrupt Status.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Empty interrupt is not active after masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Empty interrupt is active after masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>LPSPI_RISR</name>
          <description>Raw Interrupt Status Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MSTIR</name>
              <description>Multi-Master Contention Raw Interrupt Status.
This bit field is not functional if the LPSPI is programmed as a serial slave
device.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Multi-Master Contention interrupt is not active prior masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Multi-Master Contention interrupt is active prior to masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFIR</name>
              <description>Receive FIFO Full Raw Interrupt Status.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Full interrupt is not active prior masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Full interrupt is active prior to masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXOIR</name>
              <description>Receive FIFO Overflow Raw Interrupt Status.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Overflow interrupt is not active prior masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Overflow interrupt is active prior to masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXUIR</name>
              <description>Receive FIFO Underflow Raw Interrupt Status.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Underflow interrupt is not active prior masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Underflow interrupt is active prior to masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXOIR</name>
              <description>Transmit FIFO Overflow Raw Interrupt Status.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Overflow interrupt is not active prior masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Overflow interrupt is active prior to masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXEIR</name>
              <description>Transmit FIFO Empty Raw Interrupt Status.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Empty interrupt is not active prior masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Empty interrupt is active prior to masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>LPSPI_TXOICR</name>
          <description>Transmit FIFO Overflow Interrupt Clear Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXOICR</name>
              <description>Clear Transmit FIFO Overflow Interrupt.
This bit reflects the status of the interrupt. A read from this bit clears the Transmit FIFO Overflow interrupt; writing has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPSPI_RXOICR</name>
          <description>Receive FIFO Overflow Interrupt Clear Register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXOICR</name>
              <description>Clear Receive FIFO Overflow Interrupt.
This bit reflects the status of the interrupt. A read from this bit clears the Receive FIFO Overflow interrupt; writing has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPSPI_RXUICR</name>
          <description>Receive FIFO Underflow Interrupt Clear Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXUICR</name>
              <description>Clear Receive FIFO Underflow Interrupt.
This bit reflects the status of the interrupt. A read from this bit clears the Receive FIFO Underflow interrupt; writing has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPSPI_MSTICR</name>
          <description>Multi-Master Interrupt Clear Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MSTICR</name>
              <description>Clear Multi-Master Contention Interrupt.
This bit reflects the status of the interrupt. A read from this bit clears the Multi-Master Contention interrupt; writing has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPSPI_ICR</name>
          <description>Interrupt Clear Register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ICR</name>
              <description>Clear Interrupts.
This bit is set if any of the interrupts below are active. A read clears the Transmit FIFO Overflow, Receive FIFO Underflow, Receive FIFO Overflow, and Multi-Master Contention interrupts. Writing to this bit has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPSPI_DMACR</name>
          <description>DMA Control Register</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDMAE</name>
              <description>Transmit DMA Enable. This bit enables/disables the transmit FIFO DMA channel.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit DMA disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit DMA enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RDMAE</name>
              <description>Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive DMA disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive DMA enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>LPSPI_DMATDLR</name>
          <description>DMA Transmit Data Level Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMATDL</name>
              <description>Transmit Data Level.
This bit field controls the level at which a DMA request is made by the transmit logic. It is equal to the watermark level; that is, the transmit DMA request signal is generated when the number of valid data entries in the transmit FIFO is equal to or below this bit field value, and the LPSPI_DMACR[TDMAE] = 0x1.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPSPI_DMARDLR</name>
          <description>DMA Receive Data Level Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMARDL</name>
              <description>Receive Data Level. This bit field controls the level at which a DMA request is made by the receive logic. The watermark level is equal to DMARDL + 1; that is, receive DMA request is generated when the number of valid data entries in the receive FIFO is equal to or above this bit field value + 1, and LPSPI_DMACR[RDMAE] = 0x1.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPSPI_IDR</name>
          <description>Identification Register</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xC7C5C3C1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IDCODE</name>
              <description>Identification code</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPSPI_VERSION_ID</name>
          <description>Version ID Register</description>
          <addressOffset>0x5C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>SPI_COMP_VERSION</name>
              <description>Component version</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>36</dim>
          <dimIncrement>4</dimIncrement>
          <name>LPSPI_DR[%s]</name>
          <description>LPSPI Data Register (n)</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DR</name>
              <description>Data Register (n).
When writing to this register, the user must right-justify the data. Read data are automatically right-justified.
Read = Receive FIFO buffer
Write = Transmit FIFO buffer</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPI2S</name>
      <groupName>I2S</groupName>
      <baseAddress>0x43001000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>612</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>I2S_IER</name>
          <description>I2S Enable Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000F00</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDM_SLOTS</name>
              <description>These bits are used to program the number of receive and transmit slots in a TDM frame.
Programmed number of slots must be less than or equal to I2S_TDM_SLOTS-1. If the selected number of slots is greater than the I2S_TDM_SLOTS-1, the number of slots defaults back to I2S_TDM_SLOTS-1.
The I2S must be disabled prior to any changes in this field (that is, IEN = 0).</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1 slot in a TDM frame</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>2 slots in a TDM frame</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>3 slots in a TDM frame</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>4 slots in a TDM frame</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>5 slots in a TDM frame</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>6 slots in a TDM frame</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>7 slots in a TDM frame</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>8 slots in a TDM frame</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>9 slots in a TDM frame</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>10 slots in a TDM frame</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xa</name>
                  <description>11 slots in a TDM frame</description>
                  <value>0xa</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>12 slots in a TDM frame</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xc</name>
                  <description>13 slots in a TDM frame</description>
                  <value>0xc</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xd</name>
                  <description>14 slots in a TDM frame</description>
                  <value>0xd</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xe</name>
                  <description>15 slots in a TDM frame</description>
                  <value>0xe</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xf</name>
                  <description>16 slots in a TDM frame</description>
                  <value>0xf</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FRAME_OFF</name>
              <description>Frame Offset. This bit specifies the TDM Interface Frame Offset.
The I2S must be disabled prior to any changes in this field (that is, IER[0] = 0).</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>0 SCLK cycle</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>1 SCLK cycle</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INTF_TYPE</name>
              <description>I2S Audio Interface Type.
The I2S must be disabled prior to any changes in this field (that is, IER[0] = 0).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Standard I2S Interface</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>TDM Interface</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IEN</name>
              <description>I2S Enable.
This bit enables or disables the I2S module. Disabling this bit (I2S_IER[IEN] = 0x0) overrides any other block or channel enables, and flushes all FIFOs.
 For more information about how this bit affects the other I2S blocks, refer to Section I2S Enable.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>I2S disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>I2S enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_IRER</name>
          <description>I2S Receiver Block Enable Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXEN</name>
              <description>Receiver Block Enable.
This bit enables or disables the Receiver block. Disabling this bit (I2S_IRER[RXEN] = 0x0) overrides the receive channel enables.
 For more information about the Receiver block, refer to Section I2S as a Receiver.
Note: When the I2S is configured with TDM Interface support, the number of channels are always fixed to one and it is always enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receiver disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receiver enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_ITER</name>
          <description>I2S Transmitter Block Enable Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXEN</name>
              <description>Transmitter Block Enable.
This bit enables or disables the Transmitter block. Disabling this bit (I2S_ITER[TXEN] = 0x0) overrides the transmit channel enables. 
For more information about the Transmitter block, refer to Section I2S as a Transmitter.
Note: When the I2S is configured with TDM Interface support, the number of channels are always fixed to one and it is always enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmitter disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmitter enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_CER</name>
          <description>Clock Enable Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLKEN</name>
              <description>Clock Generation Enable or Disable.
This bit enables or disables the clock generation signals when the I2S module is a master: SCLK_EN, WS_OUT, and SCLK_GATE.
For more information about clock generation, refer to Section I2S Clocks.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock generation disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clock generation enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_CCR</name>
          <description>Clock Configuration Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WSS</name>
              <description>This bit field is used to program the number of SCLK cycles for which the word select line (WS_OUT) stays in the left or right sample mode. Word select length greater than 32 requires DWC-APB-Advanced-Source license. The I2S Clock Generation block must be disabled (I2S_CER[CLKEN] = 0x0) prior to any changes in this value.
0x0: 16 SCLK cycles
0x1: 24 SCLK cycles
0x2: 32 SCLK cycles
0x3: 64 SCLK cycles
0x4: 128 SCLK cycles
0x5: 256 SCLK cycles</description>
              <bitRange>[4:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCLKG</name>
              <description>This bit field is used to program the gating of SCLK. The programmed gating value must be less than or equal to the largest configured (programmed) audio resolution to prevent the truncating of Rx/Tx data. The I2S Clock Generation block must be disabled (I2S_CER[CLKEN] = 0x0) before making any changes in this value.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock gating is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Gating after 12 SCLK cycles</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Gating after 16 SCLK cycles</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Gating after 20 SCLK cycles</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Gating after 24 SCLK cycles</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>Gating after 32 SCLK cycles</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_RXFFR</name>
          <description>Receiver Block FIFO Reset Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXFFR</name>
              <description>Receiver FIFO Reset.
Writing a 0x1 to this bit flushes all the Rx FIFOs (this is a self clearing bit). The Receiver block must be disabled before writing to this bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Does not flush the Rx FIFO</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Flushes the Rx FIFO</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_TXFFR</name>
          <description>Transmitter Block FIFO Reset Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXFFR</name>
              <description>Transmitter FIFO Reset.
Writing a 0x1 to this bit flushes all the Tx FIFOs (this is a self clearing bit). The Transmitter block must be disabled prior to writing this bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Does not flush the Tx FIFO</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Flushes the Tx FIFO</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_SR</name>
          <description>Status Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TFE</name>
              <description>Transmit FIFO Empty.
TDM mode (I2S_IER[INTF_TYPE] = 1):
When all of the enabled transmit slot FIFOs become completely empty, this bit is set.. When any one of the enabled transmit FIFOs contains one or more valid entries, this bit is cleared.
Note: When the I2S is transmitting the last TDM frame, this bit is set along with the last slot in that frame - as the data is popped with it. Hence, user must wait for one slot length, 32 cycles (to ensure that last slot data is transmitted), to disable the interface.
I2S mode (I2S_IER[INTF_TYPE] = 0):
When Left and Right transmit FIFOs are completely empty, this bit is set. When the Left or Right transmit FIFO contains one or more valid entries, this bit is cleared.
Note: When the I2S is transmitting the last I2S frame, this bit is set along with the right data transmission in that frame - as the data is popped with it. Hence, user must wait for one word select length (to ensure the right data is transmitted), to disable the interface.
This bit field does not request an interrupt.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO is not empty</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO is empty</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_LRBR0</name>
          <description>Left Receive Buffer Register 0</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LRBRX</name>
              <description>The left stereo data received serially from the receive channel input (SDI). 
If the Rx FIFO is full and the two-stage read operation (for instance, a read from the I2S_LRBR0[LRBRX] bit field followed by a read from the I2S_RRBR0[RRBRX] bit field) is not performed before the start of the next stereo pair, then the new data is lost and an overrun interrupt occurs (data already in the Rx FIFO is preserved).
Note: Before reading this register again, the right stereo data must be read from the I2S_RRBR0[RRBRX] bit field or the status (interrupts) will not be valid.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_LTHR0</name>
          <description>Left Transmit Holding Register 0</description>
          <alternateRegister>I2S_LRBR0</alternateRegister>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LTHRX</name>
              <description>The left stereo data to be transmitted serially through the transmit channel output (SDO) is written through this bit field.
Writing is a two-stage process:
1. A write to this bit field passes the left stereo sample to the transmitter.
2. This must be followed by writing the right stereo sample to the I2S_RTHR0[RTHRX] bit field.
Note: Data must only be written to the FIFO when it is not full. Any attempt to write to a full FIFO results in that data being lost and an overrun interrupt being generated.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_RRBR0</name>
          <description>Right Receive Buffer Register 0</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RRBRX</name>
              <description>The right stereo data received serially from the receive channel input (SDI) is read through this bit field. If the Rx FIFO is full and the two-stage read operation (for instance, read from the I2S_LRBR0[LRBRX] bit field followed by a read from the I2S_RRBR0[RRBRX] bit field) is not performed before the start of the next stereo pair, then the new data is lost and an overrun interrupt occurs (data already in the Rx FIFO is preserved).
Note: Prior to reading this bit field, the left stereo data must be read from the I2S_LRBR0[LRBRX] bit field, or the status (interrupts) will not be valid.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_RTHR0</name>
          <description>Right Transmit Holding Register</description>
          <alternateRegister>I2S_RRBR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RTHRX</name>
              <description>The right stereo data to be transmitted serially through the transmit channel output (SDO) is written through this bit field.
Writing is a two-stage process:
1. A left stereo sample must be written to the I2S_LTHR0[LTHRX] bit field.
2. A write to this bit field passes the right stereo sample to the transmitter.
Note: Data should only be written to the FIFO when it is not full. Any attempt to write to a full FIFO results in that data being lost and an overrun interrupt being generated.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_RER0</name>
          <description>Receive Enable Register 0</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00FFFF01</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXSLOT15_EN</name>
              <description>Receiver slot 15 enable. Writing a 1/0 into this bit enables/disables the slot.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slot 15 Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slot 15 Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXSLOT14_EN</name>
              <description>Receiver slot 14 enable. Writing a 1/0 into this bit enables/disables the slot.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slot 14 Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slot 14 Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXSLOT13_EN</name>
              <description>Receiver slot 13 enable. Writing a 1/0 into this bit enables/disables the slot.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slot 13 Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slot 13 Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXSLOT12_EN</name>
              <description>Receiver slot 12 enable. Writing a 1/0 into this bit enables/disables the slot.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slot 12 Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slot 12 Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXSLOT11_EN</name>
              <description>Receiver slot 11 enable. Writing a 1/0 into this bit enables/disables the slot.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slot 11 Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slot 11 Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXSLOT10_EN</name>
              <description>Receiver slot 10 enable. Writing a 1/0 into this bit enables/disables the slot.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slot 10 Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slot 10 Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXSLOT9_EN</name>
              <description>Receiver slot 9 enable. Writing a 1/0 into this bit enables/disables the slot.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slot 9 Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slot 9 Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXSLOT8_EN</name>
              <description>Receiver slot 8 enable. Writing a 1/0 into this bit enables/disables the slot.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slot 8 Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slot 8 Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXSLOT7_EN</name>
              <description>Receiver slot 7 enable. Writing a 1/0 into this bit enables/disables the slot.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slot 7 Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slot 7 Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXSLOT6_EN</name>
              <description>Receiver slot 6 enable. Writing a 1/0 into this bit enables/disables the slot.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slot 6 Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slot 6 Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXSLOT5_EN</name>
              <description>Receiver slot 5 enable. Writing a 1/0 into this bit enables/disables the slot.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slot 5 Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slot 5 Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXSLOT4_EN</name>
              <description>Receiver slot 4 enable. Writing a 1/0 into this bit enables/disables the slot.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slot 4 Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slot 4 Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXSLOT3_EN</name>
              <description>Receiver slot 3 enable. Writing a 1/0 into this bit enables/disables the slot.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slot 3 Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slot 3 Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXSLOT2_EN</name>
              <description>Receiver slot 2 enable. Writing a 1/0 into this bit enables/disables the slot.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slot 2 Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slot 2 Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXSLOT1_EN</name>
              <description>Receiver slot 1 enable. Writing a 1/0 into this bit enables/disables the slot.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slot 1 Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slot 1 Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXSLOT0_EN</name>
              <description>Receiver slot 0 enable. Writing a 1/0 into this bit enables/disables the slot.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slot 0 Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slot 0 Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXCHENX</name>
              <description>Receive channel enable. This bit enables/disables a receive channel, independently of all other channels.
On enable, the channel begins receiving on the next left stereo cycle.
A global disable of I2S (IER[0] = 0) or the Receiver block (IRER[0] = 0) overrides this value.
When the I2S is configured with TDM Interface support, the number of channels are always fixed to one and it is always enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive Channel Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive Channel Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_TER0</name>
          <description>Transmit Enable Register 0</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00FFFF01</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXSLOT15_EN</name>
              <description>Transmitter slot 15 enable. Writing a 1/0 into this bit enables/disables the slot.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slot 15 Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slot 15 Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXSLOT14_EN</name>
              <description>Transmitter slot 14 enable. Writing a 1/0 into this bit enables/disables the slot.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slot 14 Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slot 14 Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXSLOT13_EN</name>
              <description>Transmitter slot 13 enable. Writing a 1/0 into this bit enables/disables the slot.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slot 13 Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slot 13 Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXSLOT12_EN</name>
              <description>Transmitter slot 12 enable register. Writing a 1/0 into this bit enables/disables the slot.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slot 12 Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slot 12 Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXSLOT11_EN</name>
              <description>Transmitter slot 11 enable register. Writing a 1/0 into this bit enables/disables the slot.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slot 11 Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slot 11 Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXSLOT10_EN</name>
              <description>Transmitter slot 10 enable. Writing a 1/0 into this bit enables/disables the slot.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slot 10 Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slot 10 Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXSLOT9_EN</name>
              <description>Transmitter slot 9 enable. Writing a 1/0 into this bit enables/disables the slot.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slot 9 Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slot 9 Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXSLOT8_EN</name>
              <description>Transmitter slot 8 enable. Writing a 1/0 into this bit enables/disables the slot.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slot 8 Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slot 8 Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXSLOT7_EN</name>
              <description>Transmitter slot 7 enable. Writing a 1/0 into this bit enables/disables the slot.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slot 7 Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slot 7 Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXSLOT6_EN</name>
              <description>Transmitter slot 6 enable. Writing a 1/0 into this bit enables/disables the slot.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slot 6 Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slot 6 Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXSLOT5_EN</name>
              <description>Transmitter slot 5 enable. Writing a 1/0 into this bit enables/disables the slot.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slot 5 Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slot 5 Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXSLOT4_EN</name>
              <description>Transmitter slot 4 enable. Writing a 1/0 into this bit enables/disables the slot.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slot 4 Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slot 4 Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXSLOT3_EN</name>
              <description>Transmitter slot 3 enable. Writing a 1/0 into this bit enables/disables the slot.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slot 3 Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slot 3 Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXSLOT2_EN</name>
              <description>Transmitter slot 2 enable. Writing a 1/0 into this bit enables/disables the slot.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slot 2 Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slot 2 Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXSLOT1_EN</name>
              <description>Transmitter slot 1 enable. Writing a 1/0 into this bit enables/disables the slot.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slot 1 Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slot 1 Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXSLOT0_EN</name>
              <description>Transmitter slot 0 enable. Writing a 1/0 into this bit enables/disables the slot.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slot 0 Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slot 0 Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXCHENX</name>
              <description>Transmit channel enable. This bit enables/disables a transmit channel, independently of all other channels.
On enable, the channel begins transmitting on the next left stereo cycle.
A global disable of I2S (IER[0] = 0) or Transmitter block (ITER[0] = 0) overrides this value.
When the I2S is configured with TDM Interface support, the number of channels are always fixed to one and it is always enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit Channel Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit Channel Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_RCR0</name>
          <description>Receive Configuration Register 0</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WLEN</name>
              <description>This bit field is used to program the desired data resolution of the receiver and enables the LSB of the incoming left (or right) word to be placed in the LSB of the I2S_LRBR0[LRBRX] (or I2S_RRBR0[RRBRX]) bit field.
Programmed data resolution must be less than or equal to the I2S_COMP_PARAM_2[I2S_RX_WORDSIZE_x] bit field value, where x = 0 to 3. If the selected resolution is greater than the I2S_COMP_PARAM_2[I2S_RX_WORDSIZE_x] bit field value, the receive channel defaults back to the to the maximum audio data resolution supported.
The channel must be disabled prior to any changes in this value (I2S_RER0[RXCHENX] = 0x0).
Note: When the I2S is configured with TDM Interface support, the number of channels are always fixed to one and it is always enabled. Hence, with TDM Interface configuration, the receiver block must be disabled prior to any changes in this field's value (that is, IRER[0] = 0).</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Ignore the word length</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>12-bit data resolution of the receiver</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>16-bit data resolution of the receiver</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>20-bit data resolution of the receiver</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>24-bit data resolution of the receiver</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>32-bit data resolution of the receiver</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_TCR0</name>
          <description>Transmit Configuration Register 0</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WLEN</name>
              <description>This bit field is used to program the desired data resolution of the transmitter and ensures the MSB of the data is transmitted first.
Programmed resolution must be less than or equal to the I2S_COMP_PARAM_1[I2S_TX_WORDSIZE_x] bit field value, where x = 0 to 3. If the selected resolution is greater than the I2S_COMP_PARAM_1[I2S_TX_WORDSIZE_x] bit field value, the transmit channel defaults back to the to the maximum audio data resolution supported.
The channel must be disabled prior to any changes in this value (I2S_TER0[TXCHENX] = 0x0).
Note: When the I2S is configured with TDM Interface support, the number of channels are always fixed to one and it is always enabled. Hence, with TDM Interface configuration, the transmitter block must be disabled prior to any changes in this field's value (that is, ITER[0] = 0).</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Ignore the word length</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>12-bit data resolution of the transmitter</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>16-bit data resolution of the transmitter</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>20-bit data resolution of the transmitter</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>24-bit data resolution of the transmitter</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>32-bit data resolution of the transmitter</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_ISR0</name>
          <description>Interrupt Status Register 0</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXFU</name>
              <description>Indicates TX FIFO Underrun Interrupt generated for Transmit Channel x.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No TX FIFO underrun</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>TX FIFO underrun</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXFO</name>
              <description>Status of Data Overrun Interrupt for the Tx Channel.
This bit specifies whether the Tx FIFO write is valid or an overrun (attempt to write to full Tx FIFO).</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Tx FIFO write valid</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Tx FIFO write overrun</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXFE</name>
              <description>Status of Transmit Empty Trigger Interrupt.
This bit specifies whether the Tx FIFO trigger level has reached or not (Tx FIFO is empty).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Tx FIFO trigger level is reached</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Tx FIFO trigger level is not reached</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFO</name>
              <description>Status of Data Overrun Interrupt for the Rx Channel.
Incoming data lost due to a full Rx FIFO.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Rx FIFO write valid</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Rx FIFO write overrun</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXDA</name>
              <description>Status of Receive Data Available Interrupt.
This bit denotes the status of the Rx FIFO trigger level.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Rx FIFO trigger level is not reached</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Rx FIFO trigger level is reached</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_IMR0</name>
          <description>Interrupt Mask Register 0</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000073</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXFUM</name>
              <description>Mask TX FIFO Underrun interrupt. This bit masks or unmasks a TX FIFO Underrun interrupt.
This bit masks or unmasks a Tx FIFO Underrun interrupt.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Masks TX FIFO Underrun interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Unmasks TX FIFO Underrun interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXFOM</name>
              <description>Mask Tx FIFO Overrun Interrupt.
This bit masks or unmasks a Tx FIFO Overrun interrupt.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Masks Tx FIFO Overrun interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Unmasks Tx FIFO Overrun interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXFEM</name>
              <description>Mask Tx FIFO Empty Interrupt.
This bit masks or unmasks a Tx FIFO Empty interrupt.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Masks Tx FIFO Empty interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Unmasks Tx FIFO Empty Interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFOM</name>
              <description>Mask Rx FIFO Overrun Interrupt.
This bit masks or unmasks an Rx FIFO Overrun interrupt.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Masks Rx FIFO Overrun interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Unmasks Rx FIFO Overrun interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXDAM</name>
              <description>Mask Rx FIFO Data Available Interrupt.
This bit masks or unmasks an Rx FIFO Data Available interrupt.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Masks Rx FIFO data available interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Unmasks Rx FIFO data available interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_ROR0</name>
          <description>Receive Overrun Register 0</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXCHO</name>
              <description>Read this bit to clear the Rx FIFO Data Overrun interrupt.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Rx FIFO write valid</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Rx FIFO write overrun</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_TICR0</name>
          <description>Transmit Interrupt Clear Register 0</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXCHOU</name>
              <description>Read this bit to clear TX FIFO Data Overrun or Data Underrun interrupts.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No TX FIFO overrun or underrun</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>TX FIFO overrun or underrun</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_RFCR0</name>
          <description>Receive FIFO Configuration Register 0</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXCHDT</name>
              <description>This bit field programs the trigger level in the Rx FIFO at which the Received Data Available interrupt and DMA request is generated (Trigger Level = Programmed Value + 1).
Valid values of the I2S_RFCR0[RXCHDT] bit field: 0 to Rx FIFO depth - 1.
If an illegal value is programmed, this bit field saturates to Rx FIFO depth - 1.
For more information about FIFO depth, refer to Section I2S Overview.
The channel must be disabled prior to any changes in this value (that is, I2S_RER0[RXCHENX] = 0x0).
Note: When the I2S is configured with TDM Interface support, the number of channels are always fixed to one and it is always enabled. Hence, with TDM Interface configuration, the receiver block must be disabled prior to any changes in this field's value (that is, IRER[0] = 0).</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 3</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 4</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 5</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 6</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 7</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 8</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 9</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 10</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 11</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 12</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 13</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xD</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 14</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xE</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 15</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 16</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_TFCR0</name>
          <description>Transmit FIFO Configuration Register 0</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXCHET</name>
              <description>This bit field programs the trigger level in the Tx FIFO at which the Empty Threshold Reached interrupt and DMA request is generated (Trigger Level = TXCHET).
Valid values of the I2S_TFCR0[TXCHET] bit field: 0 to Tx FIFO depth - 1.
If an illegal value is programmed, this bit field saturates to Tx FIFO depth - 1. The channel must be disabled prior to any changes in this value (that is, I2S_TER0[TXCHENX] = 0x0).
Note: When the I2S is configured with TDM Interface support, the number of channels are always fixed to one and it is always enabled. Hence, with TDM Interface configuration, the transmitter block must be disabled prior to any changes in this field's value (that is, ITER[0] = 0).</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 3</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 4</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 5</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 6</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 7</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 8</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 9</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 10</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 11</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 12</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 13</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xD</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 14</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xE</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 15</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 16</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_RFF0</name>
          <description>Receive FIFO Flush Register 0</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXCHFR</name>
              <description>Receive Channel FIFO Reset.
Writing a 0x1 to this bit flushes the channel Rx FIFO (this is a self clearing bit). The Rx channel or block must be disabled prior to writing to this bit. In TDM mode, writing a 1 to this register flushes all Slot FIFOs.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Does not flush the channel Rx FIFO</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Flushes the channel Rx FIFO</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_TFF0</name>
          <description>Transmit FIFO Flush Register 0</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXCHFR</name>
              <description>Transmit Channel FIFO Reset.
Writing a 0x1 to this bit flushes the channel Tx FIFO (this is a self clearing bit). The Tx channel or block must be disabled prior to writing to this bit. In TDM mode, writing a 1 to this register flushes all Slot FIFOs.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Does not flush TX FIFO of the channel</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Flushes TX FIFO of the channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_RXDMA</name>
          <description>Receiver Block DMA Register</description>
          <addressOffset>0x1C0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXDMA</name>
              <description>Receiver Block DMA.
In Standard I2S Interface Mode, these bits are used to cycle repeatedly through the enabled receive channels (from lowest numbered to highest), reading stereo data pairs.
In TDM Interface Mode, these bits are used to cycle repeatedly read through the enabled receive slots (from lowest numbered to highest).
For more information about the supported receive channels, refer to Section I2S Overview.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_RRXDMA</name>
          <description>Reset Receiver Block DMA Register</description>
          <addressOffset>0x1C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RRXDMA</name>
              <description>Reset Receiver Block DMA Register.
Writing a 1 to this self-clearing register resets the RXDMA register mid-cycle to point to the lowest enabled Receive channel.
Note: Writing to this register has no effect if the component is performing a stereo pair read (such as, when left stereo data has been read but not right stereo data).
When the I2S is programmed for TDM support, Writing a 1 to this self-clearing register resets the RXDMA register mid-cycle to point to the lowest enabled Receive slot.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Reset Receiver Block DMA Register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_TXDMA</name>
          <description>Transmitter Block DMA Register</description>
          <addressOffset>0x1C8</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXDMA</name>
              <description>Transmitter Block DMA.
These bits are used to allow writing of stereo data pairs to the enabled transmit channel.
In TDM Interface mode, these bits are used to cycle repeatedly write through the enabled transmit slots (from lowest numbered to highest).
For more information about the supported transmit channels, refer to Section I2S Overview.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_RTXDMA</name>
          <description>Reset Transmitter Block DMA Register</description>
          <addressOffset>0x1CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RTXDMA</name>
              <description>Reset Transmitter Block DMA Register.
Writing a 1 to this self-clearing register resets the TXDMA register mid-cycle to point to the lowest enabled Transmit channel.
Note: This register has no effect in the middle of a stereo pair write (such as, when left stereo data has been written but not right stereo data).
When the I2S is programmed for TDM support, writing a 1 to this self-clearing register resets the TXDMA register mid-cycle to point to the lowest enabled transmit slot.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Reset Transmitter Block DMA Register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_COMP_PARAM_2</name>
          <description>Module Configuration Register 2</description>
          <addressOffset>0x1F0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0000048C</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2S_RX_WORDSIZE_3</name>
              <description>These bits specify the Rx resolution for WORDSIZE_3.</description>
              <bitRange>[12:10]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>16-bit Resolution</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2S_RX_WORDSIZE_2</name>
              <description>These bits specify the Rx resolution for WORDSIZE_2.</description>
              <bitRange>[9:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>16-bit Resolution</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2S_RX_WORDSIZE_1</name>
              <description>These bits specify the Rx resolution for WORDSIZE_1.</description>
              <bitRange>[5:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>16-bit Resolution</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2S_RX_WORDSIZE_0</name>
              <description>These bits specify the Rx resolution for WORDSIZE_0.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>32-bit Resolution</description>
                  <value>0x4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_COMP_PARAM_1</name>
          <description>Module Configuration Register 1</description>
          <addressOffset>0x1F4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x024C007E</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2S_TX_WORDSIZE_3</name>
              <description>These bits specify the Tx resolution for WORDSIZE_3.</description>
              <bitRange>[27:25]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>16-bit Resolution</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2S_TX_WORDSIZE_2</name>
              <description>These bits specify the Tx resolution for WORDSIZE_2.</description>
              <bitRange>[24:22]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>16-bit Resolution</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2S_TX_WORDSIZE_1</name>
              <description>These bits specify the Tx resolution for WORDSIZE_1.</description>
              <bitRange>[21:19]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>16-bit Resolution</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2S_TX_WORDSIZE_0</name>
              <description>These bits specify the Tx resolution for WORDSIZE_0.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>32-bit Resolution</description>
                  <value>0x4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2S_TX_CHANNELS</name>
              <description>These bits specify the number of Tx channels.</description>
              <bitRange>[10:9]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1 x Transmit channel</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2S_RX_CHANNELS</name>
              <description>These bits specify the number of Rx channels.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1 x Receive channel</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2S_RECEIVER_BLOCK</name>
              <description>This bit specifies whether the receiver block is enabled or not.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receiver block is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2S_TRANSMITTER_BLOCK</name>
              <description>This bit specifies whether the transmitter block is enabled or not.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmitter block is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2S_MODE_EN</name>
              <description>This bit specifies whether the Master mode is enabled or not.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Master mode is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2S_FIFO_DEPTH_GLOBAL</name>
              <description>These bits specify the FIFO depth for Tx and Rx channels.</description>
              <bitRange>[3:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>FIFO depth is equals to 16 for Tx and Rx channels</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>APB_DATA_WIDTH</name>
              <description>These bits specify the APB data width.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>APB data width of 32 bits</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_COMP_VERSION</name>
          <description>Component Parameter Register</description>
          <addressOffset>0x1F8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>I2S_COMP_VERSION</name>
              <description>Module component version</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_COMP_TYPE</name>
          <description>Component Type Register</description>
          <addressOffset>0x1FC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x445701A0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2S_COMP_TYPE</name>
              <description>Component type</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_DMACR</name>
          <description>DMA Control Register</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMAEN_TXBLOCK</name>
              <description>DMA enable for the Transmit block.
This bit enables or disables the DMA handshake logic for the transmitter block.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DMA disabled for the transmit block</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA enabled for the transmit block</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DMAEN_RXBLOCK</name>
              <description>DMA enable for the Receive block.
 This bit enables or disables the DMA handshake logic for the receiver block.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DMA disabled for the receiver block</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA enabled for the receiver block</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>I2S_RSLOT[%s]</name>
          <description>Receive Slot (n) Buffer Register</description>
          <addressOffset>0x224</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RSLOTN</name>
              <description>The slot (n) data received serially from the receiver input (sdi0). If the RX FIFO is full and read operation is not performed before the start of the next slot data, then the new data is lost and an overrun interrupt occurs. (Data already in the RX FIFO is preserved).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>I2S_TSLOT[%s]</name>
          <description>Transmit Slot (n) Buffer Register</description>
          <alternateRegister>I2S_RSLOT[%s]</alternateRegister>
          <addressOffset>0x224</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSLOTN</name>
              <description>The slot (n) data to be transmitted serially through the transmitter output (sdo0) is written through this register. Data must only be written to the FIFO when it is not full. Any attempt to write to a full FIFO results in that data being lost and an overrun interrupt being generated.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPPDM</name>
      <groupName>PDM</groupName>
      <baseAddress>0x43002000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>2008</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PDM_CTL0</name>
          <description>PDM Audio Control Register 0</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FIFO_CLR</name>
              <description>FIFO clear</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PDM_MODE</name>
              <description>PDM clock frequency selection for all channels.
For more details about these modes,PDM Modes.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>PDM mode 0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>PDM mode 1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>PDM mode 9</description>
                  <value>0x9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CH7_EN</name>
              <description>Channel 7 enable.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable and soft-clear</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CH6_EN</name>
              <description>Channel 6 enable.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable and soft-clear</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CH5_EN</name>
              <description>Channel 5 enable.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable and soft-clear</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CH4_EN</name>
              <description>Channel 4 enable.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable and soft-clear</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CH3_EN</name>
              <description>Channel 3 enable.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable and soft-clear</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CH2_EN</name>
              <description>Channel 2 enable.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable and soft-clear</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CH1_EN</name>
              <description>Channel 1 enable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable and soft-clear</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CH0_EN</name>
              <description>Channel 0 enable.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable and soft-clear</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PDM_CTL1</name>
          <description>PDM Audio Control Register 1</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>USE_DMA_HANDSHAKE</name>
              <description>Use DMA handshaking signals for flow control.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_ADVANCE</name>
              <description>Sampling of PDM data by SAMPLE_PHASE number of PDM_CLK periods around PDM_Ci edges.
Adjust to compensate for routing delay skew between PDM_Ci and PDM_Di and to meet sampling time requirement of the microphone.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Retard sampling</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Advance sampling</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SAMPLE_PHASE</name>
              <description>Sampling phase of PDM data in units of PDM_CLK period.
Adjust to compensate for routing delay skew between PDM_Ci and PDM_Di and to meet sampling time requirement of the microphone.</description>
              <bitRange>[16:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PKDET_NODE</name>
              <description>Peak detection node.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Before gain stage</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>After gain stage</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BYP_FIR</name>
              <description>Bypass FIR filter.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYP_IIR</name>
              <description>Bypass DC blocking IIR filter.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PDM_FIFO_WATERMARK_H</name>
          <description>FIFO Watermark Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WATERMARK_H</name>
              <description>Threshold to trigger FIFO almost full warning interrupt</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PDM_FIFO_STAT</name>
          <description>FIFO Status Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Count of sets of audio data entry in FIFO for each channel available to be read. A set consists of one PDM sample per channel.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PDM_ERROR_IRQ</name>
          <description>FIFO Error Interrupt Status Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FIFO_OVERFLOW_IRQ</name>
              <description>Asserts if audio stream causes FIFO overflow</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>PDM_WARN_IRQ</name>
          <description>FIFO Warning Interrupt Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FIFO_ALMOST_FULL_IRQ</name>
              <description>Alerts the Host that FIFO fill level has reached or exceeded the PDM_FIFO_WATERMARK_H threshold and audio data should be read to avoid FIFO overflow error.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>PDM_AUDIO_DETECT_IRQ</name>
          <description>Audio Detection Interrupt Status Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH7_AUDIO_DETECT_IRQ</name>
              <description>Asserts if the peak absolute value of audio signal in channel 7 exceeds the peak detector high threshold for the channel</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>CH6_AUDIO_DETECT_IRQ</name>
              <description>Asserts if the peak absolute value of audio signal in channel 6 exceeds the peak detector high threshold for the channel</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>CH5_AUDIO_DETECT_IRQ</name>
              <description>Asserts if the peak absolute value of audio signal in channel 5 exceeds the peak detector high threshold for the channel</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>CH4_AUDIO_DETECT_IRQ</name>
              <description>Asserts if the peak absolute value of audio signal in channel 5 exceeds the peak detector high threshold for the channel</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>CH3_AUDIO_DETECT_IRQ</name>
              <description>Asserts if the peak absolute value of audio signal in channel 3 exceeds the peak detector high threshold for the channel</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>CH2_AUDIO_DETECT_IRQ</name>
              <description>Asserts if the peak absolute value of audio signal in channel 2 exceeds the peak detector high threshold for the channel</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>CH1_AUDIO_DETECT_IRQ</name>
              <description>Asserts if the peak absolute value of audio signal in channel 1 exceeds the peak detector high threshold for the channel</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>CH0_AUDIO_DETECT_IRQ</name>
              <description>Asserts if the peak absolute value of audio signal in channel 0 exceeds the peak detector high threshold for the channel</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>PDM_IRQ_ENABLE</name>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH7_AUDIO_DETECT_IRQ_EN</name>
              <description>Channel 7 audio peak detection interrupt enable</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH6_AUDIO_DETECT_IRQ_EN</name>
              <description>Channel 6 audio peak detection interrupt enable</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH5_AUDIO_DETECT_IRQ_EN</name>
              <description>Channel 5 audio peak detection interrupt enable</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH4_AUDIO_DETECT_IRQ_EN</name>
              <description>Channel 4 audio peak detection interrupt enable</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3_AUDIO_DETECT_IRQ_EN</name>
              <description>Channel 3 audio peak detection interrupt enable</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2_AUDIO_DETECT_IRQ_EN</name>
              <description>Channel 2 audio peak detection interrupt enable</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1_AUDIO_DETECT_IRQ_EN</name>
              <description>Channel 1 audio peak detection interrupt enable</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0_AUDIO_DETECT_IRQ_EN</name>
              <description>Channel 0 audio peak detection interrupt enable</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO_OVERFLOW_IRQ_EN</name>
              <description>FIFO overflow error interrupt enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO_ALMOST_FULL_IRQ_EN</name>
              <description>FIFO almost full warning interrupt enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PDM_CH0_CH1_AUDIO_OUT</name>
          <description>Channels 0 and 1 Audio Output Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH1_AUDIO</name>
              <description>Channel 1 audio output</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0_AUDIO</name>
              <description>Channel 0 audio output</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PDM_CH2_CH3_AUDIO_OUT</name>
          <description>Channels 2 and 3 Audio Output Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH3_AUDIO</name>
              <description>Channel 3 audio output</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2_AUDIO</name>
              <description>Channel 2 audio output</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PDM_CH4_CH5_AUDIO_OUT</name>
          <description>Channels 4 and 5 Audio Output Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH5_AUDIO</name>
              <description>Channel 5 audio output</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH4_AUDIO</name>
              <description>Channel 4 audio output</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PDM_CH6_CH7_AUDIO_OUT</name>
          <description>Channels 6 and 7 Audio Output Register</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH7_AUDIO</name>
              <description>Channel 7 audio output</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH6_AUDIO</name>
              <description>Channel 6 audio output</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>8</dim>
          <dimIncrement>256</dimIncrement>
          <name>PDM_CHANNEL_CFG[%s]</name>
          <addressOffset>0x40</addressOffset>
          <register>
            <name>PDM_CH_FIR_COEF_0</name>
            <description>Channel (n) FIR Filter Coefficient 0 Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_0</name>
                <description>FIR coefficient 0.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_1</name>
            <description>Channel (n) FIR Filter Coefficient 1 Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_1</name>
                <description>FIR coefficient 1.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_2</name>
            <description>Channel (n) FIR Filter Coefficient 2 Register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_2</name>
                <description>FIR coefficient 2.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_3</name>
            <description>Channel (n) FIR Filter Coefficient 3 Register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_3</name>
                <description>FIR coefficient 3.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_4</name>
            <description>Channel (n) FIR Filter Coefficient 4 Register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_4</name>
                <description>FIR coefficient 4.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_5</name>
            <description>Channel (n) FIR Filter Coefficient 5 Register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_5</name>
                <description>FIR coefficient 5.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_6</name>
            <description>Channel (n) FIR Filter Coefficient 6 Register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_6</name>
                <description>FIR coefficient 6.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_7</name>
            <description>Channel (n) FIR Filter Coefficient 7 Register</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_7</name>
                <description>FIR coefficient 7.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_8</name>
            <description>Channel (n) FIR Filter Coefficient 8 Register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_8</name>
                <description>FIR coefficient 8.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_9</name>
            <description>Channel (n) FIR Filter Coefficient 9 Register</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_9</name>
                <description>FIR coefficient 9.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_10</name>
            <description>Channel (n) FIR Filter Coefficient 10 Register</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_10</name>
                <description>FIR coefficient 10.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_11</name>
            <description>Channel (n) FIR Filter Coefficient 11 Register</description>
            <addressOffset>0x2C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_11</name>
                <description>FIR coefficient 11.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_12</name>
            <description>Channel (n) FIR Filter Coefficient 12 Register</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_12</name>
                <description>FIR coefficient 12.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_13</name>
            <description>Channel (n) FIR Filter Coefficient 13 Register</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_13</name>
                <description>FIR coefficient 13.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_14</name>
            <description>Channel (n) FIR Filter Coefficient 14 Register</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_14</name>
                <description>FIR coefficient 14.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_15</name>
            <description>Channel (n) FIR Filter Coefficient 15 Register</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_15</name>
                <description>FIR coefficient 15.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_16</name>
            <description>Channel (n) FIR Filter Coefficient 16 Register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_16</name>
                <description>FIR coefficient 16.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_17</name>
            <description>Channel (n) FIR Filter Coefficient 17 Register</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_17</name>
                <description>FIR coefficient 17.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_IIR_COEF_SEL</name>
            <description>Channel (n) IIR Filter Coefficient Selection Register</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000009</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>COEFSEL</name>
                <description>IIR filter coefficient selector for DC blocker filter characterized with the following transfer function: H(z) = (1 - z^-1) / (1 - a x z^-1), where a = 1 - (2^-COEFSEL).</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_PHASE</name>
            <description>Channel (n) Phase Control Register</description>
            <addressOffset>0x84</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PHASE</name>
                <description>Channel phase delay in units of PDM_Ci cycle counts</description>
                <bitRange>[5:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_GAIN</name>
            <description>Channel (n) Gain Control Register</description>
            <addressOffset>0x88</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000010</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>GAIN</name>
                <description>Gain in unsigned 8.4 format (Matlab 12.4 format)</description>
                <bitRange>[11:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_PKDET_TH</name>
            <description>Channel (n) Peak Detector Threshold Register</description>
            <addressOffset>0x8C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFF0000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TH_HI</name>
                <description>High threshold for peak detection</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH_LO</name>
                <description>Low threshold for peak detection</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_PKDET_ITV</name>
            <description>Channel (n) Peak Detector Interval Register</description>
            <addressOffset>0x90</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000780</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DLY_SP</name>
                <description>Number of samples to skip before peak detection starts</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CNT_SP</name>
                <description>Number of samples to use for peak detection</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_PKDET_STAT</name>
            <description>Channel (n) Peak Detector Status Register</description>
            <addressOffset>0x94</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNT_HI</name>
                <description>High peak count. Number of occurrences of the absolute value of audio signal exceeding PDM_CHn_PKDET_TH[TH_HI] threshold in the most recent peak detection interval specified by PDM_CHn_PKDET_ITV register.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CNT_LO</name>
                <description>Low peak count. Number of occurrences of the absolute value of audio signal going below PDM_CHn_PKDET_TH[TH_LO] threshold in the most recent peak detection interval specified by PDM_CHn_PKDET_ITV register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPCPI</name>
      <groupName>CPI</groupName>
      <baseAddress>0x43003000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>84</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CAM_CTRL</name>
          <description>Camera Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001115</resetMask>
          <fields>
            <field>
              <name>FIFO_CLK_SEL</name>
              <description>Select clock source for the camera data input FIFO.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Select internal clock for soft reset</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Select external camera clock for normal function mode</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_RESET</name>
              <description>Software reset.
Software shall set then clear this bit.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Not reset</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Reset</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SNAPSHOT</name>
              <description>Snapshot mode selection.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>NA</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Capture one frame then stop (snapshot mode)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUSY</name>
              <description>Status of video capture.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Not capturing video</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Capturing video</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>START</name>
              <description>Start video capture.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>No action</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Start video capture</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CAM_INTR</name>
          <description>Camera Interrupt Status Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00110071</resetMask>
          <fields>
            <field>
              <name>HSYNC</name>
              <description>Rising edge of HSYNC signal.</description>
              <bitRange>[20:20]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>VSYNC</name>
              <description>Rising edge of VSYNC signal.</description>
              <bitRange>[16:16]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>BRESP_ERR</name>
              <description>AXI bus BRESP error.</description>
              <bitRange>[6:6]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>OUTFIFO_OVERRUN</name>
              <description>Output FIFO overrun.</description>
              <bitRange>[5:5]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>INFIFO_OVERRUN</name>
              <description>Input FIFO overrun.</description>
              <bitRange>[4:4]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>STOP</name>
              <description>Video capture stopped.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CAM_INTR_ENA</name>
          <description>Camera Interrupt Enable Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00110071</resetMask>
          <fields>
            <field>
              <name>HSYNC</name>
              <description>Rising edge of HSYNC signal.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VSYNC</name>
              <description>Rising edge of VSYNC signal.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BRESP_ERR</name>
              <description>AXI bus BRESP error.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTFIFO_OVERRUN</name>
              <description>Output FIFO overrun.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INFIFO_OVERRUN</name>
              <description>Input FIFO overrun.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP</name>
              <description>Video capture stopped.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAM_CFG</name>
          <description>Camera Configuration Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x3117713F</resetMask>
          <fields>
            <field>
              <name>DATA_MASK</name>
              <description>Select camera data mask.
Valid only when [DATA_MODE] field is set to 16-bit.
Note: This register field is not functional for LPCPI.</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>16-bit</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>10-bit</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_2</name>
                  <description>12-bit</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_3</name>
                  <description>14-bit</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CODE10ON8</name>
              <description>Special coding: transfer 10-bit coding over 8-bit data bus.
Valid only when [DATA_MODE] field is set to 8-bit.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Disable special 10-bit coding</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Enable special 10-bit coding</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MSB</name>
              <description>Select MSB/LSB
Valid only when [DATA_MODE] field is set to 1-/2-/4-/8-bit.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>LSB</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>MSB</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATA_MODE</name>
              <description>Select video data mode.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>1-bit</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>2-bit</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_2</name>
                  <description>4-bit</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_3</name>
                  <description>8-bit</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_4</name>
                  <description>16-bit (Note: This value is not valid for LPCPI)</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VSYNC_POL</name>
              <description>Set camera VSYNC polarity.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Not invert VSYNC input</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Invert VSYNC input</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HSYNC_POL</name>
              <description>Set camera HSYNC polarity.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Not invert HSYNC input</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Invert HSYNC input</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PCLK_POL</name>
              <description>Set camera PIXEL_CLK polarity.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Not invert external camera PIXEL_CLK</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Invert external camera PIXEL_CLK</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ROW_ROUNDUP</name>
              <description>Round up pixel data to 64-bit at the end of each row.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Not round up</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Round up pixel data to 64-bit at the end of each row</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VSYNC_EN</name>
              <description>Capture data when VSYNC is high.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Capture data regardless of VSYNC status</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Capture data when VSYNC is high</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_VSYNC</name>
              <description>Capture video frame on the rising edge of VSYNC.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Start video capture without waiting for VSYNC</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Start video capture on rising edge of VSYNC</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ISP_PORT_EN</name>
              <description>Enable CSI/Camera to ISP port.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Disable ISP port</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Enable ISP port</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AXI_PORT_EN</name>
              <description>Enable CSI/Camera to AXI port.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Disable AXI port</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Enable AXI port</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CSI_HALT_EN</name>
              <description>Enable MIPI CSI controller halt function when FIFO is almost full.
Note: This register field is not functional for LPCPI.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Disable CSI IPI halt function</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Enable CSI IPI halt function </description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MIPI_CSI</name>
              <description>Select video data source.
Note: This register field is not functional for LPCPI.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Select video data from parallel camera interface</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Select video data from MIPI CSI interface</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CAM_FIFO_CTRL</name>
          <description>Camera FIFO Control Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00001808</resetValue>
          <resetMask>0x00001F1F</resetMask>
          <fields>
            <field>
              <name>WR_WMARK</name>
              <description>FIFO write watermark.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RD_WMARK</name>
              <description>FIFO read watermark.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAM_AXI_ERR_STAT</name>
          <description>Camera AXI Error Status Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FF03</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>AXI bus BRESP error counter.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BRESP</name>
              <description>AXI bus BRESP error code.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAM_VIDEO_HCFG</name>
          <description>Camera Video Horizontal Configure Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xBFFF3FFF</resetMask>
          <fields>
            <field>
              <name>HFP_ENA</name>
              <description>Enable horizontal cropping.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HFP</name>
              <description>Horizontal Front Porch.</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HBP</name>
              <description>Horizontal Back Porch.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAM_VIDEO_VCFG</name>
          <description>Camera Video Vertical Configure Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8FFF0FFF</resetMask>
          <fields>
            <field>
              <name>HFP_ENA</name>
              <description>Enable vertical cropping.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VFP</name>
              <description>Vertical Front Porch.</description>
              <bitRange>[27:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VBP</name>
              <description>Vertical Back Porch.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAM_VIDEO_FCFG</name>
          <description>Camera Video Frame Configuration Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0FFF3FFF</resetMask>
          <fields>
            <field>
              <name>ROW</name>
              <description>Valid data rows in a frame.</description>
              <bitRange>[27:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA</name>
              <description>Valid data in a row.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAM_CSI_CMCFG</name>
          <description>Camera MIPI CSI Color Mode Configuration Register</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>MODE</name>
              <description>Color encoding for MIPI CSI IPI interface.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>IPI-16 RAW6</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>IPI-16 RAW7</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>IPI-16 RAW8</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>IPI-16 RAW10</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>IPI-16 RAW12</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>IPI-16 RAW14</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>IPI-16 RAW16</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>IPI-48 RGB444</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>IPI-48 RGB555</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>IPI-48 RGB565</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>IPI-48 RGB666</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>IPI-48 XRGB888</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>IPI-48 RGBX888</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x10</name>
                  <description>IPI-16 RGB444</description>
                  <value>0x10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x11</name>
                  <description>IPI-16 RGB555</description>
                  <value>0x11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x12</name>
                  <description>IPI-16 RGB565</description>
                  <value>0x12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x13</name>
                  <description>IPI-16 RGB666</description>
                  <value>0x13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x14</name>
                  <description>IPI-16 XRGB888</description>
                  <value>0x14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x15</name>
                  <description>IPI-16 RGBX888</description>
                  <value>0x15</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x16</name>
                  <description>IPI-48 RAW6</description>
                  <value>0x16</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x17</name>
                  <description>IPI-48 RAW7</description>
                  <value>0x17</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x18</name>
                  <description>IPI-48 RAW8</description>
                  <value>0x18</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x19</name>
                  <description>IPI-48 RAW10</description>
                  <value>0x19</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1A</name>
                  <description>IPI-48 RAW12</description>
                  <value>0x1A</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CAM_FRAME_ADDR</name>
          <description>Camera Video Frame Start Address Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF9</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Video frame start address.</description>
              <bitRange>[31:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STREAMING</name>
              <description>Video frame streaming enable.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Disabled. Automatic increment of address for sequential frames.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Enabled. Save sequential frames in same address range.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CAM_FRAME_ADDRB</name>
          <description>Camera Sequential Video Frame Start Address B Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF8</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Video frame start address.</description>
              <bitRange>[31:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAM_FRAME_ADDRC</name>
          <description>Camera Sequential Video Frame Start Address C Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF8</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Video frame start address.</description>
              <bitRange>[31:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAM_FRAME_ADDRD</name>
          <description>Camera Sequential Video Frame Start Address D Register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF8</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Video frame start address.</description>
              <bitRange>[31:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAM_AXI_STREAM_CTRL</name>
          <description>Camera AXI Stream Control Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2401FF18</resetValue>
          <resetMask>0x7FFFFFFF</resetMask>
          <fields>
            <field>
              <name>BOUNDARY_INDEX</name>
              <description>Next awaddr boundary index.</description>
              <bitRange>[30:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BOUNDARY_REMAINDER</name>
              <description>How many beats to boundary.</description>
              <bitRange>[25:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AWLEN_CALC_EN</name>
              <description>AXI boundary index calculator enable. </description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Disabled</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Enabled</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWCACHE</name>
              <description>AWCACHE vector.</description>
              <bitRange>[6:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FCNT</name>
              <description>Stream address counter status (CDC crossing, quasi-static).</description>
              <bitRange>[2:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Frame address</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Frame address B</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_2</name>
                  <description>Frame address C</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_3</name>
                  <description>Frame address D</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WSTROBE_EN</name>
              <description>Enable AXI bus write strobe.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Disabled</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Enabled</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="LPSPI0">
      <name>LPSPI1</name>
      <baseAddress>0x43004000</baseAddress>
    </peripheral>
    <peripheral>
      <name>LPI2C1</name>
      <groupName>I2C</groupName>
      <baseAddress>0x43005000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>256</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>I2C_CON</name>
          <description>Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000007F</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUS_CLEAR_FEATURE_CTRL</name>
              <description>In master mode:
In slave mode, this bit is not applicable.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Bus clear feature is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description> Bus clear feature is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STOP_DET_IF_MASTER_ACTIVE</name>
              <description>In master mode, this bit controls whether the I2C issues the STOP_DET interrupt only when master is active or always.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Master issues the STOP_DET interrupt regardless of whether it is active or not.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Master issues the STOP_DET interrupt only when active.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RX_FIFO_FULL_HLD_CTRL</name>
              <description>This bit controls whether the I2C holds the bus when the Rx FIFO is completely full (until data is read out and there is space available in the buffer), or if the Rx FIFO overflows.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Overflow when RX_FIFO is full</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Hold bus when RX_FIFO is full</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TX_EMPTY_CTRL</name>
              <description>This bit controls the generation of the TX_EMPTY interrupt, as described in the I2C_RAW_INTR_STAT[TX_EMPTY] bit field.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Default behaviour of TX_EMPTY interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Controlled generation of TX_EMPTY interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STOP_DET_IFADDRESSED</name>
              <description>In slave mode, this bit controls whether the I2C issues the STOP_DET
interrupt only when slave is addressed or always.
Note: During a General Call address, the I2C slave does not issue the STOP_DET interrupt if STOP_DET_IFADDRESSED = 1, even if the I2C slave responds to the General Call address by generating an ACK. The STOP_DET interrupt is issued only when the transmitted address matches the I2C slave address (I2C_SAR).</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slave issues the STOP_DET interrupt regardless of whether it is addressed or not.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slave issues the STOP_DET interrupt only when addressed.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IC_SLAVE_DISABLE</name>
              <description>This bit controls whether the I2C has its slave mode enabled or disabled. At reset, I2C slave mode is disabled.
Note: Software should ensure that, if this bit is set to 0, then the MASTER_MODE bit is also set to 0 (to ensure proper operation in slave mode).</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slave mode is enabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slave mode is disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IC_RESTART_EN</name>
              <description>Determines whether RESTART conditions may be sent when acting as a master. Some older slaves do not support handling RESTART conditions; however, RESTART conditions are used in several I2C operations. When RESTART is disabled, the master is prohibited from performing the following functions:
- Sending a START BYTE
- Performing any high-speed mode operation
- Performing direction changes in combined format mode
- Performing a read operation with a 10-bit address
By replacing RESTART condition followed by STOP and subsequent START condition, split operations are broken down into multiple I2C transfers. If the above operations are performed, it will result in asserting the I2C_RAW_INTR_STAT[TX_ABRT] bit.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Master restart disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Master restart enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IC_10BITADDR_MASTER_RD_ONLY</name>
              <description>The function of this bit is handled by the I2C_TAR[IC_10BITADDR_MASTER] bit, so this bit is just read-only copy.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>7-bit master addressing mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>10-bit master addressing mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IC_10BITADDR_SLAVE</name>
              <description>When acting as a slave, this bit controls whether the I2C responds to 7-bit or 10-bit addresses.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>7-bit slave addressing mode. The I2C ignores transactions that involve 10-bit addressing; only the lower 7 bits of I2C_SAR register are compared.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>10-bit slave addressing mode. The I2C responds only to 10-bit addressing transfers that match the full 10 bits of I2C_SAR register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPEED</name>
              <description>These bits control at which speed the I2C operates; its setting is relevant only if the I2C operates in Master mode. Hardware protects against illegal values being programmed by software. These bits must be programmed appropriately for Slave mode also, as they are used to capture correct value of spike filter as per the speed mode.
This register should be programmed only with a value in the range of 1 to 3.</description>
              <bitRange>[2:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Standard mode of operation</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Fast or Fast Plus mode of operation</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>High-speed mode of operation</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MASTER_MODE</name>
              <description>This bit controls whether the I2C has its master mode enabled or disabled. At reset, I2C master mode is enabled.
Note: Software should ensure that, if this bit is set to 1, then the IC_SLAVE_DISABLE bit is also set to 1 (to ensure proper operation in master mode).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Master mode is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Master mode is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_TAR</name>
          <description>Target Address Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00001055</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DEVICE_ID</name>
              <description>If bit [11] SPECIAL = 1, then this bit controls whether a Device-ID transfer of a particular slave targeted in the [9-0] IC_TAR field is to be performed by the I2C master.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disables programming of Device-ID transmission. A Device-ID transfer is not performed and I2C checks bit [10] GC_OR_START to perform either a General Call, or a START BYTE command.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables programming of Device-ID transmission. A Device-ID transfer is performed and data bytes based on the number of read commands in the Tx FIFO are received from the targeted slave and put in the Rx FIFO.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IC_10BITADDR_MASTER</name>
              <description>This bit controls whether the I2C starts its transfers in 7-bit or 10-bit addressing mode, when acting as a master.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>7-bit master addressing mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>10-bit master addressing mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPECIAL</name>
              <description>This bit controls whether software performs a special command: Device-ID, or General Call, or START BYTE.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disables programming of special I2C command. I2C ignores bit [13] DEVICE_ID and bit [10] GC_OR_START and uses the [9-0] IC_TAR field normally.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables programming of special I2C command. I2C performs a special command as specified in bit [13] DEVICE_ID or bit [10] GC_OR_START.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GC_OR_START</name>
              <description>If bit [11] SPECIAL = 1 and bit [13] DEVICE_ID = 0, then this bit controls whether I2C performs a General Call or a START BYTE command.
Note: After issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting I2C_RAW_INTR_STAT[TX_ABRT] bit. The I2C remains in General Call mode until the SPECIAL bit value is cleared.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>General Call transmission</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>START BYTE transmission</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IC_TAR</name>
              <description>This is the target address for any I2C master transaction. When transmitting a General Call, these bits are ignored. To generate a START BYTE command, the CPU needs to write into these bits only once.
If I2C_TAR[IC_TAR] and I2C_SAR[IC_SAR] are the same, loopback exists but the FIFOs are shared between master and slave, so full loopback is not feasible. Only one direction loopback mode is supported (simplex); duplex is not supported. A master cannot transmit to itself; it can only transmit to a slave.
Note: The correct operation of the I2C interface is not guaranteed if this field is programmed to any of the reserved values listed in Table 1-7.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_SAR</name>
          <description>Slave Address Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000055</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IC_SAR</name>
              <description>This register holds the slave address when the I2C is operating as a slave. For 7-bit addressing, only bits [6-0] are used.
This register can only be written when the I2C module is disabled, which corresponds to the I2C_ENABLE[ENABLE] bit being set to 0. Writes at other times have no effect.
Note: The correct operation of the I2C interface is not guaranteed if this field is programmed to any of the reserved values listed in Table 1-7.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_HS_MADDR</name>
          <description>High Speed Master Mode Code Address Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IC_HS_MAR</name>
              <description>This bit field holds the value of the I2C HS mode master
code. HS mode master codes are reserved 8-bit codes
(00001xxx) that are not used for slave addressing or other
purposes. Each master has its unique master code; up to
eight high-speed mode masters can be present on the same
I^2C bus system. Valid values are 0-7.
This register can only be written when the I2C module is
disabled, which corresponds to the I2C_ENABLE[ENABLE] bit being set to 0. Writes at other times have no effect.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_DATA_CMD</name>
          <description>Rx/Tx Data Buffer and Command Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMD</name>
              <description>This bit controls whether a read or a write is performed. This bit does not control the direction of data transfer when I2C acts as a slave; it controls the direction only when I2C acts as a master.
When a command is entered in the Tx FIFO, this bit distinguishes the write and read commands. In the slave-receiver mode, this bit is a 'don't care' because writes to this register are not required. In the slave-transmitter mode, a 0 in this bit indicates that the data in the [7-0] DAT field is to be transmitted.
 When programming this bit, consider the following:
- Attempting to perform a read operation after sending a General Call command results in the TX_ABRT interrupt (I2C_RAW_INTR_STAT[TX_ABRT] bit) being asserted, unless the I2C_TAR[SPECIAL] bit has been cleared;
- If a 1 is written to this bit after receiving RD_REQ interrupt, then TX_ABRT interrupt occurs.</description>
              <bitRange>[8:8]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Master write command</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Master read command</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DAT</name>
              <description>This field contains the data to be transmitted or received on the I2C interface.
If this field is written while bit [8] CMD = 1, it is ignored by the I2C. If this field is read while bit [8] CMD = 1, it returns the value of the data received on the I2C interface.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_SS_SCL_HCNT</name>
          <description>Standard Speed SCL High Count Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000190</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IC_SS_SCL_HCNT</name>
              <description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. It sets the SCL clock high period count for standard speed.
This register can only be written when the I2C module is disabled, which corresponds to the I2C_ENABLE[ENABLE] bit being set to 0. Writes at other times have no effect.
The minimum valid value is 6; hardware prevents values less than this being written, and if attempted, results in 6 being set.
Note: This register must not be programmed to a value higher than 65525, because I2C uses a 16-bit counter to flag an I^2C bus IDLE condition when this counter reaches a value of I2C_SS_SCL_HCNT + 10.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_SS_SCL_LCNT</name>
          <description>Standard Speed SCL Low Count Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x000001D6</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IC_SS_SCL_LCNT</name>
              <description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for standard speed. 
This register can only be written when the I2C module is disabled, which corresponds to the I2C_ENABLE[ENABLE] bit being set to 0. Writes at other times have no effect.
The minimum valid value is 8; hardware prevents values less than this being written, and if attempted, results in 8 being set.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_FS_SCL_HCNT</name>
          <description>Fast Speed or Fast Mode Plus SCL High Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000003C</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IC_FS_SCL_HCNT</name>
              <description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high period count for fast speed or fast mode plus.
This register can only be written when the I2C module is disabled, which corresponds to the I2C_ENABLE[ENABLE] bit being set to 0. Writes at other times have no effect.
The minimum valid value is 6; hardware prevents values less than this being written, and if attempted, results in 6 being set.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_FS_SCL_LCNT</name>
          <description>Fast Speed or Fast Mode Plus SCL Low Count Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000082</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IC_FS_SCL_LCNT</name>
              <description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for fast speed or fast mode plus.
This register can only be written when the I2C module is disabled, which corresponds to the I2C_ENABLE[ENABLE] bit being set to 0. Writes at other times have no effect.
The minimum valid value is 8; hardware prevents values less than this being written, and if attempted, results in 8 being set.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_HS_SCL_HCNT</name>
          <description>High Speed SCL High Count Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000006</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IC_HS_SCL_HCNT</name>
              <description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high period count for high speed. 
The SCL high time depends on the loading of the bus. For
100 pF loading, the SCL high time is 60 ns.
This register can only be written when the I2C module is disabled, which corresponds to the I2C_ENABLE[ENABLE] bit being set to 0. Writes at other times have no effect.
The minimum valid value is 6; hardware prevents values less than this being written, and if attempted, results in 6 being set.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_HS_SCL_LCNT</name>
          <description>High Speed SCL Low Count Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IC_HS_SCL_LCNT</name>
              <description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for high speed.
The SCL low time depends on the loading of the bus. For
100 pF loading, the SCL low time is 160 ns.
This register can only be written when the I2C module is disabled, which corresponds to the I2C_ENABLE[ENABLE] bit being set to 0. Writes at other times have no effect.
The minimum valid value is 8; hardware prevents values less than this being written, and if attempted, results in 8 being set.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_INTR_STAT</name>
          <description>Interrupt Status Register</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>R_SCL_STUCK_AT_LOW</name>
              <description>For details, see I2C_RAW_INTR_STAT[SCL_STUCK_AT_LOW].</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>R_SCL_STUCK_AT_LOW interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>R_SCL_STUCK_AT_LOW interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R_MASTER_ON_HOLD</name>
              <description>For details, see I2C_RAW_INTR_STAT[MASTER_ON_HOLD].
Note: This interrupt cannot be asserted in this device.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>R_MASTER_ON_HOLD interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>R_MASTER_ON_HOLD interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R_RESTART_DET</name>
              <description>For details, see I2C_RAW_INTR_STAT[RESTART_DET].
Note: This interrupt cannot be asserted in this device.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>R_RESTART_DET interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>R_RESTART_DET interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R_GEN_CALL</name>
              <description>For details, see I2C_RAW_INTR_STAT[GEN_CALL].</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>R_GEN_CALL interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>R_GEN_CALL interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R_START_DET</name>
              <description>For details, see I2C_RAW_INTR_STAT[START_DET].</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>R_START_DET interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>R_START_DET interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R_STOP_DET</name>
              <description>For details, see I2C_RAW_INTR_STAT[STOP_DET].</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>R_STOP_DET interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>R_STOP_DET interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R_ACTIVITY</name>
              <description>For details, see I2C_RAW_INTR_STAT[ACTIVITY].</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>R_ACTIVITY interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>R_ACTIVITY interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R_RX_DONE</name>
              <description>For details, see I2C_RAW_INTR_STAT[RX_DONE].</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>R_RX_DONE interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>R_RX_DONE interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R_TX_ABRT</name>
              <description>For details, see I2C_RAW_INTR_STAT[TX_ABRT].</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>R_TX_ABRT interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>R_TX_ABRT interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R_RD_REQ</name>
              <description>For details, see I2C_RAW_INTR_STAT[RD_REQ].</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>R_RD_REQ interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>R_RD_REQ interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R_TX_EMPTY</name>
              <description>For details, see I2C_RAW_INTR_STAT[TX_EMPTY].</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>R_TX_EMPTY interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>R_TX_EMPTY interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R_TX_OVER</name>
              <description>For details, see I2C_RAW_INTR_STAT[TX_OVER].</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>R_TX_OVER interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>R_TX_OVER interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R_RX_FULL</name>
              <description>For details, see I2C_RAW_INTR_STAT[RX_FULL].</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>R_RX_FULL interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>R_RX_FULL interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R_RX_OVER</name>
              <description>For details, see I2C_RAW_INTR_STAT[RX_OVER].</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>R_RX_OVER interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>R_RX_OVER interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R_RX_UNDER</name>
              <description>For details, see I2C_RAW_INTR_STAT[RX_UNDER].</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>R_RX_UNDER interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>R_RX_UNDER interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_INTR_MASK</name>
          <description>Interrupt Mask Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x000048FF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>M_SCL_STUCK_AT_LOW</name>
              <description>Masks the I2C_INTR_STAT[R_SCL_STUCK_AT_LOW] bit.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SCL_STUCK_AT_LOW interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SCL_STUCK_AT_LOW interrupt is unmasked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M_MASTER_ON_HOLD_READ_ONLY</name>
              <description>Masks the I2C_INTR_STAT[R_MASTER_ON_HOLD] bit.
Note: This interrupt cannot be enabled in this device.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MASTER_ON_HOLD interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MASTER_ON_HOLD interrupt is unmasked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M_RESTART_DET_READ_ONLY</name>
              <description>Masks the I2C_INTR_STAT[R_RESTART_DET] bit.
Note: This interrupt cannot be enabled in this device.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RESTART_DET interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RESTART_DET interrupt is unmasked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M_GEN_CALL</name>
              <description>Masks the I2C_INTR_STAT[R_GEN_CALL] bit.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>GEN_CALL interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>GEN_CALL interrupt is unmasked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M_START_DET</name>
              <description>Masks the I2C_INTR_STAT[R_START_DET] bit.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>START_DET interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>START_DET interrupt is unmasked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M_STOP_DET</name>
              <description>Masks the I2C_INTR_STAT[R_STOP_DET] bit.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>STOP_DET interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>STOP_DET interrupt is unmasked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M_ACTIVITY</name>
              <description>Masks the I2C_INTR_STAT[R_ACTIVITY] bit.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>ACTIVITY interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ACTIVITY interrupt is unmasked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M_RX_DONE</name>
              <description>Masks the I2C_INTR_STAT[R_RX_DONE] bit.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RX_DONE interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RX_DONE interrupt is unmasked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M_TX_ABRT</name>
              <description>Masks the I2C_INTR_STAT[R_TX_ABRT] bit.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>TX_ABRT interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>TX_ABRT interrupt is unmasked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M_RD_REQ</name>
              <description>Masks the I2C_INTR_STAT[R_RD_REQ] bit.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RD_REQ interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RD_REQ interrupt is unmasked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M_TX_EMPTY</name>
              <description>Masks the I2C_INTR_STAT[R_TX_EMPTY] bit.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>TX_EMPTY interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>TX_EMPTY interrupt is unmasked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M_TX_OVER</name>
              <description>Masks the I2C_INTR_STAT [R_TX_OVER] bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>TX_OVER interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>TX_OVER interrupt is unmasked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M_RX_FULL</name>
              <description>Masks the I2C_INTR_STAT[R_RX_FULL] bit.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RX_FULL interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RX_FULL interrupt is unmasked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M_RX_OVER</name>
              <description>Masks the I2C_INTR_STAT[R_RX_OVER] bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RX_OVER interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RX_OVER interrupt is unmasked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M_RX_UNDER</name>
              <description>Masks the I2C_INTR_STAT[R_RX_UNDER] bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RX_UNDER interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RX_UNDER interrupt is unmasked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_RAW_INTR_STAT</name>
          <description>Raw Interrupt Status Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCL_STUCK_AT_LOW</name>
              <description>Indicates whether the SCL line is stuck at low for I2C_SCL_STUCK_AT_LOW_TIMEOUT number of IC_CLK periods.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SCL_STUCK_AT_LOW interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SCL_STUCK_AT_LOW interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MASTER_ON_HOLD</name>
              <description>Indicates whether master is holding the bus and Tx FIFO is empty.
Note: This interrupt cannot be set in this device.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MASTER_ON_HOLD interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MASTER_ON_HOLD interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESTART_DET</name>
              <description>Indicates whether a RESTART condition has occurred on the I^2C interface when I2C is operating in slave mode and the slave is being addressed.
Note: This interrupt cannot be set in this device.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RESTART_DET interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RESTART_DET interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GEN_CALL</name>
              <description>This bit is set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling I2C or when the CPU reads bit 0 of the I2C_CLR_GEN_CALL register. The I2C stores the received data in the Rx FIFO.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>GEN_CALL interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>GEN_CALL interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>START_DET</name>
              <description>Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether I2C is operating in slave or master mode.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>START_DET interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>START_DET interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STOP_DET</name>
              <description>Indicates whether a STOP condition has occurred on the I^2C interface regardless of whether I2C is operating in slave or master mode.
In slave mode:
- If I2C_CON[STOP_DET_IFADDRESSED] = 0, this interrupt is issued regardless of whether the I2C slave is addressed or not.
- If I2C_CON[STOP_DET_IFADDRESSED] = 1, this interrupt is issued only if the I2C slave is addressed.
Note: During a General Call address, the I2C slave does not issue the STOP_DET interrupt if STOP_DET_IFADDRESSED = 1, even if the I2C slave responds to the General Call address by generating an ACK. The STOP_DET interrupt is issued only when the transmitted address matches the I2C slave address (I2C_SAR).
In master mode:
- If I2C_CON[STOP_DET_IF_MASTER_ACTIVE] = 0, this interrupt is issued regardless of whether the I2C master is active or not.
- If I2C_CON[STOP_DET_IF_MASTER_ACTIVE] = 1, this interrupt is issued only if the I2C master is active.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>STOP_DET interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>STOP_DET interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ACTIVITY</name>
              <description>This bit captures I2C activity and stays set until it is cleared. There are four ways to clear it:
- Disabling the I2C
- Reading the I2C_CLR_ACTIVITY register
- Reading the I2C_CLR_INTR register
- System reset
Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the I2C module is idle, this bit remains set until cleared, indicating that there was activity on the bus.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RAW_INTR_ACTIVITY interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RAW_INTR_ACTIVITY interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RX_DONE</name>
              <description>When the I2C is acting as a slave-transmitter, this bit is set to 1 if the remote master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RX_DONE interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RX_DONE interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TX_ABRT</name>
              <description>This bit indicates if the I2C, acting as a transmitter on the I^2C bus, is unable to complete the intended actions on the contents of the Tx FIFO. This situation can occur both as an I^2C master or an I^2C slave, and is referred to as a transmit abort. When this bit is set to 1, the I2C_TX_ABRT_SOURCE register indicates the reason why the transmit abort has occured.
The I2C flushes/resets/empties both the Tx FIFO and the Rx FIFO whenever there is a transmit abort caused by any of the events tracked by the I2C_TX_ABRT_SOURCE register. The FIFOs remain in this flushed state until the I2C_CLR_TX_ABRT register is read. Once this read is performed, the FIFOs are ready to accept more data bytes.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>TX_ABRT interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>TX_ABRT interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RD_REQ</name>
              <description>This bit is set to 1 when the I2C is acting as a slave and another I^2C master is attempting to read data from I2C. The I2C holds the bus in a wait state until this interrupt is serviced, which means that the slave has been addressed by a remote master asking for data to be transferred. CPU must respond to this interrupt and then write the requested data to the I2C_DATA_CMD register. This bit is cleared just after the CPU reads the I2C_CLR_RD_REQ register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RD_REQ interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RD_REQ interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>The behavior of the TX_EMPTY interrupt status differs based on the selection in the I2C_CON[TX_EMPTY_CTRL] bit.
When I2C_CON[TX_EMPTY_CTRL] = 0:
This bit is set to 1 when the transmit FIFO buffer is at or below the threshold value set in the I2C_TX_TL register.
When I2C_CON[TX_EMPTY_CTRL] = 1:
This bit is set to 1 when the transmit FIFO buffer is at or below the threshold value set in the I2C_TX_TL register and the transmission of the address/data from the internal shift register for the most recently popped command is completed.
This bit is automatically cleared by hardware when the transmit buffer level goes above the threshold. If the module is disabled (I2C_ENABLE[ENABLE] = 0), the Tx FIFO is flushed and held in reset; therefore, the Tx FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer any activity and I2C_ENABLE_STATUS[IC_EN] goes to 0, this bit is cleared.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>TX_EMPTY interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>TX_EMPTY interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TX_OVER</name>
              <description>Set during transmit if the transmit buffer is completely full and the processor attempts to issue another I2C command by writing to the I2C_DATA_CMD register.
If the module is disabled (I2C_ENABLE[ENABLE] = 0), this bit keeps its level until the master or slave state machines go into IDLE, and when the I2C_ENABLE_STATUS[IC_EN] bit goes to 0, this interrupt is cleared.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>TX_OVER interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>TX_OVER interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Set when the receive buffer reaches or goes above the threshold level in the I2C_RX_TL register. This bit is automatically cleared by hardware when the receive buffer level goes below the threshold.
If the module is disabled (I2C_ENABLE[ENABLE] = 0), the Rx FIFO is flushed and held in reset; therefore, the Rx FIFO is not full. So, this bit is cleared once the I2C_ENABLE[ENABLE] bit is programmed to 0, regardless of the activity that continues.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RX_FULL interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RX_FULL interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RX_OVER</name>
              <description>Set if the receive buffer is completely full and an additional byte is received from an external I^2C device. The I2C acknowledges this, but any data bytes received after the Rx FIFO is full are lost.
If the module is disabled (I2C_ENABLE[ENABLE] = 0), this bit keeps its level until the master or slave state machines go into IDLE, and when the I2C_ENABLE_STATUS[IC_EN] bit goes to 0, this interrupt is cleared.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RX_OVER interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RX_OVER interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RX_UNDER</name>
              <description>Set if the processor attempts to read the receive buffer when it is empty by reading from the I2C_DATA_CMD register.
If the module is disabled (I2C_ENABLE[ENABLE] = 0), this bit keeps its level until the master or slave state machines go into IDLE, and when the I2C_ENABLE_STATUS[IC_EN] bit goes to 0, this interrupt is cleared.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RX_UNDER interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RX_UNDER interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_RX_TL</name>
          <description>Receive FIFO Threshold Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_TL</name>
              <description>Controls the level of entries (or above) that triggers the RX_FULL interrupt (I2C_RAW_INTR_STAT[RX_FULL] bit). Valid range is 0-31 (Rx FIFO depth = 32). Hardware does not allow this field to be set to a value larger than the depth of the buffer; any attempt to do so results in a value of 31 being set. A value of 0 sets the threshold for 1 entry, and a value of 31 sets the threshold for 32 entries.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_TX_TL</name>
          <description>Transmit FIFO Threshold Register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_TL</name>
              <description>Controls the level of entries (or below) that triggers the TX_EMPTY interrupt (I2C_RAW_INTR_STAT[TX_EMPTY]). Valid range is 0-31 (Tx FIFO depth = 32). Hardware does not allow this field to be set to a value larger than the depth of the buffer; any attempt to do so results in a value of 31 being set. A value of 0 sets the threshold for 0 entries, and a value of 31 sets the threshold for 31 entries.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CLR_INTR</name>
          <description>Clear Combined and Individual Interrupt Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLR_INTR</name>
              <description>Read this bit to:
 - Clear the combined interrupt;
- Clear all individual interrupts;
- Clear the I2C_TX_ABRT_SOURCE register;
This bit does not clear hardware clearable interrupts but software clearable interrupts. Refer to I2C_TX_ABRT_SOURCE[ABRT_SBYTE_NORSTRT] bit for an exception to clearing it.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CLR_RX_UNDER</name>
          <description>Clear RX_UNDER Interrupt Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLR_RX_UNDER</name>
              <description>Read this bit to clear the I2C_RAW_INTR_STAT[RX_UNDER] bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CLR_RX_OVER</name>
          <description>Clear RX_OVER Interrupt Register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLR_RX_OVER</name>
              <description>Read this bit to clear the I2C_RAW_INTR_STAT[RX_OVER] bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CLR_TX_OVER</name>
          <description>Clear TX_OVER Interrupt Register</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLR_TX_OVER</name>
              <description>Read this bit to clear the I2C_RAW_INTR_STAT[TX_OVER] bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CLR_RD_REQ</name>
          <description>Clear RD_REQ Interrupt Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLR_RD_REQ</name>
              <description>Read this bit to clear the I2C_RAW_INTR_STAT[RD_REQ] bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CLR_TX_ABRT</name>
          <description>Clear TX_ABRT Interrupt Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLR_TX_ABRT</name>
              <description>Read this bit to clear the I2C_RAW_INTR_STAT[TX_ABRT] bit, and the I2C_TX_ABRT_SOURCE register. This also releases the Tx FIFO from the flushed/reset state, allowing more writes to the Tx FIFO. Refer to I2C_TX_ABRT_SOURCE[ABRT_SBYTE_NORSTRT] bit for an exception to clearing it.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CLR_RX_DONE</name>
          <description>Clear RX_DONE Interrupt Register</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLR_RX_DONE</name>
              <description>Read this bit to clear the I2C_RAW_INTR_STAT[RX_DONE] bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CLR_ACTIVITY</name>
          <description>Clear ACTIVITY Interrupt Register</description>
          <addressOffset>0x5C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLR_ACTIVITY</name>
              <description>Reading this bit clears the ACTIVITY interrupt if the I2C is not active anymore. If the I2C is still active on the bus, the ACTIVITY interrupt bit continues to be set. It is automatically cleared by hardware if the I2C is disabled and if there is no further activity on the bus.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CLR_STOP_DET</name>
          <description>Clear STOP_DET Interrupt Register</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLR_STOP_DET</name>
              <description>Read this bit to clear the I2C_RAW_INTR_STAT[STOP_DET] bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CLR_START_DET</name>
          <description>Clear START_DET Interrupt Register</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLR_START_DET</name>
              <description>Read this bit to clear the I2C_RAW_INTR_STAT[START_DET] bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CLR_GEN_CALL</name>
          <description>Clear GEN_CALL Interrupt Register</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLR_GEN_CALL</name>
              <description>Read this bit to clear the I2C_RAW_INTR_STAT[GEN_CALL] bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_ENABLE</name>
          <description>Enable Register</description>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SDA_STUCK_RECOVERY_ENABLE</name>
              <description>If SDA is stuck at low, as indicated through the TX_ABRT interrupt (I2C_TX_ABRT_SOURCE[ABRT_SDA_STUCK_AT_LOW] bit asserted), then this bit is used as a control knob to initiate the SDA recovery mechanism (that is, send at most 9 SCL clocks and STOP to release the SDA line), and then this bit gets auto cleared.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Master disables the SDA stuck at low recovery mechanism</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Master initiates the SDA stuck at low recovery mechanism</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABORT</name>
              <description>When set, the controller initiates the transfer abort.
Software can abort the I2C transfer in master mode by setting this bit. Software can set this bit only when the ENABLE bit is already set; otherwise, the controller ignores any write to the ABORT bit. Software cannot clear the ABORT bit once set. In response to an ABORT, the controller issues a STOP and flushes the Tx FIFO after completing the current transfer, then sets the TX_ABRT interrupt after the abort operation. The ABORT bit is cleared automatically after the abort operation.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>ABORT operation not in progress</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ABORT operation in progress</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Controls whether the I2C module is enabled or disabled. 
Software can disable the I2C module while it is active. However, it is important that care be taken to ensure that the I2C module is disabled properly. A recommended procedure is described in Section Disabling the I2C.
When I2C is disabled, the following occurs:
 - Tx FIFO and Rx FIFO get flushed;
- I2C_INTR_STAT status bits are still active until I2C goes IDLE; 
If the I2C is transmitting, it stops as well as deletes the
contents of the transmit buffer after the current transfer is
complete. If the I2C is receiving, it stops
the current transfer at the end and
does not acknowledge the transfer.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disables I2C</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables I2C</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_STATUS</name>
          <description>Status Register</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000006</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SDA_STUCK_NOT_RECOVERED</name>
              <description>This bit indicates that SDA stuck at low is not recovered after the SDA recovery mechanism. In slave mode, this bit is not applicable.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SDA stuck at low is recovered after recovery mechanism</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SDA stuck at low is not recovered after recovery mechanism</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLV_ACTIVITY</name>
              <description>Slave FSM Activity Status.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slave FSM is in IDLE state (slave is not active)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slave FSM is not in IDLE state (slave is active)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MST_ACTIVITY</name>
              <description>Master FSM Activity Status.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Master FSM is in IDLE state (master is not active)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Master FSM is not in IDLE state (master is active)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFF</name>
              <description>Receive FIFO Completely Full.
When the Rx FIFO is completely full, this bit is set. When the Rx FIFO contains one or more empty locations, this bit is cleared.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Rx FIFO not full</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Rx FIFO is full</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFNE</name>
              <description>Receive FIFO Not Empty.
When the Rx FIFO contains one or more valid entries, this bit is set. When the Rx FIFO is empty, this bit is cleared.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Rx FIFO is empty</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Rx FIFO not empty</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TFE</name>
              <description>Transmit FIFO Completely Empty.
When the Tx FIFO is completely empty, this bit is set. When the Tx FIFO contains one or more valid entries, this bit is cleared.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Tx FIFO not empty</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Tx FIFO is empty</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TFNF</name>
              <description>Transmit FIFO Not Full.
When the Tx FIFO contains one or more empty locations, this bit is set. When the Tx FIFO is full, this bit is cleared.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Tx FIFO is full</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Tx FIFO not full</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ACTIVITY</name>
              <description>I2C Activity Status.
This bit is an OR of bit [5] MST_ACTIVITY and bit [6] SLV_ACTIVITY.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>I2C is IDLE</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>I2C is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_TXFLR</name>
          <description>Transmit FIFO Level Register</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXFLR</name>
              <description>Tx FIFO Level.
Contains the number of valid data entries in the Tx FIFO.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_RXFLR</name>
          <description>Receive FIFO Level Register</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXFLR</name>
              <description>Rx FIFO Level.
Contains the number of valid data entries in the Rx FIFO.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_SDA_HOLD</name>
          <description>SDA Hold Time Length Register</description>
          <addressOffset>0x7C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IC_SDA_RX_HOLD</name>
              <description>Sets the required SDA hold time in units of IC_CLK period, when I2C acts as a receiver.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IC_SDA_TX_HOLD</name>
              <description>Sets the required SDA hold time in units of IC_CLK period, when I2C acts as a transmitter.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_TX_ABRT_SOURCE</name>
          <description>Transmit Abort Source Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_FLUSH_CNT</name>
              <description>This bit is applicable in both master and slave mode.
This field indicates the number of Tx FIFO data commands which are flushed due to TX_ABRT interrupt. It is cleared whenever I2C is disabled.
Role of I2C: Master-Transmitter or Slave-Transmitter</description>
              <bitRange>[31:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ABRT_DEVICE_WRITE</name>
              <description>This is a master-mode-only bit.
This field indicates that the master has initiated Device-ID transfer and the Tx FIFO consists of write commands.
Role of I2C: Master</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>This abort is not generated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Device-ID transfer initiated and Tx FIFO with write commands</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_DEVICE_SLVADDR_NOACK</name>
              <description>This is a master-mode-only bit.
This field indicates that the master has initiated Device-ID transfer and the slave address sent was not acknowledged by any slave.
Role of I2C: Master</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>This abort is not generated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slave address not acknowledged by any slave</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_DEVICE_NOACK</name>
              <description>This is a master-mode-only bit.
This field indicates that the master has initiated Device-ID transfer and the Device-ID sent was not acknowledged by any slave.
Role of I2C: Master</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>This abort is not generated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Device-ID not acknowledged by any slave</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_SDA_STUCK_AT_LOW</name>
              <description>This is a master-mode-only bit.
The field indicates that the master has detected the SDA stuck at low for the I2C_SDA_STUCK_AT_LOW_TIMEOUT number of IC_CLK cycles.
Role of I2C: Master</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>This abort is not generated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SDA stuck at low for the I2C_SDA_STUCK_AT_LOW_TIMEOUT number of IC_CLK cycles.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_USER_ABRT</name>
              <description>This is a master-mode-only bit.
This field indicates that the master has detected a transfer abort (initiated by setting I2C_ENABLE[ABORT] = 1).
Role of I2C: Master-Transmitter</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>This abort is not generated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transfer abort detected by master</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_SLVRD_INTX</name>
              <description>This is a slave-mode-only bit.
When the processor side responds to a slave request for data to be transmitted to a remote master and the user writes a 1 in the I2C_DATA_CMD[CMD] bit.
Role of I2C: Slave-Transmitter</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>This abort is not generated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slave trying to transmit to remote master in read mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_SLV_ARBLOST</name>
              <description>This is a slave-mode-only bit.
This field indicates that a slave has lost the bus while transmitting data to a remote master. The ARB_LOST bit in this register is set at the same time.
Note: Even though the slave never 'owns' the bus, something could go wrong on the bus. This is a fail-safe check. For instance, during a data transmission at the low-to-high transition of SCL, if what is on the data bus is not what is supposed to be transmitted, then the I2C no longer 'owns' the bus.
Role of I2C: Slave-Transmitter</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>This abort is not generated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slave lost arbitration to remote master</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_SLVFLUSH_TXFIFO</name>
              <description>This is a slave-mode-only bit.
This field specifies that the slave has received a read command and some data exists in the Tx FIFO, so the slave issues TX_ABRT interrupt to flush old data in the Tx FIFO.
Role of I2C: Slave-Transmitter</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>This abort is not generated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slave flushes existing data in the Tx FIFO upon getting a read command</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ARB_LOST</name>
              <description>This bit is applicable in both master and slave mode.
This field specifies that the master has lost arbitration, or if the ABRT_SLV_ARBLOST bit in this register is also set, then the slave-transmitter has lost arbitration.
Role of I2C: Master-Transmitter or Slave-Transmitter</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>This abort is not generated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Master-transmitter or slave-transmitter lost arbitration</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_MASTER_DIS</name>
              <description>This is a master-mode-only bit.
This field indicates that the user tries to initiate a master
operation with the master mode disabled.
Role of I2C: Master-Transmitter or Master-Receiver
operation when master mode disabled</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>This abort is not generated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>User initiating master</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_10B_RD_NORSTRT</name>
              <description>This is a master-mode-only bit.
This field indicates that the RESTART feature is disabled (I2C_CON[IC_RESTART_EN] = 0) and the master sends a read command in 10-bit addressing mode.
Role of I2C: Master-Receiver</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>This abort is not generated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Master read in 10-bit addressing mode when the RESTART feature is disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_SBYTE_NORSTRT</name>
              <description>This is a master-mode-only bit.
This field indicates that the RESTART feature is disabled
(I2C_CON[IC_RESTART_EN] = 0) and the user is tryingto send a START BYTE.
 To clear the ABRT_SBYTE_NORSTRT bit, the source of this abort must be fixed first:
- Restart must be enabled (I2C_CON[IC_RESTART_EN] = 1);
- I2C_TAR[SPECIAL] bit must be cleared; OR
- I2C_TAR[GC_OR_START] bit must be cleared;
Once the source of the ABRT_SBYTE_NORSTRT abort is fixed, then this bit is cleared in the same manner as other bits in this register. If the source of this abort is not fixed before attempting to clear this bit, the bit clears for one cycle and then gets reasserted.
Role of I2C: Master
trying to send START BYTE when RESTART disabled</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>This abort is not generated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>User</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_HS_NORSTRT</name>
              <description>This is a master-mode-only bit.
This field indicates that the RESTART feature is disabled
(I2C_CON[IC_RESTART_EN] = 0) and the user is tryingto use the master to transfer data in High-Speed mode.
Role of I2C: Master-Transmitter or Master-Receiver
to switch master to HS mode when the RESTART feature is disabled</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>This abort is not generated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>User trying</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_SBYTE_ACKDET</name>
              <description>This is a master-mode-only bit.
This field indicates that the master has sent a START BYTE and the START BYTE was acknowledged (wrong behavior).
Role of I2C: Master</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>This abort is not generated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ACK detected for START BYTE</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_HS_ACKDET</name>
              <description>This is a master-mode-only bit.
This field indicates that the master is in High-Speed mode
and the High-Speed master code was acknowledged (wrong
behavior).
Role of I2C: Master
acknowledged in HS mode</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>This abort is not generated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>HS master code</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_GCALL_READ</name>
              <description>This is a master-mode-only bit.
This field indicates that I2C in master mode has sent a General Call but the user programmed the byte
following the General Call to be a read from the bus (I2C_DATA_CMD[CMD] = 1).
Role of I2C: Master-Transmitter</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>This abort is not generated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>General Call is followed by read from bus</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_GCALL_NOACK</name>
              <description>This is a master-mode-only bit.
This field indicates that I2C in master mode has sent a General Call and no slave on the bus acknowledged the General Call.
Role of I2C: Master-Transmitter</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>This abort is not generated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>General Call not acknowledged by any slave</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_TXDATA_NOACK</name>
              <description>This is a master-mode-only bit.
This field indicates that the master received an acknowledgment for the address, but when the master sent data byte(s) following the address, it did not receive an acknowledgment from remote slave(s).
Role of I2C: Master-Transmitter</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>This abort is not generated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmitted data not acknowledged by addressed slave</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_10ADDR2_NOACK</name>
              <description>This is a master-mode-only bit.
This field indicates that the master is in 10-bit address mode and the second address byte was not acknowledged by any slave.
Role of I2C: Master-Transmitter or Master-Receiver</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>This abort is not generated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Byte 2 of 10-bit address not acknowledged by any slave</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_10ADDR1_NOACK</name>
              <description>This is a master-mode-only bit.
This field indicates that the master is in 10-bit address mode and the first address byte was not acknowledged by any slave.
Role of I2C: Master-Transmitter or Master-Receiver</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>This abort is not generated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Byte 1 of 10-bit address not acknowledged by any slave</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_7B_ADDR_NOACK</name>
              <description>This is a master-mode-only bit.
This field indicates that the master is in 7-bit addressing mode and the address sent was not acknowledged by any slave.
Role of I2C: Master-Transmitter or Master-Receiver</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>This abort is not generated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>7-bit address not acknowledged by any slave</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_DMA_CR</name>
          <description>DMA Control Register</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDMAE</name>
              <description>Transmit DMA Enable.
This bit enables/disables the Tx FIFO DMA channel.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Tx FIFO DMA channel disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Tx FIFO DMA channel enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RDMAE</name>
              <description>Receive DMA Enable.
This bit enables/disables the Rx FIFO DMA channel.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Rx FIFO DMA channel disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Rx FIFO DMA channel enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_DMA_TDLR</name>
          <description>DMA Transmit Data Level Register</description>
          <addressOffset>0x8C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMATDL</name>
              <description>DMA Transmit Data Level.
This bit field controls the level at which a DMA request is made by the transmit logic. It is equal to the watermark level; that is, the DMA_TX_REQ signal is generated when the number of valid data entries in the Tx FIFO is equal to or below this field value, and I2C_DMA_CR[TDMAE] = 1.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_DMA_RDLR</name>
          <description>DMA Receive Data Level Register</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMARDL</name>
              <description>DMA Receive Data Level. 
This bit field controls the level at which a DMA request is made by the receive logic. The watermark level = DMARDL + 1; that is, the DMA_RX_REQ signal is generated when the number of valid data entries in the Rx FIFO is equal to or more than this field value + 1, and I2C_DMA_CR[RDMAE] = 1. For instance, when DMARDL = 0, then DMA_RX_REQ is asserted when one or more data entries are present in the Rx FIFO.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_SDA_SETUP</name>
          <description>SDA Setup Register</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000064</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SDA_SETUP</name>
              <description>SDA Setup
It is recommended that if the required delay is 1000 ns, then for an IC_CLK frequency of 10 MHz, I2C_SDA_SETUP should be programmed to a value of 11. I2C_SDA_SETUP must be programmed with a minimum value of 2.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_ACK_GENERAL_CALL</name>
          <description>ACK General Call Register</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACK_GEN_CALL</name>
              <description>ACK General Call.
When set to 1, I2C responds with a ACK when it receives a General Call. Otherwise, I2C responds with a NACK.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Generates NACK for a General Call</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Generates ACK for a General Call</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_ENABLE_STATUS</name>
          <description>Enable Status Register</description>
          <addressOffset>0x9C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SLV_RX_DATA_LOST</name>
              <description>Slave Received Data Lost.
 This bit indicates if a slave-receiver operation has been aborted with at least one data byte received from an I^2C transfer, due to CPU setting the I2C_ENABLE[ENABLE] bit from 1 to 0.
When read as 0, the I2C is deemed to have been disabled without being actively involved in the data phase of slave-receiver transfer.
When read as 1, the I2C is deemed to have been actively engaged in an aborted I^2C transfer (with matching address) and the data phase of the I^2C transfer has been entered, even though a data byte has been responded with a NACK.
Note: If the remote master terminates the transfer with a STOP condition before the I2C has a chance to NACK the transfer, and the I2C_ENABLE[ENABLE] bit has been set to 0, then this bit is also set to 1.
Note: CPU can safely read this bit when the IC_EN bit is read as 0.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slave Rx data is not lost</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slave Rx data is lost</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLV_DISABLED_WHILE_BUSY</name>
              <description>Slave Disabled While Busy (Transmit, Receive).
This bit indicates if a potential or active slave operation has been aborted due to CPU setting the I2C_ENABLE[ENABLE] bit from 1 to 0. This bit is asserted when the CPU writes a 0 to the I2C_ENABLE[ENABLE] bit, while:
- In slave-transmitter operation, I2C is receiving the address byte from the remote master;
- In slave-receiver operation, I2C is receiving the address and data bytes from the remote master;
When read as 0, the I2C is deemed to have been disabled when there is master activity, or when the I^2C bus is IDLE.
When read as 1, the I2C is deemed to have forced a NACK during any part of an I^2C transfer, regardless of whether the I^2C address matches the slave address set in I2C (I2C_SAR) OR if the transfer is completed before the I2C_ENABLE[ENABLE] bit is set to 0, but has not taken effect.
Note: If the remote master terminates the transfer with a STOP condition before the I2C has a chance to NACK the transfer, and the I2C_ENABLE[ENABLE] bit has been set to 0, then this bit is also set to 1.
Note: CPU can safely read this bit when the IC_EN bit is read as 0.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slave is disabled when it is IDLE</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slave is disabled when it is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IC_EN</name>
              <description>I2C Enable Status.
Note: The CPU can safely read this bit anytime. When this bit is read as 0, the CPU can safely read the SLV_RX_DATA_LOST and SLV_DISABLED_WHILE_BUSY bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>I2C is deemed completely inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>I2C is deemed to be in an enabled state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_FS_SPKLEN</name>
          <description>SS, FS or FM+ Spike Suppression Limit Register</description>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IC_FS_SPKLEN</name>
              <description>This register must be set before any I2C bus transaction can take place to ensure stable operation. 
This register sets the duration, measured in IC_CLK cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic.
This register can only be written when the I2C module is disabled, which corresponds to the I2C_ENABLE[ENABLE] bit being set to 0. Writes at other times have no effect.
 The minimum valid value is 1; hardware prevents values less than this being written, and if attempted, results in 1 being set.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_HS_SPKLEN</name>
          <description>HS Spike Suppression Limit Register</description>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IC_HS_SPKLEN</name>
              <description>This register must be set before any I2C bus transaction can take place to ensure stable operation. 
This register sets the duration, measured in IC_CLK cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic.
This register can only be written when the I2C module is disabled, which corresponds to the I2C_ENABLE[ENABLE] bit being set to 0. Writes at other times have no effect.
The minimum valid value is 1; hardware prevents values less than this being written, and if attempted, results in 1 being set.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_SCL_STUCK_AT_LOW_TIMEOUT</name>
          <description>SCL Stuck at Low Timeout Register</description>
          <addressOffset>0xAC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IC_SCL_STUCK_LOW_TIMEOUT</name>
              <description>The I2C generates an interrupt (I2C_RAW_INTR_STAT[SCL_STUCK_AT_LOW]), if it detects the SCL stuck at low for a duration of IC_SCL_STUCK_LOW_TIMEOUT in units of IC_CLK period. 
This register can only be written when the I2C module is disabled, which corresponds to the I2C_ENABLE[ENABLE] bit being set to 0. Writes at other times have no effect.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_SDA_STUCK_AT_LOW_TIMEOUT</name>
          <description>SDA Stuck at Low Timeout Register</description>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IC_SDA_STUCK_LOW_TIMEOUT</name>
              <description>The I2C initiates the recovery of the SDA line through enabling the I2C_ENABLE[SDA_STUCK_RECOVERY_EN] bit, if it detects the SDA stuck at low for a duration of IC_SDA_STUCK_LOW_TIMEOUT in units of IC_CLK period.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CLR_SCL_STUCK_DET</name>
          <description>Clear SCL Stuck at Low Detect Interrupt Register</description>
          <addressOffset>0xB4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLR_SCL_STUCK_DET</name>
              <description>Read this bit to clear the I2C_RAW_INTR_STAT[SCL_STUCK_AT_LOW] bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_DEVICE_ID</name>
          <description>Device-ID Register</description>
          <addressOffset>0xB8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DEVICE_ID</name>
              <description>Contains the Device-ID of the component</description>
              <bitRange>[23:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_REG_TIMEOUT_RST</name>
          <description>Timeout Counter Reset Value Register</description>
          <addressOffset>0xF0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000008</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REG_TIMEOUT_RST_RW</name>
              <description>This field holds the reset value of the register timeout counter.
The value of this field (default or programmed) determines from what value the register timeout counter starts
counting down. A zero on this counter will break the waited APB transaction with PSLVERR as high.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_COMP_PARAM_1</name>
          <description>Component Parameter Register 1</description>
          <addressOffset>0xF4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x001F1FEE</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_BUFFER_DEPTH</name>
              <description>This field defines the Tx FIFO buffer depth.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1F</name>
                  <description>32 entries</description>
                  <value>0x1F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RX_BUFFER_DEPTH</name>
              <description>This field defines the Rx FIFO buffer depth.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1F</name>
                  <description>32 entries</description>
                  <value>0x1F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADD_ENCODED_PARAMS</name>
              <description>This field defines the encoded parameters.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Capability of reading encoded parameters via SW is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HAS_DMA</name>
              <description>This field defines the DMA handshaking.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA handshaking signals are enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INTR_IO</name>
              <description>This field defines the interrupt output type.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Combined interrupt output</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HC_COUNT_VALUES</name>
              <description>This field defines the count values.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Programmable count values for each mode</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MAX_SPEED_MODE</name>
              <description>This field defines the maximum speed mode.</description>
              <bitRange>[3:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>High-Speed</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>APB_DATA_WIDTH</name>
              <description>This field defines the APB data bus width.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>32 bits</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_COMP_VERSION</name>
          <description>Component Version Register</description>
          <addressOffset>0xF8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x3230332A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IC_COMP_VERSION</name>
              <description>Component version</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_COMP_TYPE</name>
          <description>Component Type Register</description>
          <addressOffset>0xFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x44570140</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IC_COMP_TYPE</name>
              <description>Component type</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPI3C</name>
      <groupName>I3C</groupName>
      <baseAddress>0x43006000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>644</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>I3C_DEVICE_CTRL</name>
          <description>Device Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>I3C Controller Enable.
This bit controls whether or not I3C is enabled.
In master mode of operation, software can disable I3C while it is active. However, the controller may not get disabled immediately and gets disabled after the commands in the command queue (if any) are executed leading to a STOP condition on the bus and the master FSM is in IDLE state (as indicated in I3C_PRESENT_STATE[MASTER_IDLE] bit).
In slave mode of operation, software can disable I3C while it is active. However, the disable happens after the ongoing transfer is completed on the I3C bus. Software can read back 0 from this bit once disabling of I3C slave is completed. After POR, the I3C slave controller is enabled by programming this bit to 1. However, the I3C bus interface of the controller responds to transfer on the bus only after it observes 'bus available' condition for I3C_BUS_FREE_AVAIL_TIMING[BUS_AVAILABLE_TIME] x I3C_DEVICE_CTRL[IDLE_CNT_MULTPLIER] counts of PCLK period. Successful completion of enable/disable of the I3C controller depends on the availability of SCL to the controller at the time of performing this operation, and hence may not happen instantly.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disables the I3C controller</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables the I3C controller</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESUME</name>
              <description>I3C Controller Resume.
This bit is used to resume the controller after it goes to the HALT state.
In master mode of operation, the I3C controller goes to the HALT state (as indicated in I3C_PRESENT_STATE[CM_TFR_ST_STS] field) due to any type of error in the transfer. The error type is specified in the response packet available in I3C_RESPONSE_QUEUE_PORT register, as per the value in the ERR_STS field .
After the I3C controller goes to the HALT state, the application has to write a 1 to this bit to resume the I3C operation. This bit is auto-cleared once the controller resumes the transfers by initiating the next command.
In slave mode of operation, the I3C controller goes to the HALT state due to the following conditions:
- Any type of error in the transfer;
 - I3C_SLV_MAX_LEN[MRL] field updated by the master through SETMRL CCC;
After the I3C controller goes to the HALT state, the application has to take necessary action to handle the error condition and then write a 1 to this bit to resume the I3C operation. This bit is auto-cleared once the controller is ready to accept new transfers.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ABORT</name>
              <description>I3C Controller Abort.
This bit is used in master mode of operation.
This bit allows the I3C controller to relinquish the I3C bus before completing the issued transfer.
In response to an ABORT request, the controller issues the STOP condition after the complete data byte is transferred or received.
This bit is auto-cleared once the transfer is aborted and the I3C controller issues a 'transfer abort' interrupt (I3C_INTR_STATUS[TRANSFER_ABORT_STS] = 1).</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_ENABLE</name>
              <description>DMA Handshake Interface Enable.
This bit is used to enable or disable the DMA handshake interface, and is applicable to both master and slave modes of operation.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The DMA handshake control has no significance.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables the DMA handshake control to interact with external DMA.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADAPTIVE_I2C_I3C</name>
              <description>Adaptive I2C/I3C Mode.
This field is used in slave mode of operation. 
Note: When the I2C mode strap is driven to 0, the slave controller operates in adaptive mode. Setting of this bit is NOT required to put the controller in adaptive mode. It is only used to enable some features of the slave controller to adapt to adaptive I2C/I3C mode of operation. This bit is cleared automatically if the controller determines the mode as I3C. 
Effect on hot-join:
- If this bit is programmed to 1, the controller initiates a hot-join request only after it has switched to I3C mode of operation.
- If this bit is programmed to 0, the controller initiates a hot-join without determining the bus mode assuming itself to be on I3C bus.
This bit should be set only if the slave application does not know to which bus the device is connected to.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_CNT_MULTPLIER</name>
              <description>Idle Count Multiplier.
This bit is used in slave mode of operation.
After POR, the slave controller is enabled only after it sees both the SDA and SCL lines IDLE for a specified time. This IDLE time is calculated by multiplying IDLE_CNT_MULTPLIER with the I3C_BUS_FREE_AVAIL_TIMING[BUS_AVAILABLE_TIME] field.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>BUS_AVAILABLE_TIME x 1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>BUS_AVAILABLE_TIME x 2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>BUS_AVAILABLE_TIME x 4</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>BUS_AVAILABLE_TIME x 8</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HOT_JOIN_CTRL</name>
              <description>Hot-Join ACK/NACK Control.
This bit is used in master mode of operation.
This bit acts as a global control to ACK/NACK the hot-join request from the devices. The I3C master ACK/NACKs the hot-join request from other devices connected on the I3C interface, based on the programming of this bit.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>ACK hot-join requests</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>NACK and send broadcast CCC to disable hot-join</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2C_SLAVE_PRESENT</name>
              <description>I2C Slave Present.
This bit is used in master mode of operation.
This bit indicates whether any legacy I2C devices are present in the system.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>I2C slave not present</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>I2C slave present</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IBA_INCLUDE</name>
              <description>I3C Broadcast Address Include.
This bit is used in master mode of operation.
This bit is used to include I3C broadcast address (0x7E) for private transfer.
Note: If the I3C broadcast address is not included for the private transfers, In-Band Interrupts (IBIs) driven from slaves might not win address arbitration. Hence, the IBIs get delayed.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>I3C broadcast address is not included for private transfers</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>I3C broadcast address is included for private transfers</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_DEVICE_ADDR</name>
          <description>Device Address Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DYNAMIC_ADDR_VALID</name>
              <description>Dynamic Address Valid.
This bit is used to control whether the dynamic address set in the DYNAMIC_ADDR field is valid or not.
- In I3C main master mode, the user sets this bit to 1 as it self-assigns its dynamic address.
- In all other operation modes, the controller sets this bit to 1 when the main master assigns the dynamic address during ENTDAA or SETDASA mechanism.
- In I3C slave mode, the controller sets this bit to 1 when the main master assigns the dynamic address during ENTDAA or SETDASA mechanism.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Dynamic address is invalid</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Dynamic address is valid</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DYNAMIC_ADDR</name>
              <description>Device Dynamic Address.
This field is used to program the device Dynamic address. The controller uses this address for I3C transfers.
In Main Master mode, the application has to program the Dynamic address through the slave interface as it self-assigns its Dynamic address.
In all other modes, the Main Master assigns this address during ENTDAA or SETDASA mechanism.</description>
              <bitRange>[22:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STATIC_ADDR_VALID</name>
              <description>Static Address Valid.
In slave mode of operation, this bit reflects the value of static address input port. The input port Static address is expected to be driven to 0x1 only if the device supports I2C or I3C Static address.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Static address is invalid</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Static address is valid</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STATIC_ADDR</name>
              <description>Device Static Address.
In Slave mode of operation this field reflects the value of Static address input port. The controller uses this address to respond to SETDASA CCC command to get the Dynamic address if Static address is valid.</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_HW_CAPABILITY</name>
          <description>Hardware Capability Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000E00AB</resetValue>
          <resetMask>0xFFFE07FF</resetMask>
          <fields>
            <field>
              <name>SLV_IBI_CAP</name>
              <description>Specifies slave's capability to initiate in-band interrupt request</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slave IBI request is supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLV_HJ_CAP</name>
              <description>Specifies slave's capability to initiate hot-join request</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slave HJ request is supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DMA_EN</name>
              <description>Specifies whether the controller has DMA handshake interface</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA handshake interface is supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLOCK_PERIOD</name>
              <description>Specifies the minimum period of CORE_CLK (ns integers only), that is, the maximum frequency of CORE_CLK that is intended to be fed to I3C.</description>
              <bitRange>[10:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HDR_TS_EN</name>
              <description>Specifies controller's capability to perform HDR-TS transfers</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>HDR-TS is not supported</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HDR_DDR_EN</name>
              <description>Specifies controller's capability to perform HDR-DDR
transfers</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>HDR-DDR is supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEVICE_ROLE_CONFIG</name>
              <description>Specifies the configured device role of the I3C controller</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Secondary master</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_COMMAND_QUEUE_PORT</name>
          <description>Command Queue Port Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMMAND</name>
              <description>32-bit command</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_RESPONSE_QUEUE_PORT</name>
          <description>Response Queue Port Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESPONSE</name>
              <description>32-bit response</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_RX_DATA_PORT</name>
          <description>Receive Data Port Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_DATA_PORT</name>
              <description>Receive Data Port.
The receive data port is mapped to the Rx data buffer.
The receive data is always packed in 4-byte aligned data words and stored in the Rx data buffer. If the command length is not aligned to the 4-bytes, then the additional data bytes have to be ignored.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_TX_DATA_PORT</name>
          <description>Transmit Data Port Register</description>
          <alternateRegister>I3C_RX_DATA_PORT</alternateRegister>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_DATA_PORT</name>
              <description>Transmit Data Port.
The transmit data port is mapped to the Tx data buffer.
The transmit data should always be packed as 4-byte aligned data words and written to this field. If the command length is not aligned to 4-bytes, then the additional bytes are ignored.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_IBI_QUEUE_STATUS</name>
          <description>In-Band Interrupt Queue Status Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IBI_STS</name>
              <description>IBI Received Status.
Defines the master response for IBI received.
Others: Reserved</description>
              <bitRange>[31:28]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Responded with ACK</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Responded with NACK</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IBI_ID</name>
              <description>IBI Identifier.
This represents the byte received after START condition:
- Device address and R/W bit, in case of SIR or MR IBI;
- Hot-Join ID and R/W bit, in case of HJ IBI;</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA_LENGTH</name>
              <description>IBI Data Length.
This field represents the length of data received along with the IBI, in bytes.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_QUEUE_THLD_CTRL</name>
          <description>Queue Threshold Control Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x01000101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IBI_STATUS_THLD</name>
              <description>In-Band Interrupt Status Threshold Value.
Every IBI received by the I3C controller generates an IBI status. This field controls the number of IBI status entries (or greater) in the IBI queue that trigger the I3C_INTR_STATUS[IBI_THLD_STS] interrupt.
The valid range is 0 to 15. Software
should program only valid values. A value of 0 sets the threshold
for 1 entry, and a value of N sets the threshold for N+1
entries.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESP_BUF_THLD</name>
              <description>Response Buffer Threshold Value.
Controls the number of entries (or greater) in the response queue that trigger the I3C_INTR_STATUS[RESP_READY_STS] interrupt.
The valid range is 0 to 7. Software
should program only valid values. A value of 0 sets the threshold
for 1 entry, and a value of N sets the threshold for N+1
entries.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_EMPTY_BUF_THLD</name>
              <description>Command Buffer Empty Threshold Value.
Controls the number of empty locations (or greater) in the command queue that trigger the I3C_INTR_STATUS[CMD_QUEUE_READY_STS] interrupt.
The valid range is 0 to 15. Software should program only valid values. A value of 0 sets the threshold to indicate that the queue is completely empty, and a value of N (ranging 1-15) sets the threshold for N entries.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_DATA_BUFFER_THLD_CTRL</name>
          <description>Data Buffer Threshold Control Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x01010101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_START_THLD</name>
              <description>Receive Start Threshold Value.
In master mode of operation, when the I3C is set up to initiate a read transfer, it waits until either one of the following conditions is met before it initiates the read transfer on the I3C interface:
 - Data length (as specified in the command) number of locations are empty in Rx FIFO;
- Threshold number of locations (or more) are empty in Rx FIFO;
In slave mode of operation, the I3C slave ACKs a write request from a master only if threshold number of empty locations (or more) are available in its receive buffer.
The supported values for this field are:</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>At least 1 empty location</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>At least 4 empty locations</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>At least 8 empty locations</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>At least 16 empty locations</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>At least 32 empty locations</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>At least 64 empty locations</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TX_START_THLD</name>
              <description>Transmit Start Threshold Value.
In master mode of operation, when the I3C is set up to initiate a write transfer, it waits until either one of the following conditions is met before it initiates the write transfer on the I3C Interface:
 - Data length (as specified in the command) number of locations are filled in Tx FIFO;
- Threshold number of entries (or more) are available in Tx FIFO;
In slave mode of operation, the I3C slave ACKs a read request from a master only if either one of the following conditions is met:
 - Data length (as specified in the command) number of locations are filled in Tx FIFO;
- Threshold number of entries (or more) are available in Tx FIFO;
The supported values for this field are:</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>At least 1 entry</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>At least 4 entries</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>At least 8 entries</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>At least 16 entries</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>At least 32 entries</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>At least 64 entries</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RX_BUF_THLD</name>
              <description>Receive Buffer Threshold Value.
This field controls the number of entries (or above) in the Rx FIFO that trigger the I3C_INTR_STATUS[RX_THLD_STS] interrupt.
If programmed value is greater than the Rx buffer depth,
then the threshold is set to the Rx buffer depth.
The supported values for this field are:</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>At least 1 entry</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>At least 4 entries</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>At least 8 entries</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>At least 16 entries</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>At least 32 entries</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>At least 64 entries</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TX_EMPTY_BUF_THLD</name>
              <description>Transmit Buffer Threshold Value.
This field controls the number of empty locations (or above) in the Tx FIFO that trigger the I3C_INTR_STATUS[TX_THLD_STS] interrupt.
If programmed value is greater than the Tx buffer depth,
then the threshold is set to the Tx buffer depth.
The supported values for this field are:</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>At least 1 empty location</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>At least 4 empty locations</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>At least 8 empty locations</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>At least 16 empty locations</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>At least 32 empty locations</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>At least 64 empty locations</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_IBI_QUEUE_CTRL</name>
          <description>IBI Queue Control Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NOTIFY_SIR_REJECTED</name>
              <description>Notify Rejected Slave Interrupt Request Control.
This bit is used to suppress reporting to the application about a Slave Interrupt Request (SIR) being rejected.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Notify SIR rejected disable. Suppress passing the IBI status to the IBI FIFO when a SIR request is NACK-ed and auto-disabled based on the I3C_IBI_SIR_REQ_REJECT register.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Notify SIR rejected enable. Write IBI status to the IBI FIFO when a SIR request is NACK-ed and auto-disabled based on the I3C_IBI_SIR_REQ_REJECT register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NOTIFY_MR_REJECTED</name>
              <description>Notify Rejected Master Request Control.
This bit is used to suppress reporting to the application about a Master Request (MR) being rejected.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Notify MR rejected disable. Suppress passing the IBI status to the IBI FIFO when a MR request is NACK-ed and auto-disabled based on the I3C_IBI_MR_REQ_REJECT register.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Notify MR rejected enable. Write IBI status to the IBI FIFO when a MR request is NACK-ed and auto-disabled based on the I3C_IBI_MR_REQ_REJECT register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NOTIFY_HJ_REJECTED</name>
              <description>Notify Rejected Hot-Join Control.
This bit is used to suppress reporting to the application about a Hot-Join (HJ) request being rejected.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Notify HJ rejected disable. Suppress passing the IBI status to the IBI FIFO when a HJ request is NACK-ed and auto-disabled based on the I3C_DEVICE_CTRL[HOT_JOIN_CTRL] bit.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Notify HJ rejected enable. Write IBI status to the IBI FIFO when a HJ request is NACK-ed and auto-disabled based on the I3C_DEVICE_CTRL[HOT_JOIN_CTRL] bit.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_IBI_MR_REQ_REJECT</name>
          <description>IBI MR Request Rejection Control Register</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MR_REQ_REJECT</name>
              <description>In-band Master Request Reject.
The control bits of this field determine if the I3C controller ACKs an incoming MR or NACKs and disables it. A
device-specific policy can be established by appropriately
programming this register.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>ACK the MR request</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>NACK and send directed DISEC CCC to disable the interrupting slave</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_IBI_SIR_REQ_REJECT</name>
          <description>IBI SIR Request Rejection Control Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SIR_REQ_REJECT</name>
              <description>In-band Slave Interrupt Request Reject.
The application of the I3C can decide whether to send an ACK or NACK for a slave interrupt request received from any I3C device.
A device-specific response control bit is provided to select the response option. Master ACKs/NACKs the SIR request based on programming of control bit, corresponding to the interrupting device.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>ACK the SIR request</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>NACK and send directed auto-disable CCC</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_RESET_CTRL</name>
          <description>Reset Control Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUS_RESET</name>
              <description>Bus Reset.
This bit is only used in master mode of operation.
Write a 1 to this bit to exercise bus reset pattern generation based on the selection in the BUS_RESET_TYPE field. This bit is cleared automatically once the bus reset pattern generation is complete.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUS_RESET_TYPE</name>
              <description>Bus Reset Type.
Type of bus reset triggered by BUS_RESET bit.
Others: Reserved</description>
              <bitRange>[30:29]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>HDR exit pattern</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>SCL timed reset</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IBI_QUEUE_RST</name>
              <description>IBI Queue Software Reset.
This bit is only used in master mode of operation.
Write a 1 to this bit to exercise IBI queue reset. This bit is cleared automatically once the IBI queue reset is complete.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_FIFO_RST</name>
              <description>Receive Buffer Software Reset.
Write a 1 to this bit to exercise Rx buffer reset. This bit is cleared automatically once the Rx buffer reset is complete.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_FIFO_RST</name>
              <description>Transmit Buffer Software Reset.
Write a 1 to this bit to exercise Tx buffer reset. This bit is cleared automatically once the Tx buffer reset is complete.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESP_QUEUE_RST</name>
              <description>Response Queue Software Reset.
Write a 1 to this bit to exercise response queue reset. This bit is cleared automatically once the response queue reset is complete.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_QUEUE_RST</name>
              <description>Command Queue Software Reset.
Write a 1 to this bit to exercise command queue reset. This bit is cleared automatically once the command queue reset is complete.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SOFT_RST</name>
              <description>Core Software Reset.
Write a 1 to this bit to exercise core reset. This resets: 
 - Queues (command, response) and buffers (transmit, receive);
- User programmable registers to reflect the reset values;
- Pipelining data (if any); 
- State machines to IDLE state; 
This bit is cleared automatically once the core reset is complete.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_SLV_EVENT_STATUS</name>
          <description>Slave Event Status Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000000B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MWL_UPDATED</name>
              <description>This bit indicates a SETMWL CCC is received by the slave. The updated MWL value can be read from I3C_SLV_MAX_LEN[MWL]. This status can be cleared by writing 0x1 to this bit after reading the updated MWL.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>MRL_UPDATED</name>
              <description>This bit indicates a SETMRL CCC is received by the slave. The updated MRL value can be read from I3C_SLV_MAX_LEN[MRL]. This status can be cleared by writing 0x1 to this bit after reading the updated MRL.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>ACTIVITY_STATE</name>
              <description>Activity State Status.
This bit reflects the activity state of slave set by the master.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description> ENTAS0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description> ENTAS1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description> ENTAS2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description> ENTAS3</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HJ_EN</name>
              <description>Hot-Join Interrupt Enable.
This bit reflects whether the HJ request interrupts are allowed on the I3C bus or not.
The slave application can choose to disable hot-Join capability of the slave controller (if selected) by setting this bit to 0x0 before enabling the I3C. When done so, the slave does not initiate hot-join and takes part in address assignment without initiating hot-join.
If this bit is not set to 0x0 by the slave application, it can be set or cleared by the remote I3C master through ENEC or DISEC CCC.
Once disabled, CCC do not have any effect on this bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MR_EN</name>
              <description>Master Request Enable.
In slave mode of operation, this bit reflects whether the controller can initiate the MR request on the I3C bus or not.
Usually, this bit is set or cleared by the remote I3C master through ENEC or DISEC CCC.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SIR_EN</name>
              <description>Slave Interrupt Request Enable.
In slave mode of operation, this bit reflects whether the controller can initiate the SIR request on the I3C bus or not.
Usually, this bit is set or cleared by the remote I3C master through ENEC or DISEC CCC.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_INTR_STATUS</name>
          <description>Interrupt Status Register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUS_RESET_DONE_STS</name>
              <description>Bus Reset Pattern Generation Done Status.
This bit is used only in master mode of operation.
The interrupt is generated when the SCL Low Timeout Bus Reset Pattern Generation is completed.
This bit can be cleared by writing 0x1.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>BUSOWNER_UPDATED_STS</name>
              <description>Bus Owner Updated Status.
This interrupt is set when the role of the I3C changes from being a master to slave or vice versa.
This bit can be cleared by writing 0x1.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>IBI_UPDATED_STS</name>
              <description>IBI Updated Status.
This bit is used only in slave mode of operation.
This bit indicates that the IBI request initiated through SIR request register is addressed and status is updated.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>READ_REQ_RECV_STS</name>
              <description>Read Request Received Status.
This bit is used only in slave mode of operation.
This bit indicates a read request received from the current master when command queue is empty.
This bit can be cleared by writing 0x1.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>DEFSLV_STS</name>
              <description>Define Slave CCC Received Status.
The interrupt is generated if DEFSLV CCC is received.
This bit can be cleared by writing 0x1.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>TRANSFER_ERR_STS</name>
              <description>Transfer Error Status.
The interrupt is generated if any error occurs during transfer. The error type is specified in the response packet associated with the command (in ERR_STS field of the I3C_RESPONSE_QUEUE_PORT register;for details).
This bit can be cleared by writing 0x1.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>DYN_ADDR_ASSGN_STS</name>
              <description>Dynamic Address Assigned Status.
This bit is used only in slave mode of operation.
The interrupt is generated if device's dynamic address is assigned through SETDASA or ENTDAA CCC.
This bit can be cleared by writing 0x1.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>CCC_UPDATED_STS</name>
              <description>CCC Table Updated Status.
This bit is used only in slave mode of operation.
The interrupt is generated if any of the CCC registers are updated by remote I3C master through CCC commands.
This interrupt can be cleared by writing 0x1.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>TRANSFER_ABORT_STS</name>
              <description>Transfer Abort Status.
This bit is used only in master mode of operation.
The interrupt is generated if transfer is aborted.
This interrupt can be cleared by writing 0x1.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>RESP_READY_STS</name>
              <description>Response Queue Ready Status.
The interrupt is generated when the number of entries in the RESP queue is greater than or equal to threshold value specified in the I3C_QUEUE_THLD_CTRL[RESP_BUF_THLD] field.
This bit is cleared automatically when the number of entries in the RESP queue is less than the specified threshold value.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_QUEUE_READY_STS</name>
              <description>Command Queue Ready.
The interrupt is generated when the number of empty locations in CMD queue is greater than or equal to threshold value specified in the I3C_QUEUE_THLD_CTRL[CMD_EMPTY_BUF_THLD] field. 
This bit is cleared automatically when number of empty locations in the CMD queue is less than the specified threshold value.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IBI_THLD_STS</name>
              <description>IBI Buffer Threshold Status.
This bit is only used in master mode of operation.
The interrupt is generated when the number of entries in the IBI buffer is greater than or equal to threshold value specified in the I3C_QUEUE_THLD_CTRL[IBI_STATUS_THLD] field.
This bit is cleared automatically when the number of entries in the IBI buffer is less than the specified threshold value.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_THLD_STS</name>
              <description>Receive Buffer Threshold Status.
The interrupt is generated when the number of entries in the Rx buffer is greater than or equal to threshold value specified in the I3C_DATA_BUFFER_THLD_CTRL[RX_BUF_THLD] field.
This bit is cleared automatically when the number of entries in the Rx buffer is less than the specified threshold value.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_THLD_STS</name>
              <description>Transmit Buffer Threshold Status.
The interrupt is generated when the number of empty locations in the Tx buffer is greater than or equal to threshold value specified in the I3C_DATA_BUFFER_THLD_CTRL[TX_EMPTY_BUF_THLD] field.
This bit is cleared automatically when number of empty locations in the Tx buffer is less than the specified threshold value.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_INTR_STATUS_EN</name>
          <description>Interrupt Status Enable Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUS_RESET_DONE_STS_EN</name>
              <description>Bus Reset Pattern Generation Done Status Enable.
This bit is used only in master mode of operation.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUSOWNER_UPDATED_STS_EN</name>
              <description>Bus Owner Updated Status Enable</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IBI_UPDATED_STS_EN</name>
              <description>IBI Updated Status Enable.
This bit is used in slave mode of operation.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>READ_REQ_RECV_STS_EN</name>
              <description>Read Request Received Status Enable.
This bit is used in slave mode of operation.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEFSLV_STS_EN</name>
              <description>Define Slave CCC Received Status Enable</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRANSFER_ERR_STS_EN</name>
              <description>Transfer Error Status Enable</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DYN_ADDR_ASSGN_STS_EN</name>
              <description>Dynamic Address Assigned Status Enable.
This bit is used in slave mode of operation.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCC_UPDATED_STS_EN</name>
              <description>CCC Table Updated Status Enable.
This bit is used in slave mode of operation.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRANSFER_ABORT_STS_EN</name>
              <description>Transfer Abort Status Enable.
This bit is used only in master mode of operation.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESP_READY_STS_EN</name>
              <description>Response Queue Ready Status Enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_QUEUE_READY_STS_EN</name>
              <description>Command Queue Ready Status Enable</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IBI_THLD_STS_EN</name>
              <description>IBI Buffer Threshold Status Enable.
This bit is used only in master mode of operation.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_THLD_STS_EN</name>
              <description>Receive Buffer Threshold Status Enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_THLD_STS_EN</name>
              <description>Transmit Buffer Threshold Status Enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_INTR_SIGNAL_EN</name>
          <description>Interrupt Signal Enable Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUS_RESET_DONE_SIGNAL_EN</name>
              <description>Bus Reset Pattern Generation Done Signal Enable
This bit is used only in master mode of operation.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUSOWNER_UPDATED_SIGNAL_EN</name>
              <description>Bus Owner Updated Signal Enable</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IBI_UPDATED_SIGNAL_EN</name>
              <description>IBI Updated Signal Enable.
This field is used in slave mode of operation.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>READ_REQ_RECV_SIGNAL_EN</name>
              <description>Read Request Received Signal Enable.
This field is used in slave mode of operation.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEFSLV_SIGNAL_EN</name>
              <description>Define Slave CCC Received Signal Enable</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRANSFER_ERR_SIGNAL_EN</name>
              <description>Transfer Error Signal Enable</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DYN_ADDR_ASSGN_SIGNAL_EN</name>
              <description>Dynamic Address Assigned Signal Enable.
This field is used in slave mode of operation.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCC_UPDATED_SIGNAL_EN</name>
              <description>CCC Table Updated Signal Enable.
This field is used in slave mode of operation.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRANSFER_ABORT_SIGNAL_EN</name>
              <description>Transfer Abort Signal Enable.
This field is used in master mode of operation.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESP_READY_SIGNAL_EN</name>
              <description>Response Queue Ready Signal Enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_QUEUE_READY_SIGNAL_EN</name>
              <description>Command Queue Ready Signal Enable</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IBI_THLD_SIGNAL_EN</name>
              <description>IBI Buffer Threshold Signal Enable.
This field is used in master mode of operation.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_THLD_SIGNAL_EN</name>
              <description>Receive Buffer Threshold Signal Enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_THLD_SIGNAL_EN</name>
              <description>Transmit Buffer Threshold Signal Enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_INTR_FORCE</name>
          <description>Interrupt Force Enable Register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUS_RESET_DONE_FORCE_EN</name>
              <description>Bus Reset Pattern Generation Done Force Enable.
This bit is used only in master mode of operation.</description>
              <bitRange>[15:15]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BUSOWNER_UPDATED_FORCE_EN</name>
              <description>Bus Owner Updated Force Enable</description>
              <bitRange>[13:13]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>IBI_UPDATED_FORCE_EN</name>
              <description>IBI Updated Force Enable.
This bit is used in slave mode of operation.</description>
              <bitRange>[12:12]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>READ_REQ_FORCE_EN</name>
              <description>Read Request Received Force Enable.
This bit is used in slave mode of operation.</description>
              <bitRange>[11:11]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DEFSLV_FORCE_EN</name>
              <description>Define Slave CCC Received Force Enable</description>
              <bitRange>[10:10]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>TRANSFER_ERR_FORCE_EN</name>
              <description>Transfer Error Force Enable</description>
              <bitRange>[9:9]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DYN_ADDR_ASSGN_FORCE_EN</name>
              <description>Dynamic Address Assigned Force Enable.
This bit is used in slave mode of operation.</description>
              <bitRange>[8:8]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CCC_UPDATED_FORCE_EN</name>
              <description>CCC Table Updated Force Enable.
This bit is used in slave mode of operation.</description>
              <bitRange>[6:6]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>TRANSFER_ABORT_FORCE_EN</name>
              <description>Transfer Abort Force Enable.
This bit is used in master mode of operation.</description>
              <bitRange>[5:5]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>RESP_READY_FORCE_EN</name>
              <description>Response Queue Ready Force Enable</description>
              <bitRange>[4:4]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CMD_QUEUE_READY_FORCE_EN</name>
              <description>Command Queue Ready Force Enable</description>
              <bitRange>[3:3]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>IBI_THLD_FORCE_EN</name>
              <description>IBI Buffer Threshold Force Enable.
This bit is used in master mode of operation.</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>RX_THLD_FORCE_EN</name>
              <description>Receive Buffer Threshold Force Enable</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>TX_THLD_FORCE_EN</name>
              <description>Transmit Buffer Threshold Force Enable</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_QUEUE_STATUS_LEVEL</name>
          <description>Queue Status Level Register</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IBI_BUF_BLR</name>
              <description>IBI Buffer Level Value.
This field contains the number of valid IBI status entries in the IBI buffer.
This field is used in master mode of operation.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RESP_BUF_BLR</name>
              <description>Response Buffer Level Value.
 This field contains the number of valid data entries in the response buffer.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_QUEUE_EMPTY_LOC</name>
              <description>Command Queue Empty Locations.
This field contains the number of empty locations in the command buffer.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_DATA_BUFFER_STATUS_LEVEL</name>
          <description>Data Buffer Status Level Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000040</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_BUF_BLR</name>
              <description>Receive Buffer Level Value.
This field contains the number of valid data entries in the receive buffer.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_BUF_EMPTY_LOC</name>
              <description>Transmit Buffer Empty Level Value.
This field contains the number of empty locations in the transmit buffer.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_PRESENT_STATE</name>
          <description>Present State Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x10000007</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASTER_IDLE</name>
              <description>Master IDLE.
This bit reflects whether the I3C master is in IDLE state or not. This bit is set when all queues (command, response, IBI) and buffers (transmit, receive) are empty and the master FSM is in IDLE state.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>I3C master is not in IDLE state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>I3C master is in IDLE state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_TID</name>
              <description>Command Transaction-ID.
This field reflects the Transaction-ID of the currently executing command.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CM_TFR_ST_STS</name>
              <description>Current Master Transfer State Status.
 This field indicates the state of current transfer currently being executed by the I3C. This is valid in master mode only.</description>
              <bitRange>[21:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>IDLE (controller is in IDLE state, waiting for commands from application or slave-initiated IBI)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>START generation state</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>RESTART generation state</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>STOP generation state</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>START hold generation for the slave-initiated START state</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>Broadcast write address header (0x7E, W) generation state</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>Broadcast read address header (0x7E, R) generation state</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>Dynamic address assignment state</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>Slave address generation state</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>CCC byte generation state</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>HDR command generation state</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xD</name>
                  <description>Write data transfer state</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xE</name>
                  <description>Read data transfer state</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description>IBI (SIR) read data state</description>
                  <value>0xF</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x10</name>
                  <description>IBI auto-disable state</description>
                  <value>0x10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x11</name>
                  <description>HDR-DDR CRC data generation/receive state</description>
                  <value>0x11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x12</name>
                  <description>Clock extension state</description>
                  <value>0x12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x13</name>
                  <description>HALT state (controller is in HALT state, waiting for resume from application through the I3C_DEVICE_CTRL[RESUME] bit)</description>
                  <value>0x13</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CM_TFR_STS</name>
              <description>Transfer Type Status.
This field indicates the type of transfer currently being executed by the I3C.
In master mode of operation:
0x0: IDLE (controller is in IDLE state, waiting for commands from application or slave-initiated IBI)
0x1: Broadcast CCC write transfer
0x2: Directed CCC write transfer
0x3: Directed CCC read transfer
0x4: ENTDAA address assignment transfer
0x5: SETDASA address assignment transfer
0x6: Private I3C SDR write transfer
0x7: Private I3C SDR read transfer
0x8: Private I2C SDR write transfer
0x9: Private I2C SDR read transfer
0xC: Private HDR-DDR write transfer
0xD: Private HDR-DDR read transfer
0xE: Servicing IBI transfer
0xF: HALT state (controller is in HALT state, waiting for resume from application through the I3C_DEVICE_CTRL[RESUME] bit)
In slave mode of operation:
0x0: IDLE (controller is in IDLE state)
0x1: Hot-join transfer state
0x2: IBI transfer state
0x3: Master write transfer ongoing
0x4: Read data prefetch state
0x5: Master read transfer ongoing
0x6: HALT state (controller is in HALT state, waiting for resume from application through the I3C_DEVICE_CTRL[RESUME] bit)</description>
              <bitRange>[13:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURRENT_MASTER</name>
              <description>Current Master.
This bit is used to check whether I3C master is current master or not. The current master is the master that owns the SCL line.
If this bit is set to 0, I3C master is not current master and requires to request the ownership before initiating any transfer on the line.
If this bit is set to 1, I3C master is current master and can initiate transfers on the line.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SDA_LINE_SIGNAL_LEVEL</name>
              <description>SDA Line Signal Level.
This bit is used to check the SDA line level to recover from errors and for debugging. It reflects the value of synchronized SDA signal.
This is valid in master mode only.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SCL_LINE_SIGNAL_LEVEL</name>
              <description>SCL Line Signal Level.
This bit is used to check the SCL line level to recover from errors and for debugging. It reflects the value of synchronized SCL signal.
This is valid in master mode only.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_CCC_DEVICE_STATUS</name>
          <description>Device Operating Status Register</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FRAME_ERROR</name>
              <description>Frame Error.
This bit is set when private write request from master has frame error in HDR-DDR mode. This is cleared only after master reads the device status through GETSTATUS CCC.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BUFFER_NOT_AVAIL</name>
              <description>Buffer Not Available.
This bit is set when private write request from master is NACK-ed because of Rx buffer not having I3C_DATA_BUFFER_THLD_CTRL[RX_BUF_THLD] number of empty locations or response buffer is full. In SDR mode of operation this is cleared when the master issues GETSTATUS CCC or upon space becoming available in the buffer and the successful completion of the next write transfer. In HDR mode of operation it is cleared only when the master issues GETSTATUS CCC.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA_NOT_READY</name>
              <description>Data Not Ready.
This bit is set when private read request from master is NACK-ed because of any of the following conditions:
 - Command FIFO empty;
- Tx FIFO threshold is not met;
- Response FIFO full; 
 </description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW_ERR</name>
              <description>Overflow Error.
Overflow error condition detected during master write transfer. This is cleared only after master reads the device status through GETSTATUS CCC.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SLAVE_BUSY</name>
              <description>Slave Busy.
This bit is set if any change is made by the current master in to MRL register or occurance of any error. It is cleared after slave application resumes the slave operation by writing 1 to the I3C_DEVICE_CTRL[RESUME] bit.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNDERFLOW_ERR</name>
              <description>Underflow Error.
This bit is set if I3C slave terminates a read transfer because of unavailability of data in the transmit buffer. This is cleared only after master reads the device status through GETSTATUS CCC.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACTIVITY_MODE</name>
              <description>Activity Mode.
This field reflects the input port signal ACT_MODE.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PROTOCOL_ERR</name>
              <description>Protocol Error.
This bit is set when the slave controller encounters a parity/CRC error during write data transfer.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PENDING_INTR</name>
              <description>Pending Interrupt.
This field reflects the value driven on PENDING_INT input port.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_DEVICE_ADDR_TABLE_POINTER</name>
          <description>Pointer for Device Address Table Registers</description>
          <addressOffset>0x5C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00080280</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DEV_ADDR_TABLE_DEPTH</name>
              <description>Depth of Device Address Table</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>P_DEV_ADDR_TABLE_START_ADDR</name>
              <description>Start Address of Device Address Table</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_DEV_CHAR_TABLE_POINTER</name>
          <description>Pointer for Device Characteristics Table Register</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00020200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRESENT_DEV_CHAR_TABLE_INDX</name>
              <description>Current Index of Device Characteristics Table.
This field returns the current location of the Device Characteristics Table (DCT) index. Initially, this index points to 0.
 Once the complete characteristics information of a slave device is written into DCT during ENTDAA, this index increments by 1. The first winning device information is stored into DCT index 0, the second winning device information into DCT index 1, and so on.
If required, this index is used to override the location, where the characteristic information of the slave devices on the I3C bus is written during ENTDAA. Hence, this bit is useful only if the device is current master. During DEFSLV CCC, the index always starts from 0.
In non-current master, this bit is always read-only.</description>
              <bitRange>[21:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEV_CHAR_TABLE_DEPTH</name>
              <description>Depth of Device Characteristics Table</description>
              <bitRange>[18:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>P_DEV_CHAR_TABLE_START_ADDR</name>
              <description>Start Address of Device Characteristics Table</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_VENDOR_SPECIFIC_REG_POINTER</name>
          <description>Pointer for Vendor Specific Registers</description>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000B0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>P_VENDOR_REG_START_ADDR</name>
              <description>Start Address of Vendor Specific Registers</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_SLV_MIPI_ID_VALUE</name>
          <description>Manufacturer ID Register</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SLV_MIPI_MFG_ID</name>
              <description>Specifies the MIPI Manufacturer ID of the I3C device, PID[47-33]</description>
              <bitRange>[15:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SLV_PROV_ID_SEL</name>
              <description>Specifies the Provisional ID type of the I3C device, PID[32]</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Vendor-fixed value</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Random value</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_SLV_PID_VALUE</name>
          <description>Provisional ID Register</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SLV_PART_ID</name>
              <description>Specifies the Part ID of the I3C device, PID[31-16]</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SLV_INST_ID</name>
              <description>Specifies the Instance ID of the I3C device, PID[15-12]</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SLV_PID_DCR</name>
              <description>Specifies the additional 12-bit ID of the I3C device, PID[11-0]</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_SLV_CHAR_CTRL</name>
          <description>I3C Slave Characteristic Register</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00010062</resetValue>
          <resetMask>0xFFFFFFE3</resetMask>
          <fields>
            <field>
              <name>HDR_CAP</name>
              <description>I3C Device HDR Capability Field Value.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>HDR Mode 0 (HDR-DDR)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DCR</name>
              <description>I3C Device Characteristic Value.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVICE_ROLE</name>
              <description>Device Role Field in Bus Characteristic Register, BCR[7:6].
This field is set to 0x1 by default, because the I3C is configured to a 'secondary master' device role. The
application is not expected to change the role once
configured. But if the application chooses to operate the
secondary master configuration as
slave-only through programming, then the device role
can be overwritten as a slave (BCR[7:6] = 0x0).
This field is
reset to its default value upon HW/SW reset. Software must
program the values again after issuing reset.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HDR_CAPABLE</name>
              <description>HDR Capable Field in Bus
Characteristic Register, BCR[5].
This field is set to 0x1 by default, because the I3C is configured to support HDR mode. Note that programming this bit to 0x0 does not disable the HDR
feature itself. This bit can be modified by the application if it
does not want to advertize slave's HDR capability to master.
This field is
reset to its default value upon HW/SW reset. Software must
program the values again after issuing reset.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IBI_REQUEST_CAPABLE</name>
              <description>IBI Request Capable Field in Bus Characteristic Register, BCR[1].</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slave IBI is supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MAX_DATA_SPEED_LIMIT</name>
              <description>Max Data Speed Limitation Field in Bus Characteristic Register, BCR[0].
Specifies whether or not I3C has maximum data speed limitation.
If this bit is set to 0, controller NACK-ed the GETMXDS CCC sent by the master.
If this bit is set to 1, controller returns the data in I3C_MAX_DATA_SPEED and I3C_MAX_READ_TURNAROUND registers in response to the GETMXDS CCC sent by the master.
This field is
reset to its default value upon HW/SW reset. Software must
program the values again after issuing reset.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_SLV_MAX_LEN</name>
          <description>I3C Max Write/Read Length Register</description>
          <addressOffset>0x7C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00FF00FF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MRL</name>
              <description>I3C Device Max Read Length</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MWL</name>
              <description>I3C Device Max Write Length</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_MAX_READ_TURNAROUND</name>
          <description>MXDS Maximum Read Turnaround Time Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MXDS_MAX_RD_TURN</name>
              <description>Specifies the maximum read turnaround time (in us) of I3C slave.
A value of 0 indicates that I3C slave supports GETMXDS Format 1 (two data bytes).</description>
              <bitRange>[23:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_MAX_DATA_SPEED</name>
          <description>MXDS Maximum Data Speed Register</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MXDS_CLK_DATA_TURN</name>
              <description>Specifies the clock to data turnaround time of I3C slave device.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>8 ns</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>9 ns</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>10 ns</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>11 ns</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>12 ns</description>
                  <value>0x4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MXDS_MAX_RD_SPEED</name>
              <description>Specifies the Maximum Sustained Data Rate for non-CCC messages sent by I3C slave device to master device.</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>12.5 MHz</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>8 MHZ</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>6 MHz</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>4 MHz</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>2 MHz</description>
                  <value>0x4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MXDS_MAX_WR_SPEED</name>
              <description>Specifies the Maximum Sustained Data Rate for non-CCC messages sent by master device to I3C slave device.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>12.5 MHz</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>8 MHZ</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>6 MHz</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>4 MHz</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>2 MHz</description>
                  <value>0x4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_SLV_INTR_REQ</name>
          <description>Slave Interrupt Request Register</description>
          <addressOffset>0x8C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IBI_STS</name>
              <description>IBI Completion Status.
This field is common for SIR and MR.
The controller does not attempt to issue the IBI and generates the IBI completion status as 0x3 if one of the following condition is true:
 - Master has not assigned the dynamic address;
- Master has cleared the assigned dynamic address (through RSTDAA CCC);
- Master has disabled the IBI event (through DISEC CCC);
- The controller has switched the role to master;</description>
              <bitRange>[9:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>IBI accepted by the master (ACK response received)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>IBI not attempted</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MR</name>
              <description>Master Request.
 When set, the controller attempts to issue the MR on the I3C bus. Once issued and when the current master accepts (ACK) or if the controller is unable to issue the MR, then the controller clears this bit automatically and updates the IBI_STS field. If NACK response is received for the MR, then the controller re-attempts the MR upon detecting the next START condition from the master or after the 'bus available' time. 
Once set, the application cannot clear this bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SIR_CTRL</name>
              <description>Slave Interrupt Request Control.</description>
              <bitRange>[2:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Send the assigned dynamic address</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SIR</name>
              <description>Slave Interrupt Request.
When set, the controller attempts to issue the SIR on the I3C bus. Once issued and when the current master accepts (ACK) or if the controller is unable to issue the SIR, then the controller clears this bit automatically and updates the IBI_STS field. If NACK response is received for the SIR, then the controller re-attempts the SIR upon detecting the next START condition from the master or after the 'bus available' time.
Once set, the application cannot clear this bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_DEVICE_CTRL_EXTENDED</name>
          <description>Device Control Extended Register</description>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REQMST_ACK_CTRL</name>
              <description>In slave mode of operation, this bit serves as a control to ACK / NACK GETACCMST CCC from current master.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>ACK GETACCMST CCC</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>NACK GETACCMST CCC</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEV_OPERATION_MODE</name>
              <description>This field is used to select the device operation mode before the I3C is enabled. This field is written only when the I3C is disabled.
This field is automatically updated by the I3C once the
role change happens in secondary master mode.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Master</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slave</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_SCL_I3C_OD_TIMING</name>
          <description>SCL I3C Open Drain Timing Register</description>
          <addressOffset>0xB4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x000A0010</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I3C_OD_HCNT</name>
              <description>I3C Open-Drain High Count.
SCL open-drain high count timing for I3C transfers.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I3C_OD_LCNT</name>
              <description>I3C Open-Drain Low Count.
SCL open-drain low count timing for I3C transfers.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_SCL_I3C_PP_TIMING</name>
          <description>SCL I3C Push Pull Timing Register</description>
          <addressOffset>0xB8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x000A000A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I3C_PP_HCNT</name>
              <description>I3C Push-Pull High Count.
SCL push-pull high count timing for I3C transfers.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I3C_PP_LCNT</name>
              <description>I3C Push-Pull Low Count.
SCL push-pull low count timing for I3C transfers.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_SCL_I2C_FM_TIMING</name>
          <description>SCL I2C Fast Mode Timing Register</description>
          <addressOffset>0xBC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00100010</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2C_FM_HCNT</name>
              <description>I2C Fast Mode High Count.
The SCL open-drain high count timing for I2C FM transfers.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_FM_LCNT</name>
              <description>I2C Fast Mode Low Count.
The SCL open-drain low count timing for I2C FM transfers.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_SCL_I2C_FMP_TIMING</name>
          <description>SCL I2C Fast Mode Plus Timing Register</description>
          <addressOffset>0xC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00100010</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2C_FMP_HCNT</name>
              <description>I2C Fast Mode Plus High Count.
The SCL open-drain high count timing for I2C FM+ transfers.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_FMP_LCNT</name>
              <description>I2C Fast Mode Plus Low Count.
The SCL open-drain low count timing for I2C FM+ transfers.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_SCL_EXT_LCNT_TIMING</name>
          <description>SCL Extended Low Count Timing Register</description>
          <addressOffset>0xC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20202020</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I3C_EXT_LCNT_4</name>
              <description>I3C Extended Low Count Register 4.
SDR4 uses this field for data transfer.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I3C_EXT_LCNT_3</name>
              <description>I3C Extended Low Count Register 3.
SDR3 uses this field for data transfer.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I3C_EXT_LCNT_2</name>
              <description>I3C Extended Low Count Register 2.
SDR2 uses this field for data transfer.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I3C_EXT_LCNT_1</name>
              <description>I3C Extended Low Count Register 1.
SDR1 uses this field for data transfer.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_SCL_EXT_TERMN_LCNT_TIMING</name>
          <description>SCL Termination Bit Low Count Timing Register</description>
          <addressOffset>0xCC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x10000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STOP_HLD_CNT</name>
              <description>Stop Hold Count.
Stop hold count in terms of CORE_CLKs which is used for 'stop hold' generation in master mode.</description>
              <bitRange>[31:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I3C_EXT_TERMN_LCNT</name>
              <description>I3C Extended Read Termination Bit Low Count.
Effective termination bit low period is derived based on the SDR speed.
SDR0 speed: I3C_PP_LCNT + I3C_EXT_TERMN_LCNT
SDR1 speed: I3C_EXT_LCNT_1 + I3C_EXT_TERMN_LCNT
SDR2 speed: I3C_EXT_LCNT_2 + I3C_EXT_TERMN_LCNT
SDR3 speed: I3C_EXT_LCNT_3 + I3C_EXT_TERMN_LCNT
SDR4 speed: I3C_EXT_LCNT_4 + I3C_EXT_TERMN_LCNT</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_SDA_HOLD_SWITCH_DLY_TIMING</name>
          <description>SDA Hold and Mode Switch Delay Timing Register</description>
          <addressOffset>0xD0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00010000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SDA_TX_HOLD</name>
              <description>This field controls the hold time (in term of the CORE_CLK periods) of the transmit data (SDA) with respect to the SCL edge in the FM, FM+, SDR and DDR speed modes. 
The valid values are from 0x1 to 0x7. Others are reserved.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_PP_OD_SWITCH_DLY</name>
              <description>This field is used to delay the sda_out with respect to sda_oe (in terms of CORE_CLK period) while switching the transfer from PP1 (Push-Pull Mode SDA = 1) to OD1 (Open-Drain SDA = 1).
The valid value can range from 0 to 4. Others are reserved.</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OD_PP_SWITCH_DLY</name>
              <description>This field is used to delay the sda_oe with respect to sda_out (in terms of CORE_CLK period) while switching the transfer from OD1 (Open-Drain Mode SDA = 1) to PP1 (Push-Pull Mode SDA = 1).
The valid value can range from 0 to 4. Others are reserved.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_BUS_FREE_AVAIL_TIMING</name>
          <description>Bus Free Timing Register</description>
          <addressOffset>0xD4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00200020</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUS_AVAILABLE_TIME</name>
              <description>Bus Available Count Value.
This field is used only in slave mode of operation.
This field is used by the slave / non-current master to initiate an IBI after STOP condition.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUS_FREE_TIME</name>
              <description>Bus Free Count Value.
This field is used only in master mode of operation.
In pure bus system, this field represents tCAS parameter. In mixed bus system, this field is expected to be programmed to tLOW of I2C timing.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_BUS_IDLE_TIMING</name>
          <description>Bus Idle Timing Register</description>
          <addressOffset>0xD8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000020</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUS_IDLE_TIME</name>
              <description>Bus Idle Count Value.
This field is used by the controller in slave or non-current master mode to initiate a hot-join request if the dynamic address is not valid.</description>
              <bitRange>[19:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_SCL_LOW_MST_EXT_TIMEOUT</name>
          <description>SCL Low Master Extended Timeout Register</description>
          <addressOffset>0xDC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x003567E0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCL_LOW_MST_TIMEOUT_COUNT</name>
              <description>This count defines the number of CORE_CLK periods to count for generation of the SCL low bus reset pattern.</description>
              <bitRange>[25:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_VER_ID</name>
          <description>Version ID Register</description>
          <addressOffset>0xE0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x3130312A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I3C_VER_ID</name>
              <description>Current release number.
An application reading this register along with the I3C_VER_TYPE register gathers details of the current release.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_VER_TYPE</name>
          <description>Version Type Register</description>
          <addressOffset>0xE4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x6C633030</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I3C_VER_TYPE</name>
              <description>Current release type.
An application reading this register along with the I3C_VER_ID register gathers details of the current release.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_QUEUE_SIZE_CAPABILITY</name>
          <description>I3C Queue Size Capability Register</description>
          <addressOffset>0xE8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00032355</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IBI_BUF_SIZE</name>
              <description>IBI Queue Size</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>16 DWORDS</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESP_BUF_SIZE</name>
              <description>Response Queue Size</description>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>8 DWORDS</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_BUF_SIZE</name>
              <description>Command Queue Size</description>
              <bitRange>[11:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>16 DWORDS</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RX_BUF_SIZE</name>
              <description>Receive Data Buffer Size</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>64 DWORDS</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TX_BUF_SIZE</name>
              <description>Transmit Data Buffer Size</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>64 DWORDS</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_DEV_CHAR_TABLE1_LOC1</name>
          <description>Device Characteristic Table Location 1 Register</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MSB_PROVISIONAL_ID</name>
              <description>The MSB 32-bit value of Provisional-ID</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_SEC_DEV_CHAR_TABLE1</name>
          <description>Secondary Master Device Characteristic Table Location Register</description>
          <alternateRegister>I3C_DEV_CHAR_TABLE1_LOC1</alternateRegister>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STATIC_ADDR</name>
              <description>The Static Address of Device</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BCR_TYPE</name>
              <description>The BCR Type of Device</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DCR_TYPE</name>
              <description>The DCR Type of Device</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYNAMIC_ADDR</name>
              <description>The Dynamic Address of Device</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_DEV_CHAR_TABLE1_LOC2</name>
          <description>Device Characteristic Table Location 2 Register</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LSB_PROVISIONAL_ID</name>
              <description>The LSB 16-bit value of Provisional-ID</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_DEV_CHAR_TABLE1_LOC3</name>
          <description>Device Characteristic Table Location 3 Register</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BCR</name>
              <description>Bus Characteristic Value</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DCR</name>
              <description>Device Characteristic Value</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_DEV_CHAR_TABLE1_LOC4</name>
          <description>Device Characteristic Table Location 4 Register</description>
          <addressOffset>0x20C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DEV_DYNAMIC_ADDR</name>
              <description>Device Dynamic Address assigned.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_DEV_ADDR_TABLE_LOC1</name>
          <description>Device Address Table Location 1 Register</description>
          <addressOffset>0x280</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LEGACY_I2C_DEVICE</name>
              <description>Legacy I2C Device or Not.
This bit should be set to 1 if the device is a legacy I2C device.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEV_NACK_RETRY_CNT</name>
              <description>Device NACK Retry Count.
This field is used to set Device NACK Retry Count for the particular device.
If the device NACKs for the device address, the I3C automatically retries the same device until this count expires. If the slave does not ACK for the mentioned number of retries, then I3C generates an error response and moves to the HALT state.
This feature is used for Retry Model for the following features in the I3C specification:
- Retry Model for Direct GET CCC Commands.
- The incoming SIR-IBI matches with the slave address initiated by the master.</description>
              <bitRange>[30:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEV_DYNAMIC_ADDR</name>
              <description>Device Dynamic Address with Parity.
This field consists of dynamic address and parity bit. The LSB bits [22:16] should
consist of 7-bit dynamic address field indicating the address to be
assigned for the winning I3C device when using the ENTDAA
command. The MSB bit [23] is the odd parity of the 7-bit
dynamic address used for the ENTDAA address assignment
(~XOR(DEV_DYNAMIC_ADDR[22:16]).</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEV_STATIC_ADDR</name>
              <description>Device Static Address</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>M55HE_CFG</name>
      <baseAddress>0x43007000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>40</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>HE_DMA_CTRL</name>
          <description>DMA2 Boot Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x00010001</resetMask>
          <fields>
            <field>
              <name>SW_RST</name>
              <description>Software reset for DMA2</description>
              <bitRange>[16:16]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No reset</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Reset DMA2. This bit is self-cleared.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BOOT_MANAGER</name>
              <description>When DMA2 exits from reset, this bit controls the security state of the DMA manager thread</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Assigns DMA manager to the secure state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Assigns DMA manager to the non-secure state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HE_DMA_IRQ</name>
          <description>DMA2 Boot IRQ Non-Secure Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BOOT_IRQ</name>
              <description>Controls the security state of an event-interrupt resource, when DMA2 exits from reset</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DMA2 assigns event x or IRQ[x] to the secure state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA2 assigns event x or IRQ[x] to the non-secure state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HE_DMA_PERIPH</name>
          <description>DMA2 Boot Peripheral Non-Secure Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BOOT_PERIPH</name>
              <description>Controls the security state of a peripheral request interface, when DMA2 exits from reset</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DMA2 assigns peripheral request interface x to the secure state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA2 assigns peripheral request interface x to the non-secure state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HE_DMA_SEL</name>
          <description>DMA2 Select Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFF011331</resetMask>
          <fields>
            <field>
              <name>FLT_ENA</name>
              <description>This field provides glitch filtering for the GPIOV_[7-0] signals that are mapped to DMA2 inputs [31-24] DMA2 (M55-HE) Requests Mapping).
For each bit:</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable glitch-filter for LPGPIO input</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable glitch-filter for LPGPIO input</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PDM</name>
              <description>Select DMA for LPPDM</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select DMA2</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select DMA0</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2S</name>
              <description>Select DMA for LPI2S</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select DMA2</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select DMA0</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I3C</name>
              <description>Select DMA for LPI3C</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select DMA2</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select DMA0</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPI</name>
              <description>Select DMA for LPSPI</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select DMA2</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select DMA0 group 1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Select DMA0 group 2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Select DMA0 group 2</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UART</name>
              <description>Select DMA for LPUART</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select DMA2</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select DMA0</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HE_CLK_ENA</name>
          <description>Peripheral Clock Enable Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x8003F311</resetMask>
          <fields>
            <field>
              <name>WRAP_DIS</name>
              <description>Enable wrap cleaner</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Enable wrap cleaner</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Disable wrap cleaner</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UTM_CKEN</name>
              <description>Enable clock for LPUTIMER</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPI_CKEN</name>
              <description>Enable clock for LPSPI</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPI_MODE</name>
              <description>Master/Slave mode select for LPSPI</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Master mode (LPSPI0)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slave mode (LPSPI1)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I3C_CKEN</name>
              <description>Enable clock for LPI3C</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2C_CKEN</name>
              <description>Enable clock for LPI2C</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CPI_CKEN</name>
              <description>Enable clock for LPCPI</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PDM_CKSEL</name>
              <description>Select clock source for LPPDM</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select 76.8 MHz crystal-oscillator clock (76M8_CLK)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select external audio clock input (AUDIO_CLK)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PDM_CKEN</name>
              <description>Enable clock for LPPDM</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DMA_CKEN</name>
              <description>Enable clock for DMA2 and EVTRTR2</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NPU_CKEN</name>
              <description>Enable clock for NPU-HE</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HE_I2S_CTRL</name>
          <description>LPI2S Control Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000100</resetValue>
          <resetMask>0x001313FF</resetMask>
          <fields>
            <field>
              <name>SCLK_AON</name>
              <description>LPI2S clock output to external device always on</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>LPI2S clock output (LPI2S_SCLK) in gated mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>LPI2S clock output (LPI2S_SCLK) in always on mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIV_BYPASS</name>
              <description>LPI2S clock divider bypass</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Do not bypass clock divider</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Bypass clock divider</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>LPI2S functional clock source select</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select 76.8 MHz crystal-oscillator clock (76M8_CLK)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select external audio clock input (AUDIO_CLK)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_ENA</name>
              <description>LPI2S clock enable</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock for LPI2S module</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock for LPI2S module</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_DIVISOR</name>
              <description>LPI2S functional clock divisor
n: Clock divided by n</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Illegal values</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Illegal values</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Clock divided by 2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Clock divided by 3</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HE_I3C_CTRL</name>
          <description>LPI3C Control Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000003F1</resetMask>
          <fields>
            <field>
              <name>ACT_MODE</name>
              <description>LPI3C slave activity mode for GETSTATUS CCC</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PENDING_INT</name>
              <description>LPI3C pending interrupt information for GETSTATUS CCC</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_I2C</name>
              <description>LPI3C mode select signal (I2C or I3C )</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HE_CAMERA_PIXCLK</name>
          <description>LPCPI Pixel Clock Control Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x01FF0000</resetValue>
          <resetMask>0x01FF0001</resetMask>
          <fields>
            <field>
              <name>DIVISOR</name>
              <description>LPCPI pixel clock integer divisor
n: Clock divided by n</description>
              <bitRange>[24:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Illegal values</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Illegal values</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Clock divided by 2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Clock divided by 3</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENA</name>
              <description>LPCPI pixel clock enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HE_DMA_GPIO16_SEL</name>
          <description>DMA2 GPIO16 Filter Select Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFF000000</resetMask>
          <fields>
            <field>
              <name>FLT_ENA</name>
              <description>For each bit:</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable glitch-filter for GPIO16 input</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable glitch-filter for GPIO16 input</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPUART</name>
      <groupName>UART</groupName>
      <baseAddress>0x43008000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>256</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>UART_RBR</name>
          <description>Receive Buffer Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RBR</name>
              <description>Receive Buffer Register Field
This field contains the data byte received on the serial input port. The data is valid only if the UART_LSR[DR] is set.
If FIFOs are disabled (UART_FCR[FIFOE] set to 0), the data in the UART_RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an over-run error.
If FIFOs are enabled (UART_FCR[FIFOE] set to 1), this register accesses the head of the Rx FIFO. If the Rx FIFO is full and this field is not read before the next data character arrives, then the data already in the FIFO will be preserved, but any incoming data will be lost and an over-run error occurs.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_DLL</name>
          <description>Divisor Latch Low Register</description>
          <alternateRegister>UART_RBR</alternateRegister>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DLL</name>
              <description>Divisor Latch Low Field
 The output baud rate is equal to serial clock frequency (SCLK for UART, PCLK for LPUART) divided by 16 times the value of the baud rate divisor, as follows:
 baud rate = (serial clock frequency) / (16 x divisor).
Note: With the Divisor Latch registers (UART_DLL and UART_DLH) set to 0, the baud clock is disabled and no serial communication will occur. Also, once the DLL is set, at least 8 clock cycles of the slowest UART clock should be allowed to pass before transmitting or receiving data.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_THR</name>
          <description>Transmit Holding Register</description>
          <alternateRegister>UART_RBR</alternateRegister>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>THR</name>
              <description>This field contains data to be transmitted on the serial output port. Data should only be written to the THR when the UART_LSR[THRE] is set.
If FIFOs are disabled (UART_FCR[FIFOE] set to 0) and UART_LSR[THRE] is set, writing a single character to the THR field clears the UART_LSR[THRE]. Any additional writes to the THR before the UART_LSR[THRE] is set again cause the THR data to be overwritten. 
If FIFOs are enabled (UART_FCR[FIFOE] set to 1) and UART_LSR[THRE] is set, 32 number of characters of data may be written to the THR before the FIFO is full. Any attempt to write data when the FIFO is full results in the write data being lost. 
Note: The 9^th bit is applicable only when UART_LCR_EXT[TRANSMIT_MODE]=1.</description>
              <bitRange>[8:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_DLH</name>
          <description>Divisor Latch High Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DLH</name>
              <description>Divisor Latch High
 The output baud rate is equal to serial clock frequency (SCLK for UART, PCLK for LPUART) divided by 16 times the value of the baud rate divisor, as follows: 
baud rate = (serial clock frequency) / (16 x divisor).
Note: With the Divisor Latch registers (UART_DLL and UART_DLH) set to 0, the baud clock is disabled and no serial communication will occur. Also, once the DLH is set, at least 8 clock cycles of the slowest UART clock should be allowed to pass before transmitting or receiving data.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_IER</name>
          <description>Interrupt Enable Register</description>
          <alternateRegister>UART_DLH</alternateRegister>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PTIME</name>
              <description>Programmable THRE Interrupt Mode Enable
 This bit is used to enable/disable the generation of THRE interrupt.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable programmable THRE interrupt mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable programmable THRE interrupt mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ELCOLR</name>
              <description>This bit controls the method for clearing the status in the UART_LSR register. This is applicable only for overrun error, parity error, framing error, and break interrupt status bits of UART_LSR register. </description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>UART_LSR status bits are cleared either on reading Rx FIFO (UART_RBR) or UART_LSR register. The overrun error interrupt status is cleared only on reading UART_LSR register.</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EDSSI</name>
              <description>Enable Modem Status Interrupt
This bit is used to enable/disable the generation of Modem Status interrupt. This is the fourth highest priority interrupt.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable Modem Status interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable Modem Status interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ELSI</name>
              <description>Enable Receiver Line Status Interrupt
This bit is used to enable/disable the generation of Receiver Line Status interrupt. This is the highest priority interrupt.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable Receiver Line Status interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable Receiver Line Status interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ETBEI</name>
              <description>Enable Transmit Holding Register Empty Interrupt
This bit is used to enable/disable the generation of THRE Interrupt. This is the third highest priority interrupt.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable THRE interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable THRE interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ERBFI</name>
              <description>Enable Received Data Available Interrupt
 This bit is used to enable/disable the generation of Received Data Available interrupt and the Character Timeout interrupt (if FIFOs are enabled). These are the second highest priority interrupts.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable Received Data Available interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable Received Data Available interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_FCR</name>
          <description>FIFO Control Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RT</name>
              <description>Rx Trigger
 This field is used to select the trigger level in the Rx FIFO at which the Received Data Available interrupt will be generated. In Auto Flow Control mode, it is used to determine when the RTS signal will be deasserted, but only when RTC flow-control trigger is disabled. It also determines when the DMA_RX_REQ signal will be asserted when in certain modes of operation. 
For details on DMA support, refer to Section UART DMA Requests.</description>
              <bitRange>[7:6]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1 character in FIFO</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>FIFO 1/4 full</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>FIFO 1/2 full</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>FIFO 2 characters till full</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TET</name>
              <description>Tx Empty Trigger
 This field is used to select the empty threshold level at which the THRE interrupts will be generated when the mode is active. It also determines when the DMA_TX_REQ signal will be asserted when in certain modes of operation. 
For details on DMA support, refer to Section UART DMA Requests.</description>
              <bitRange>[5:4]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>FIFO Empty</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>2 characters in FIFO</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>FIFO 1/4 full</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>FIFO 1/2 full</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>XFIFOR</name>
              <description>Tx FIFO Reset
 This bit resets the control portion of the Tx FIFO and treats the FIFO as empty. This will also deassert the DMA Tx request and single signals. Note that this bit is self-clearing.</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Tx FIFO reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFIFOR</name>
              <description>Rx FIFO Reset
This bit resets the control portion of the Rx FIFO and treats the FIFO as empty. This will also deassert the DMA Rx request and single signals. Note that this bit is self-clearing.</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Rx FIFO reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FIFOE</name>
              <description>FIFO Enable
This bit enables/disables the Tx FIFOs and Rx FIFOs. Whenever the value of this bit is changed, both the Tx FIFO and Rx FIFO control 
portion of FIFOs are reset.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>FIFO disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>FIFO enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_IIR</name>
          <description>Interrupt Identification Register</description>
          <alternateRegister>UART_FCR</alternateRegister>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FIFOSE</name>
              <description>FIFOs Enabled
This field is used to indicate whether the FIFOs are enabled or disabled.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>FIFOs are disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>FIFOs are enabled</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IID</name>
              <description>Interrupt ID
This field indicates the highest priority pending interrupt which can be one of the following types:</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Modem Status interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>No interrupt pending</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>THRE interrupt</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Received Data Available interrupt</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>Receiver Line Status interrupt</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>Character Timeout interrupt (can only occur when the FIFOs are enabled)</description>
                  <value>0xC</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_LCR</name>
          <description>Line Control Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DLAB</name>
              <description>Divisor Latch Access Bit
This bit is used to enable reading and writing of the Divisor Latch registers (UART_DLL and UART_DLH). This bit must be cleared after initial baud rate setup in order to access other registers.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Divisor Latch register is writable only when UART is not busy</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Divisor Latch register is always readable and writable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BC</name>
              <description>Break Control Bit
 This bit is used to cause a break condition to be transmitted to the receiving device. If set to 1, the UART_TX is forced to the spacing (logic 0) state. 
When not in Loopback mode, as determined by UART_MCR[LOOPBACK], the UART_TX is forced low until the bit is cleared. 
When in Loopback mode, the break condition is internally looped back to the receiver.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>UART_TX is released for data transmission</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>UART_TX is forced to spacing state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SP</name>
              <description>Stick Parity
 This bit is used to force parity value. When PEN, EPS and SP bits are set to 1, the parity bit is transmitted and checked as logic 0. 
If PEN and SP are set to 1 and EPS is a logic 0, then parity bit is transmitted and checked as a logic 1.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Stick parity disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Stick parity enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EPS</name>
              <description>Even Parity Select
 This bit is used to select between even and odd parity, when PEN set to 1. </description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>An odd parity is transmitted or checked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>An even parity is transmitted or checked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PEN</name>
              <description>Parity Enable
 This bit is used to enable/disable parity generation and detection in transmitted and received serial character, respectively.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable parity</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable parity</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STOP</name>
              <description>Number of Stop Bit
This bit is used to select the number of stop bits per character that the peripheral will transmit and receive.
 If set to 0, one stop bit is transmitted in the serial data.
 If set to 1 and the data bits are set to 5 (UART_LCR[DLS] set to 0) one and a half stop bits are transmitted. Otherwise, 2 stop bits are transmitted. 
Note that regardless of the number of stop bits selected the receiver will only check the first stop bit.
 The STOP bit duration implemented by UART may appear longer due to IDLE time inserted between characters for some configurations and baud clock divisor values in the transmit direction; for details on IDLE time between transmitted transfers, refer to Section UART Back-to-Back Character Stream Transmission</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1 stop bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>1.5 stop bits when UART_LCR[DLS] is 0, 2 stop bits otherwise</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DLS</name>
              <description>Data Length Select
 When UART_LCR_EXT[DLS_E] set to 0, this field is used to select the number of data bits per character that the peripheral will transmit and receive.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>5 data bits per character</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>6 data bits per character</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>7 data bits per character</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>8 data bits per character</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_MCR</name>
          <description>Modem Control Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AFCE</name>
              <description>Auto Flow Control Enable
 When this bit is set and FIFOs are enabled, Auto Flow Control features are enabled.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Auto Flow Control mode disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Auto Flow Control mode enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOOPBACK</name>
              <description>Loopback Bit
 This bit is used to put the UART into a diagnostic mode for test purposes. Data on the UART_TX is held high, while UART_TX is looped back to the UART_RX, internally. In this mode all the interrupts are fully functional.
 In Loopback mode, the modem control inputs are disconnected and the modem control outputs are looped back to the inputs internally.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Loopback mode disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Loopback mode enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OUT2</name>
              <description>This bit is used to directly control the internal OUT2 signal. The value written to this location is inverted and driven out on OUT2. Note that in Loopback mode (UART_MCR[LOOPBACK] set to 1), the OUT2 signal is held inactive high while the value of this location is internally looped back to an input.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>OUT2 signal deasserted (logic 1)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>OUT2 signal asserted (logic 0)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OUT1</name>
              <description>This bit is used to directly control the internal OUT1 signal. The value written to this location is inverted and driven out on OUT1. Note that in Loopback mode (UART_MCR[LOOPBACK] set to 1), the OUT1 signal is held inactive high while the value of this location is internally looped back to an input.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>OUT1 signal deasserted (logic 1)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>OUT1 signal asserted (logic 0)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RTS</name>
              <description>Request to Send
This bit is used to directly control the UART_RTS output. The RTS bit is used to inform the modem that the UART is ready to exchange data.
 When Auto Flow Control mode is not enabled (UART_MCR[AFCE] set to 0), the UART_RTS is set low by programming UART_MCR[RTS] to high. 
When both Auto Flow Control mode and FIFOs are enabled (UART_MCR[AFCE] set to 1 and UART_FCR[FIFOE] set to 1, respectively), the UART_RTS is controlled in the same way, but is also gated with the Rx FIFO threshold trigger (UART_RTS is inactive high when above the threshold). The UART_RTS output will be deasserted when UART_MCR[RTS] is set to 0. 
Note that in Loopback mode (UART_MCR[LOOPBACK] set to 1), the UART_RTS output remains held inactive high, while the value of this bit is internally looped back to an input.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>UART_RTS deasserted (logic 1)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>UART_RTS asserted (logic 0)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTR</name>
              <description>Data Terminal Ready
This bit is used to directly control the DTR output. The value written to this bit is inverted and driven out on DTR.
 The DTR output is used to inform the modem that the UART is ready to establish communications. 
Note that in Loopback mode (UART_MCR[LOOPBACK] set to 1), the DTR output is held inactive high while the value of this bit is internally looped back to an input.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DTR output deasserted (logic1)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DTR output asserted (logic 0)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_LSR</name>
          <description>Line Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000060</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_RCVD</name>
              <description>Address Received
If 9-bit data mode is enabled (UART_LCR_EXT[DLS_E] set to 1), this bit is used to indicate the 9^th bit of the receive data is set to 1. This bit can also be used to indicate whether the incoming character is address or data.
The 9^th bit, associated with a received character, is revealed when a character with the 9th bit set to 1 is at the top of the FIFO.
Reading the UART_LSR clears the 9^th bit. 
Note: Read UART_LSR register before the next address byte arrives. If there is a delay in clearing the interrupt, then software will not be able to distinguish between multiple address related interrupts.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Indicates the character is data</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Indicates the character is address</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFE</name>
              <description>Rx FIFO Error
This bit is only relevant when FIFOs are enabled (UART_FCR[FIFOE] set to 1).
 This bit is used to indicate if there is at least one parity error, framing error, or break interrupt in the FIFO.
This bit is cleared when the UART_LSR is read and the character with the error is at the top of the Rx FIFO and there are no subsequent errors in the FIFO.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error in Rx FIFO</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error in Rx FIFO</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TEMT</name>
              <description>Transmitter Empty
If FIFOs are enabled (UART_FCR[FIFOE] set to 1), this bit is set whenever the internal transmit shift register and the Tx FIFO are both empty. If the FIFOs are disabled, this bit is set whenever the UART_THR and the transmit shift register are both empty.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmitter not empty</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmitter empty</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>THRE</name>
              <description>Transmit Holding Register Empty
If THRE mode is disabled (UART_IER[PTIME] set to 0), regardless of whether FIFOs are enabled or not, this bit indicates that the UART_THR or Tx FIFO is empty.
 This bit is set whenever data is transferred from the UART_THR or Tx FIFO to the transmit shift register, and no new data has been written to the UART_THR or Tx FIFO. 
This also causes a THRE interrupt to occur, if the THRE interrupt is enabled. If both THRE Interrupt mode (UART_IER[PTIME] set to 1) and FIFOs (UART_FCR[FIFOE] set to 1) are enabled, the functionality is switched to indicate the Tx FIFO is full, and no longer controls THRE interrupts, which are then controlled by the UART_FCR[TET] threshold setting.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>THRE interrupt control is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>THRE interrupt control is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BI</name>
              <description>Break Interrupt
This bit is used to indicate the detection of a break sequence on the serial input data.
This bit is set whenever the UART_RX is held in a logic 0 state for longer than the sum of start time + data bits + parity + stop bits.
If the FIFOs are enabled, the character associated with the break condition is carried through the FIFO and is revealed when the character is at the top of the FIFO.
 Reading the UART_LSR or UART_RBR clears the BI bit.
If FIFOs are disabled, this bit is set immediately and persists until the UART_LSR is read.
Note: If a FIFO is full when a break condition is received, a FIFO overrun occurs. The break condition and all the information associated with it-parity and framing errors-is discarded; any information that a break character was received is lost.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No break sequence detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Break sequence detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FE</name>
              <description>Framing Error
This bit is used to indicate the occurrence of a framing error in the receiver. A framing error occurs when the receiver does not detect a valid STOP bit in the received data (see UART_LCR[STOP]).
If the FIFOs are enabled, the framing error is associated with a character received, it is revealed when the character with the framing error is at the top of the FIFO. When a framing error occurs, the UART will attempt to resynchronize. It does this by assuming that the error was due to the start bit of the next character and then continues receiving the other bit (data, and/or parity, and stop).
It should be noted that the UART_LSR[FE] bit will be set if a break interrupt has occurred, as indicated by the BI bit. This happens because the break character implicitly generates a framing error by holding the UART_RX to logic 0 for longer than the duration of a character.
Reading the UART_LSR or UART_RBR clears this bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No framing error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Framing error</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PE</name>
              <description>Parity Error
This bit is used to indicate the occurrence of a parity error in the receiver if the UART_LCR[PEN] bit is set.
If the FIFOs are enabled, the parity error is associated with a character received, it is revealed when the character with the parity error arrives at the top of the FIFO.
It should be noted that this bit will be set if a break interrupt has occurred, as indicated by the BI bit. In this situation, the PE bit is set if parity generation and detection is enabled (UART_LCR[PEN] is set to 1) and the parity is set to odd (UART_LCR[EPS] is set to 0).
 Reading the UART_LSR or UART_RBR clears this bit.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No parity error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Parity error</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OE</name>
              <description>Overrun Error 
This bit is used to indicate the occurrence of an overrun error. This occurs if a new data character was received before the previous data was read.
If the FIFOs are enabled, an overrun error occurs when the FIFO is full and a new character arrives at the receiver. The data in the FIFO is retained and the data in the receive shift register is lost.
 Reading the UART_LSR or UART_RBR clears this bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No overrun error </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Overrun error</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DR</name>
              <description>Data Ready 
This bit is used to indicate that the receiver contains at least one character in the UART_RBR or the receiver FIFO. This bit is cleared when the UART_RBR is read (if FIFOs are disabled) or when the receiver FIFO is empty (if FIFOs are enabled).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No data ready </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Data ready</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_MSR</name>
          <description>Modem Status Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DCD</name>
              <description>Data Carrier Detect
This bit is used to indicate the current state of the modem control
 line DCD. When the Data Carrier Detect input (DCD) is asserted, it
 indicates that the carrier has been detected by the modem or 
data set.
In Loopback mode (UART_MCR[LOOPBACK] set to 1), DCD is the same as UART_MCR[OUT2] bit.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DCD input is deasserted (logic 1)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DCD input is asserted (logic 0)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RI</name>
              <description>Ring Indicator
This bit is used to indicate the current state of the modem control line RI. When this bit is asserted, it indicates that a telephone ringing signal has been received by the modem data set.
In Loopback mode (UART_MCR[LOOPBACK] set to 1), RI is the same as UART_MCR[OUT1].</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RI input is deasserted (logic 1)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RI input is asserted (logic 0)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSR</name>
              <description>Data Set Ready
This bit is used to indicate the current state of the modem control line DSR. When this bit is asserted, it indicates that the modem or data set is ready to establish communications with the UART.
In Loopback mode (UART_MCR[LOOPBACK] set to 1), DSR is the same as UART_MCR[DTR].</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DSR input is deasserted (logic 1)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DSR input is asserted (logic 0)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CTS</name>
              <description>Clear to Send
This bit is used to indicate the current state of the modem control line CTS. When this bit is asserted, it indicates that the modem or data set is ready to exchange data with the UART.
In Loopback mode (UART_MCR[LOOPBACK] set to 1), CTS is the same as UART_MCR[RTS].</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>CTS input is deasserted (logic 1)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CTS input is asserted (logic 0)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DDCD</name>
              <description>Delta Data Carrier Detect
This bit is used to indicate that the modem control line DCD has changed since the last time the UART_MSR was read.
Reading the UART_MSR clears the DDCD bit. In Loopback mode (UART_MCR[LOOPBACK] set to 1), DDCD reflects changes on UART_MCR[OUT2].
Note: If the DDCD bit is not set and the DCD signal is asserted (low) and a reset occurs, then the DDCD bit will get set when the reset is removed, provided that the DCD signal remains asserted.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No change on DCD since last read of UART_MSR</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Change on DCD since last read of UART_MSR</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TERI</name>
              <description>Trailing Edge of Ring Indicator
This bit is used to indicate that a change on the input RI (from an active low, to an inactive high state) has occurred since the last time the UART_MSR was read.
Reading the UART_MSR clears the TERI bit. In Loopback mode (UART_MCR[LOOPBACK] set to 1), this bit reflects a change in state from high to low for UART_MCR[OUT1].</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No change on RI since last read of UART_MSR</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Change on RI since last read of UART_MSR</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DDSR</name>
              <description>Delta Data Set Ready
This bit is used to indicate that the modem control line DSR has changed since the last time the UART_MSR was read.
Reading the UART_MSR clears the DDSR bit. In Loopback mode (UART_MCR[LOOPBACK] set to 1), DDSR reflects changes on UART_MCR[DTR].
Note: If the DDSR bit is not set and the DSR signal is asserted (low) and a reset occurs, then the DDSR bit will be set when the reset is removed if the DSR signal remains asserted.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No change on DSR since last read of UART_MSR</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Change on DSR since last read of UART_MSR</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DCTS</name>
              <description>Delta Clear to Send
This bit is used to indicate that the modem control line CTS has changed since the last time the UART_MSR was read.
Reading the UART_MSR clears the DCTS bit. In Loopback mode (UART_MCR[LOOPBACK] set to 1), DCTS reflects changes on UART_MCR[RTS].
Note: If the DCTS bit is not set and the CTS signal is asserted (low) and a reset occurs, then the DCTS bit will be set when the reset is removed if the CTS signal remains asserted.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No change on CTS since last read of UART_MSR</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Change on CTS since last read of UART_MSR</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_SCR</name>
          <description>Scratchpad Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCR</name>
              <description>This field is used as a temporary storage space. It has no defined purpose in the UART.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>UART_SRBR[%s]</name>
          <description>Shadow Receive Buffer Register (n)</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SRBRN</name>
              <description>This is a shadow field for the UART_RBR[RBR] field and has been allocated sixteen 32-bit locations to accommodate burst accesses from the master. This field contains the data byte received on the UART_RX. The data in this field is valid only if the UART_LSR[DR] bit is set.
If FIFOs are disabled (UART_FCR[FIFOE] set to 0), the data in the UART_RBR[RBR] must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error.
If FIFOs are enabled (UART_FCR[FIFOE] set to 1), this register accesses the head of the Rx FIFO. If the Rx FIFO is full and this field is not read before the next data character arrives, then the data already in the FIFO will be preserved, but any incoming data will be lost. An overrun error will also occur.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>UART_STHR[%s]</name>
          <description>Shadow Transmit Holding Register (n)</description>
          <alternateRegister>UART_SRBR[%s]</alternateRegister>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STHRN</name>
              <description>This is a shadow field for the UART_THR[THR] and has been allocated sixteen 32-bit locations to accommodate burst accesses from the master. This field contains data to be transmitted on the UART_TX. Data should only be written to the UART_THR when the UART_LSR[THRE] bit is set.
If FIFOs are disabled (UART_FCR[FIFOE] set to 0) and UART_LSR[THRE] is set, writing a single character to the UART_THR[THR] clears the UART_LSR[THRE]. Any additional writes to the UART_THR[THR] before the UART_LSR[THRE] is set again causes the UART_THR[THR] data to be overwritten.
If FIFOs are enabled (UART_FCR[FIFOE] set to 1) and UART_LSR[THRE] is set, 32 data characters may be written to the UART_THR[THR] before the FIFO is full. Any attempt to write data when the FIFO is full results in the write data being lost.</description>
              <bitRange>[8:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_FAR</name>
          <description>FIFO Access Register</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FAR</name>
              <description>This bit is used to enable a FIFO access mode for testing, so that the Rx FIFO can be written and the Tx FIFO can be read by the master when FIFOs are enabled. When FIFOs are not enabled, it allows the UART_RBR[RBR] to be written by the master and the UART_THR[THR] to be read by the master.
Note: When the FIFO access mode is enabled/disabled, the control portion of the Rx FIFO and Tx FIFO is reset and the FIFOs are treated as empty.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>FIFO access mode disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>FIFO access mode enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_TFR</name>
          <description>Tx FIFO Read Register</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TFR</name>
              <description>This field is only valid when FIFO access mode is enabled (UART_FAR[FAR] set to 1).
When FIFOs are enabled, reading this field gives the data at the top of the Tx FIFO. Each consecutive read pops the Tx FIFO and gives the next data value that is currently at the top of the FIFO.
When FIFOs are not enabled, reading this field gives the data in the UART_THR[THR] field.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RFW</name>
          <description>Rx FIFO Write Register</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFFE</name>
              <description>Rx FIFO Framing Error
 When FIFOs are enabled, this bit is used to write framing error detection information to the Rx FIFO. 
When FIFOs are not enabled, this bit is used to write framing error detection information to the UART_RBR[RBR].</description>
              <bitRange>[9:9]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Frame error disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Frame error enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFPE</name>
              <description>Rx FIFO Parity Error
 When FIFOs are enabled, this bit is used to write parity error detection information to the Rx FIFO.
When FIFOs are not enabled, this bit is used to write parity error detection information to the UART_RBR[RBR].</description>
              <bitRange>[8:8]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Parity error disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Parity error enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFWD</name>
              <description>Rx FIFO Write Data
 When FIFOs are enabled, the data that is written to this field is pushed into the Rx FIFO. Each consecutive write pushes the new data to the next write location in the Rx FIFO. 
When FIFOs are not enabled, the data that is written to this field is pushed into the UART_RBR[RBR].</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_USR</name>
          <description>UART Status Register</description>
          <addressOffset>0x7C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000006</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFF</name>
              <description>Rx FIFO Full
This bit is used to indicate that the Rx FIFO is completely full. This bit is cleared when the Rx FIFO is no longer full.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Rx FIFO is not full</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Rx FIFO is full</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFNE</name>
              <description>Rx FIFO Not Empty
This bit is used to indicate that the Rx FIFO contains one or more entries. This bit is cleared when the Rx FIFO is empty.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Rx FIFO is empty</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Rx FIFO is not empty</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TFE</name>
              <description>Tx FIFO Empty
 This bit is used to indicate that the Tx FIFO is completely empty. This bit is cleared when the Tx FIFO is no longer empty.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Tx FIFO is not empty</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Tx FIFO is empty</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TFNF</name>
              <description>Tx FIFO Not Full
This bit is used to indicate that the Tx FIFO is not full. This bit is cleared when the Tx FIFO is full.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Tx FIFO is full</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Tx FIFO is not full</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_TFL</name>
          <description>Tx FIFO Level Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TFL</name>
              <description>Transmit FIFO Level
This field indicates the number of data entries in the Tx FIFO.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RFL</name>
          <description>Rx FIFO Level Register</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFL</name>
              <description>Receive FIFO Level
This field indicates the number of data entries in the Rx FIFO.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_SRR</name>
          <description>Software Reset Register</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>XFR</name>
              <description>Tx FIFO Reset
 This is a shadow bit for the UART_FCR[XFIFOR] bit. It is used to remove the burden on software of having to store previously written UART_FCR values just to reset the Tx FIFO. This resets the control portion of the Tx FIFO and treats the FIFO as empty. This will also deassert the DMA Tx request and single signals. Note that this bit is self-clearing.</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>RFR</name>
              <description>Rx FIFO Reset
 This is a shadow bit for the UART_FCR[RFIFOR] bit. It is used to remove the burden on software of having to store previously written UART_FCR values just to reset the Rx FIFO. This resets the control portion of the Rx FIFO and treats the FIFO as empty. This will also deassert the DMA Rx request and single signals. Note that this bit is self-clearing.</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>UR</name>
              <description>UART Reset
This bit asynchronously resets the UART and synchronously removes the reset assertion. Both PCLK and SCLK (UART only) will be reset.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No UART reset</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>UART reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_SRTS</name>
          <description>Shadow Request to Send Register</description>
          <addressOffset>0x8C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SRTS</name>
              <description>This is a shadow bit for the UART_MCR[RTS] bit, used to remove the burden of having to perform a read / modify write on the UART_MCR. This is used to directly control the UART_RTS output. The UART_RTS is used to inform the modem or data set that the UART is ready to exchange data.
When UART_MCR[AFCE] bit is set to 0, the UART_RTS output is set low by programming UART_MCR[RTS] to a high.
When UART_MCR[AFCE] bit is set to 1 and UART_FCR[FIFOE] set to 1, the UART_RTS signal is controlled in the same way, but is also gated with the Rx FIFO threshold trigger (UART_RTS signal is in active high when above the threshold) only when RTC flow-control trigger is disabled; otherwise it is gated by the Rx FIFO almost-full trigger, where almost full refers to two available slots in the FIFO (UART_RTS signal is in active high when above the threshold).
Note: In Loopback mode (UART_MCR[LOOPBACK] bit set to 1), the UART_RTS signal is held in active high while the value of this bit is internally looped back to an input.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Shadow UART_RTS logic 1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Shadow UART_RTS logic 0</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_SBCR</name>
          <description>Shadow Break Control Register</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SBCB</name>
              <description>This is a shadow bit for the UART_LCR[BC] bit, used to remove the burden of having to perform a read / modify write on the UART_LCR. It is used to cause a break condition to be transmitted to the receiving device. If SBCB is set to 1 the UART_TX signal is forced to the spacing (logic 0) state. 
When not in Loopback mode (UART_MCR[LOOPBACK] set to 0), the UART_TX signal is forced low until the UART_LCR[BC] bit is cleared.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No spacing on UART_TX signal </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>UART_TX forced to the spacing</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_SFE</name>
          <description>Shadow FIFO Enable Register</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SFE</name>
              <description>This is a shadow bit for the UART_FCR[FIFOE] bit. It is used to remove the burden of having to store the previously written value to the UART_FCR in memory and and masking it, so that only the UART_FCR[FIFOE] bit gets updated. 
This enables/disables the Tx and Rx FIFOs. If this bit is set to 0 after being enabled then both the Tx and Rx control portion of FIFOs will be reset.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>FIFOs are disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>FIFOs are enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_SRT</name>
          <description>Shadow RCVR Trigger Register</description>
          <addressOffset>0x9C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SRT</name>
              <description>This is a shadow field for the UART_FCR[RT] field. It is used to remove the burden of having to store the previously written value to the UART_FCR[RT] in memory and and masking it, so that only the UART_FCR[RT] bit gets updated.
SRT is used to select the trigger level in the Rx FIFO at which the Received Data Available interrupt will be generated.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1 character in FIFO</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>FIFO 1/4 full</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>FIFO 1/2 full</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>FIFO 2 less than full</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_STET</name>
          <description>Shadow Tx Empty Trigger Register</description>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STET</name>
              <description>This is a shadow field for the UART_FCR[TET] field. It is used to remove the burden of having to store the previously written value to the UART_FCR[TET] in memory and and masking it, so that only the UART_FCR[TET] bit gets updated. STET is used to select the empty threshold level at which the THRE interrupts will be generated when the mode is active.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>FIFO empty</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>2 characters in FIFO</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>FIFO 1/4 full</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>FIFO 1/2 full</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_HTX</name>
          <description>Halt Tx Register</description>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HTX</name>
              <description>This bit is used to halt transmissions for testing, so that the Tx FIFO is filled by the master when FIFOs are enabled.
Note: If FIFOs are not enabled the setting of this bit will have no effect on operation.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Halt transmission disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Halt transmission enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_DMASA</name>
          <description>DMA Software Acknowledge Register</description>
          <addressOffset>0xA8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMASA</name>
              <description>This bit is used to perform DMA software acknowledge if a transfer needs to be terminated due to an error condition. 
For example, if the DMA disables the channel, then the UART should clear its request. This will cause the Tx request, Tx single, Rx request and Rx single signals to deassert. 
Note: This bit is self-clearing.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA software acknowledge</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_TCR</name>
          <description>Transceiver Control Register</description>
          <addressOffset>0xAC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>XFER_MODE</name>
              <description>Transfer Mode
Hardware will consider the Turnaround timings programmed in the UART_TAT register while switching from RE to DE, or DE to RE. For transmission hardware will wait if it is in middle of receiving any transfer, before it starts transmitting.
Once the Tx FIFO becomes empty, RE signal gets enabled and DE signal will be disabled. Hardware will consider the Turnaround timings which are programmed in the UART_TAT register while switching from RE to DE or DE to RE. The DE and RE signals are strictly complementary to each other.</description>
              <bitRange>[4:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>In this mode, transmit and receive can happen simultaneously. UART_DE_EN[DE_ENABLE], UART_RE_EN[RE_ENABLE] can be enabled at any point of time. Turnaround timing as programmed in the UART_TAT register is not applicable in this mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>In this mode, DE and RE are mutually exclusive. Either DE or RE is expected to be enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description> In this mode, DE and RE are mutually exclusive. Once UART_DE_EN/UART_RE_EN register is set-by default RE will be enabled and UART controller will be ready to receive. If the SW programs the Tx FIFO with the data, then UART (after ensuring no receive is in progress), disables RE and enables DE signal.</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DE_POL</name>
              <description>Driver Enable Polarity</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DE signal is active low</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DE signal is active high</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RE_POL</name>
              <description>Receiver Enable Polarity
NOTE: The reset value for UART is 0x0, and for LPUART it is 0x1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RE signal is active low</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RE signal is active high</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RS485_EN</name>
              <description>RS485 Transfer Enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The transfers will happen in RS485 mode. All other fields of this register are applicable.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_DE_EN</name>
          <description>Driver Output Enable Register</description>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DE_ENABLE</name>
              <description>This bit is used to control assertion and deassertion of DE signal.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description> Deassert DE signal</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Assert DE signal</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RE_EN</name>
          <description>Receiver Output Enable Register</description>
          <addressOffset>0xB4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RE_ENABLE</name>
              <description>This bit is used to control assertion and deassertion of RE signal.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Deassert RE signal</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Assert RE signal</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_DET</name>
          <description>Driver Output Enable Timing Register</description>
          <addressOffset>0xB8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DE_DE_ASSERTION_TIME</name>
              <description>Driver Enable Deassertion Time
This field controls the amount of time (in terms of number of SCLK periods) between the end of the stop bit on the UART_TX signal to the falling edge of DE signal.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DE_ASSERTION_TIME</name>
              <description>Driver Enable Assertion Time
This field controls the amount of time (in terms of number of SCLK periods) between the assertion of rising edge of DE signal to serial transmit enable. Any data in transmit buffer, will start on UART_TX signal after the transmit enable.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_TAT</name>
          <description>Turnaround Timing Register</description>
          <addressOffset>0xBC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RE_TO_DE</name>
              <description>Receiver Enable to Driver Enable Turnaround time
Turnaround time (in terms of SCLK) for RE deassertion to DE assertion:
 - If the UART_DET[DE_ASSERTION_TIME] field is 0, then the actual value is the programmed value + 3. 
- If the UART_DET[DE_ASSERTION_TIME] field is 1, then the actual value is the programmed value + 2. 
- If the UART_DET[DE_ASSERTION_TIME] field is greater than 1, then the actual value is the programmed value + 1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DE_TO_RE</name>
              <description>Driver Enable to Receiver Enable TurnAround time.
Turnaround time (in terms of SCLK) for DE Deassertion to RE assertion:
The actual time is the programmed value + 1.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_DLF</name>
          <description>Divisor Latch Fraction Register</description>
          <addressOffset>0xC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DLF</name>
              <description>This field defines the fractional value that is added to the integer value set by UART_DLH, UART_DLL.
 Fractional value = DLF / 2^DLF_SIZE, where DLF_SIZE = 4.
For more information, see Section UART Fractional Baud Rate Support.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RAR</name>
          <description>Receive Address Register</description>
          <addressOffset>0xC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RAR</name>
              <description>This field is an address matching field during Receive mode. If the 9^th bit is set in the incoming character, then the remaining 8-bits will be checked against this field value. If the match happens, then sub-sequent characters with 9^th bit set to 0 will be treated as data byte until the next address byte is received.
 This field is applicable only when UART_LCR_EXT[ADDR_MATCH] and UART_LCR_EXT[DLS_E] bits are set to 1.
RAR can be programmed at any point of the time. However, it must not be changed during any receive is in progress.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_TAR</name>
          <description>Transmit Address Register</description>
          <addressOffset>0xC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TAR</name>
              <description>This field is an address matching field during Transmit mode. If UART_LCR_EXT[DLS_E] bit is enabled, then UART will send the 9-bit character with 9^th bit set to 1, and remaining 8-bit address will be sent from this field, provided UART_LCR_EXT[SEND_ADDR] bit set to 1.
This field is used only to send the address. The normal data should be sent by programming UART_THR[THR] field.
Once the address starts to be send on the UART serial lane, then UART_LCR_EXT[SEND_ADDR] bit will be auto-cleared.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_LCR_EXT</name>
          <description>Line Extended Control Register</description>
          <addressOffset>0xCC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRANSMIT_MODE</name>
              <description>Transmit Mode Control
This bit is used to control the type of Transmit mode during 9-bit data transfers.
Ensure that the UART_THR/UART_STHRn registers are written correctly for address/data: 
- Address: 9^th bit set to 1
- Data: 9^th bit set to 0
Note: In this mode of operation: 
- UART_TAR[TAR] field is not applicable
- UART_DLH and UART_DLL are always readable and writable</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>In this mode of operation, UART_THR[THR] field and fields of UART_STHRn registers are 8-bitwide. Program the address into UART_TAR[TAR] field and data intothe UART_THR/UART_STHRn registers. The UART_LCR_EXT[SEND_ADDR] bit is used as a control knob to indicate the UART when to send the address.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>In this mode of operation, UART_THR[THR] field and fields of UART_STHRn registers are 9-bitwide. </description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEND_ADDR</name>
              <description>Send Address Control
This bit is used as a control knob to determine when to send the address during Transmit mode.
This bit is auto-cleared after sending out the address character.
This field is applicable only when UART_LCR_EXT[DLS_E] bit is set to 1 and UART_LCR_EXT[TRANSMIT_MODE] is set to 0.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>9-bit character will be transmitted with 9^th bit set to 0 and the remaining 8-bits will be taken from the Tx FIFO which is programmed through 8-bit wide UART_THR/UART_STHRn registers.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>9-bit character will be transmitted with 9^th bit set to 1 and the remaining 8-bits will match to what is being programmed in UART_TAR register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADDR_MATCH</name>
              <description>Address Match Mode 
This bit is used to enable the address match feature during Receive mode.
This bit is applicable only when UART_LCR_EXT[DLS_E] is set to 1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Normal mode. The UART will start to receive the data and 9-bit character will be formed and written into the receive Rx FIFO. User is responsible to read the data and differentiate address and data.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Address match mode. The UART will wait until the incoming character with 9^th bit set to 1 and then checks if the address matches the one programmed in the UART_RAR register. If match is found, then sub-sequent characters will be treated as valid data and UART starts receiving data.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DLS_E</name>
              <description>Extension for DLS
This bit is used to enable 9-bit data for transmit and receive transfers.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_REG_TIMEOUT_RST</name>
          <description>Timeout Counter Reset Value Register</description>
          <addressOffset>0xD4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000008</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REG_TIMEOUT_RST</name>
              <description>This field holds reset value of the register timeout counter.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_CPR</name>
          <description>Module Configuration Register</description>
          <addressOffset>0xF4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00023F32</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FIFO_MODE</name>
              <description>The value of this field defines the FIFO mode.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>FIFO depth is 32</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DMA_EXTRA</name>
              <description>The value of this bit defines the DMA interface.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA interface enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UART_ADD_ENCODED_PARAMS</name>
              <description>The value of this bit determines whether encoded information about module configuration settings can be read.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The encoded information can be read</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SHADOW</name>
              <description>The value of this bit determines the availability of shadow registers.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Shadow registers are available</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FIFO_STAT</name>
              <description>The value of this bit defines the availability of FIFO status registers</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>FIFO status registers are available</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FIFO_ACCESS</name>
              <description>The value of this bit determines whether the UART has programmable FIFO access mode.
NOTE: The reset value for UART is 0x1, and for LPUART it is 0x0.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>FIFO ACCESS enabled (UART only)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>FIFO ACCESS disabled (LPUART only)</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADDITIONAL_FEAT</name>
              <description>The value of this bit defines the additional features.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Additional features enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SIR_LP_MODE</name>
              <description>The value of this bit defines the SIR low power mode.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SIR_LP mode disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SIR_MODE</name>
              <description>The value of this bit defines the SIR mode.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SIR mode disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>THRE_MODE</name>
              <description>The value of this bit defines the THRE mode.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>THRE mode enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AFCE_MODE</name>
              <description>The value of this bit defines the AFCE mode.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>AFCE mode enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>APB_DATA_WIDTH</name>
              <description>The value of this field defines the APB data width.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>APB data width is 32 bits</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_UCV</name>
          <description>Component Version Register</description>
          <addressOffset>0xF8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x3430322A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UART_COMPONENT_VERSION</name>
              <description>Component version
NOTE: The reset value for UART is 0x3430322A, and for LPUART it is 0x3430332A.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_CTR</name>
          <description>Component Type Register</description>
          <addressOffset>0xFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x44570110</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PERIPHERAL_ID</name>
              <description>Component type</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPI2C0</name>
      <baseAddress>0x43009000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>36</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>LPI2C_DATA</name>
          <description>Read/Write Data Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>If the corresponding FIFO is not empty/full, a byte of data can be read/written to this address. From FIFO's perspective, it would be like a pop/push operation.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPI2C_INFIFO_STATUS</name>
          <description>Inbound FIFO Status Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000020</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WEMPTY</name>
              <description>This field shows if the inbound FIFO is empty.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not empty</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Empty</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WFULL</name>
              <description>This field shows if the inbound FIFO is full.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not full</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Full</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WSIZE</name>
              <description>This field shows the number of available bytes of data in the inbound FIFO.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPI2C_OUTFIFO_STATUS</name>
          <description>Outbound FIFO Status Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000020</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMPTY</name>
              <description>This field shows if the outbound FIFO is empty.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not empty</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Empty</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFULL</name>
              <description>This field shows if the outbound FIFO is full.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not full</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Full</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RSIZE</name>
              <description>This field shows the number of bytes of data in the outbound FIFO to be transmitted.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="LPGPIO">
      <name>GPIO16</name>
      <baseAddress>0x4300A000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LPGPIO">
      <name>GPIO17</name>
      <baseAddress>0x4300B000</baseAddress>
    </peripheral>
    <peripheral>
      <name>LPUTIMER</name>
      <groupName>UTIMER</groupName>
      <baseAddress>0x4300C000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65848</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>UTIMER_GLB_CNTR_START</name>
          <description>Channels Global Counter Start Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHANNEL_NUM</name>
              <description>Write 1 to start the associated channel counter.</description>
              <bitRange>[15:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UTIMER_GLB_CNTR_STOP</name>
          <description>Channels Global Counter Stop Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHANNEL_NUM</name>
              <description>Write 1 to stop the associated channel counter.</description>
              <bitRange>[15:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UTIMER_GLB_CNTR_CLEAR</name>
          <description>Channels Global Counter Clear Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHANNEL_NUM</name>
              <description>Write 1 to clear the associated channel counter.</description>
              <bitRange>[15:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UTIMER_GLB_CNTR_RUNNING</name>
          <description>Channels Global Counter Running Status Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHANNEL_NUM</name>
              <description>Real-time running status of each channel.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UTIMER_GLB_DRIVER_OEN</name>
          <description>Channels Driver Output Enable Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DRIVER_OEN_11</name>
              <description>Channel 11 active low output enable controls for driver A and B. B is the upper bit, A is the lower bit.</description>
              <bitRange>[23:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DRIVER_OEN_10</name>
              <description>Channel 10 active low output enable controls for driver A and B. B is the upper bit, A is the lower bit.</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DRIVER_OEN_9</name>
              <description>Channel 9 active low output enable controls for driver A and B. B is the upper bit, A is the lower bit.</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DRIVER_OEN_8</name>
              <description>Channel 8 active low output enable controls for driver A and B. B is the upper bit, A is the lower bit.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DRIVER_OEN_7</name>
              <description>Channel 7 active low output enable controls for driver A and B. B is the upper bit, A is the lower bit.</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DRIVER_OEN_6</name>
              <description>Channel 6 active low output enable controls for driver A and B. B is the upper bit, A is the lower bit.</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DRIVER_OEN_5</name>
              <description>Channel 5 active low output enable controls for driver A and B. B is the upper bit, A is the lower bit.</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DRIVER_OEN_4</name>
              <description>Channel 4 active low output enable controls for driver A and B. B is the upper bit, A is the lower bit.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DRIVER_OEN_3</name>
              <description>Channel 3 active low output enable controls for driver A and B. B is the upper bit, A is the lower bit.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DRIVER_OEN_2</name>
              <description>Channel 2 active low output enable controls for driver A and B. B is the upper bit, A is the lower bit.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DRIVER_OEN_1</name>
              <description>Channel 1 active low output enable controls for driver A and B. B is the upper bit, A is the lower bit.</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DRIVER_OEN_0</name>
              <description>Channel 0 active low output enable controls for driver A and B. B is the upper bit, A is the lower bit.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UTIMER_GLB_CLOCK_ENABLE</name>
          <description>Channels Clock Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHANNEL_NUM</name>
              <description>Clock control for each channel.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>16</dim>
          <dimIncrement>4096</dimIncrement>
          <name>UTIMER_CHANNEL_CFG[%s]</name>
          <addressOffset>0x1000</addressOffset>
          <register>
            <name>UTIMER_START_0_SRC</name>
            <description>Channel (n) Counter Start Source 0 Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRIG15_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 15 causes counter to start.
For QEC channels: Reserved, not used.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG15_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 15 causes counter to start.
For QEC channels: Reserved, not used.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG14_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 14 causes counter to start.
For QEC channels: Reserved, not used.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG14_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 14 causes counter to start.
For QEC channels: Reserved, not used.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG13_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 13 causes counter to start.
For QEC channels: Reserved, not used.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG13_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 13 causes counter to start.
For QEC channels: Reserved, not used.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG12_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 12 causes counter to start.
For QEC channels: Reserved, not used.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG12_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 12 causes counter to start.
For QEC channels: Reserved, not used.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG11_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 11 causes counter to start.
For QEC channels: Falling edge of QEC_TRIGGER11 causes counter to start.</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG11_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 11 causes counter to start.
For QEC channels: Rising edge of QEC_TRIGGER11 causes counter to start.</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG10_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 10 causes counter to start.
For QEC channels: Falling edge of QEC_TRIGGER10 causes counter to start.</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG10_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 10 causes counter to start.
For QEC channels: Rising edge of QEC_TRIGGER10 causes counter to start.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG9_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 9 causes counter to start.
For QEC channels: Falling edge of QEC_TRIGGER9 causes counter to start.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG9_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 9 causes counter to start.
For QEC channels: Rising edge of QEC_TRIGGER9 causes counter to start.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG8_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 8 causes counter to start.
For QEC channels: Falling edge of QEC_TRIGGER8 causes counter to start.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG8_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 8 causes counter to start.
For QEC channels: Rising edge of QEC_TRIGGER8 causes counter to start.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG7_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 7 causes counter to start.
For QEC channels: Falling edge of QEC_TRIGGER7 causes counter to start.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG7_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 7 causes counter to start.
For QEC channels: Rising edge of QEC_TRIGGER7 causes counter to start.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG6_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 6 causes counter to start.
For QEC channels: Falling edge of QEC_TRIGGER6 causes counter to start.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG6_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 6 causes counter to start.
For QEC channels: Rising edge of QEC_TRIGGER6 causes counter to start.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG5_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 5 causes counter to start.
For QEC channels: Falling edge of QEC_TRIGGER5 causes counter to start.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG5_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 5 causes counter to start.
For QEC channels: Rising edge of QEC_TRIGGER5 causes counter to start.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG4_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 4 causes counter to start.
For QEC channels: Falling edge of QEC_TRIGGER4 causes counter to start.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG4_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 4 causes counter to start.
For QEC channels: Rising edge of QEC_TRIGGER4 causes counter to start.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG3_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 3 causes counter to start.
For QEC channels: Falling edge of QEC_TRIGGER3 causes counter to start.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG3_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 3 causes counter to start.
For QEC channels: Rising edge of QEC_TRIGGER3 causes counter to start.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG2_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 2 causes counter to start.
For QEC channels: Falling edge of QEC_TRIGGER2 causes counter to start.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG2_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 2 causes counter to start.
For QEC channels: Rising edge of QEC_TRIGGER2 causes counter to start.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG1_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 1 causes counter to start.
For QEC channels: Falling edge of QEC_TRIGGER1 causes counter to start.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG1_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 1 causes counter to start.
For QEC channels: Rising edge of QEC_TRIGGER1 causes counter to start.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG0_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 0 causes counter to start.
For QEC channels: Falling edge of QEC_TRIGGER0 causes counter to start.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG0_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 0 causes counter to start.
For QEC channels: Rising edge of QEC_TRIGGER0 causes counter to start.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_START_1_SRC</name>
            <description>Channel (n) Counter Start Source 1 Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PGM_EN</name>
                <description>Programatic Start Enabled:</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Global programmatic start is disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Global programmatic start is enabled (only for start, stop, and clear).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DRIVE_B_FALLING_A_1</name>
                <description>For this channel, channel input B is falling and channel input A = 1 causes counter to start.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_B_FALLING_A_0</name>
                <description>For this channel, channel input B is falling and channel input A = 0 causes counter to start.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_B_RISING_A_1</name>
                <description>For this channel, channel input B is rising and channel input A = 1 causes counter to start.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_B_RISING_A_0</name>
                <description>For this channel, channel input B is rising and channel input A = 0 causes counter to start.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_FALLING_B_1</name>
                <description>For this channel, channel input A is falling and channel input B = 1 causes counter to start.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_FALLING_B_0</name>
                <description>For this channel, channel input A is falling and channel input B = 0 causes counter to start.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_RISING_B_1</name>
                <description>For this channel, channel input A is rising and channel input B = 1 causes counter to start.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_RISING_B_0</name>
                <description>For this channel, channel input A is rising and channel input B = 0 causes counter to start.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_STOP_0_SRC</name>
            <description>Channel (n) Counter Stop Source 0 Register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRIG15_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 15 causes counter to stop.
For QEC channels: Reserved, not used.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG15_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 15 causes counter to stop.
For QEC channels: Reserved, not used.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG14_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 14 causes counter to stop.
For QEC channels: Reserved, not used.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG14_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 14 causes counter to stop.
For QEC channels: Reserved, not used.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG13_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 13 causes counter to stop.
For QEC channels: Reserved, not used.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG13_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 13 causes counter to stop.
For QEC channels: Reserved, not used.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG12_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 12 causes counter to stop.
For QEC channels: Reserved, not used.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG12_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 12 causes counter to stop.
For QEC channels: Reserved, not used.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG11_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 11 causes counter to stop.
For QEC channels: Falling edge of QEC_TRIGGER11 causes counter to stop.</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG11_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 11 causes counter to stop.
For QEC channels: Rising edge of QEC_TRIGGER11 causes counter to stop.</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG10_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 10 causes counter to stop.
For QEC channels: Falling edge of QEC_TRIGGER10 causes counter to stop.</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG10_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 10 causes counter to stop.
For QEC channels: Rising edge of QEC_TRIGGER10 causes counter to stop.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG9_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 9 causes counter to stop.
For QEC channels: Falling edge of QEC_TRIGGER9 causes counter to stop.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG9_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 9 causes counter to stop.
For QEC channels: Rising edge of QEC_TRIGGER9 causes counter to stop.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG8_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 8 causes counter to stop.
For QEC channels: Falling edge of QEC_TRIGGER8 causes counter to stop.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG8_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 8 causes counter to stop.
For QEC channels: Rising edge of QEC_TRIGGER8 causes counter to stop.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG7_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 7 causes counter to stop.
For QEC channels: Falling edge of QEC_TRIGGER7 causes counter to stop.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG7_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 7 causes counter to stop.
For QEC channels: Rising edge of QEC_TRIGGER7 causes counter to stop.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG6_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 6 causes counter to stop.
For QEC channels: Falling edge of QEC_TRIGGER6 causes counter to stop.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG6_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 6 causes counter to stop.
For QEC channels: Rising edge of QEC_TRIGGER6 causes counter to stop.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG5_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 5 causes counter to stop.
For QEC channels: Falling edge of QEC_TRIGGER5 causes counter to stop.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG5_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 5 causes counter to stop.
For QEC channels: Rising edge of QEC_TRIGGER5 causes counter to stop.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG4_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 4 causes counter to stop.
For QEC channels: Falling edge of QEC_TRIGGER4 causes counter to stop.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG4_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 4 causes counter to stop.
For QEC channels: Rising edge of QEC_TRIGGER4 causes counter to stop.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG3_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 3 causes counter to stop.
For QEC channels: Falling edge of QEC_TRIGGER3 causes counter to stop.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG3_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 3 causes counter to stop.
For QEC channels: Rising edge of QEC_TRIGGER3 causes counter to stop.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG2_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 2 causes counter to stop.
For QEC channels: Falling edge of QEC_TRIGGER2 causes counter to stop.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG2_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 2 causes counter to stop.
For QEC channels: Rising edge of QEC_TRIGGER2 causes counter to stop.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG1_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 1 causes counter to stop.
For QEC channels: Falling edge of QEC_TRIGGER1 causes counter to stop.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG1_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 1 causes counter to stop.
For QEC channels: Rising edge of QEC_TRIGGER1 causes counter to stop.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG0_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 0 causes counter to stop.
For QEC channels: Falling edge of QEC_TRIGGER0 causes counter to stop.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG0_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 0 causes counter to stop.
For QEC channels: Rising edge of QEC_TRIGGER0 causes counter to stop.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_STOP_1_SRC</name>
            <description>Channel (n) Counter Stop Source 1 Register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PGM_EN</name>
                <description>Programatic Stop Enabled:</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Global programmatic stop is disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Global programmatic stop is enabled (only for start, stop, and clear).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DRIVE_B_FALLING_A_1</name>
                <description>For this channel, channel input B is falling and channel input A = 1 causes counter to stop.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_B_FALLING_A_0</name>
                <description>For this channel, channel input B is falling and channel input A = 0 causes counter to stop.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_B_RISING_A_1</name>
                <description>For this channel, channel input B is rising and channel input A = 1 causes counter to stop.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_B_RISING_A_0</name>
                <description>For this channel, channel input B is rising and channel input A = 0 causes counter to stop.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_FALLING_B_1</name>
                <description>For this channel, channel input A is falling and channel input B = 1 causes counter to stop.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_FALLING_B_0</name>
                <description>For this channel, channel input A is falling and channel input B = 0 causes counter to stop.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_RISING_B_1</name>
                <description>For this channel, channel input A is rising and channel input B = 1 causes counter to stop.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_RISING_B_0</name>
                <description>For this channel, channel input A is rising and channel input B = 0 causes counter to stop.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CLEAR_0_SRC</name>
            <description>Channel (n) Counter Clear Source 0 Register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRIG15_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 15 causes counter to clear.
For QEC channels: Reserved, not used.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG15_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 15 causes counter to clear.
For QEC channels: Reserved, not used.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG14_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 14 causes counter to clear.
For QEC channels: Reserved, not used.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG14_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 14 causes counter to clear.
For QEC channels: Reserved, not used.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG13_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 13 causes counter to clear.
For QEC channels: Reserved, not used.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG13_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 13 causes counter to clear.
For QEC channels: Reserved, not used.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG12_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 12 causes counter to clear.
For QEC channels: Reserved, not used.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG12_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 12 causes counter to clear.
For QEC channels: Reserved, not used.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG11_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 11 causes counter to clear.
For QEC channels: Falling edge of QEC_TRIGGER11 causes counter to clear.</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG11_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 11 causes counter to clear.
For QEC channels: Rising edge of QEC_TRIGGER11 causes counter to clear.</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG10_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 10 causes counter to clear.
For QEC channels: Falling edge of QEC_TRIGGER10 causes counter to clear.</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG10_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 10 causes counter to clear.
For QEC channels: Rising edge of QEC_TRIGGER10 causes counter to clear.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG9_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 9 causes counter to clear.
For QEC channels: Falling edge of QEC_TRIGGER9 causes counter to clear.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG9_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 9 causes counter to clear.
For QEC channels: Rising edge of QEC_TRIGGER9 causes counter to clear.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG8_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 8 causes counter to clear.
For QEC channels: Falling edge of QEC_TRIGGER8 causes counter to clear.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG8_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 8 causes counter to clear.
For QEC channels: Rising edge of QEC_TRIGGER8 causes counter to clear.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG7_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 7 causes counter to clear.
For QEC channels: Falling edge of QEC_TRIGGER7 causes counter to clear.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG7_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 7 causes counter to clear.
For QEC channels: Rising edge of QEC_TRIGGER7 causes counter to clear.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG6_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 6 causes counter to clear.
For QEC channels: Falling edge of QEC_TRIGGER6 causes counter to clear.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG6_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 6 causes counter to clear.
For QEC channels: Rising edge of QEC_TRIGGER6 causes counter to clear.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG5_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 5 causes counter to clear.
For QEC channels: Falling edge of QEC_TRIGGER5 causes counter to clear.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG5_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 5 causes counter to clear.
For QEC channels: Rising edge of QEC_TRIGGER5 causes counter to clear.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG4_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 4 causes counter to clear.
For QEC channels: Falling edge of QEC_TRIGGER4 causes counter to clear.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG4_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 4 causes counter to clear.
For QEC channels: Rising edge of QEC_TRIGGER4 causes counter to clear.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG3_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 3 causes counter to clear.
For QEC channels: Falling edge of QEC_TRIGGER3 causes counter to clear.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG3_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 3 causes counter to clear.
For QEC channels: Rising edge of QEC_TRIGGER3 causes counter to clear.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG2_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 2 causes counter to clear.
For QEC channels: Falling edge of QEC_TRIGGER2 causes counter to clear.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG2_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 2 causes counter to clear.
For QEC channels: Rising edge of QEC_TRIGGER2 causes counter to clear.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG1_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 1 causes counter to clear.
For QEC channels: Falling edge of QEC_TRIGGER1 causes counter to clear.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG1_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 1 causes counter to clear.
For QEC channels: Rising edge of QEC_TRIGGER1 causes counter to clear.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG0_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 0 causes counter to clear.
For QEC channels: Falling edge of QEC_TRIGGER0 causes counter to clear.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG0_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 0 causes counter to clear.
For QEC channels: Rising edge of QEC_TRIGGER0 causes counter to clear.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CLEAR_1_SRC</name>
            <description>Channel (n) Counter Clear Source 1 Register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PGM_EN</name>
                <description>Programmatic Clear Enabled:</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Global programmatic clear is disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Global programmatic clear is enabled (only for start, stop, and clear).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DRIVE_B_FALLING_A_1</name>
                <description>For this channel, channel input B is falling and channel input A = 1 causes counter to clear.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_B_FALLING_A_0</name>
                <description>For this channel, channel input B is falling and channel input A = 0 causes counter to clear.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_B_RISING_A_1</name>
                <description>For this channel, channel input B is rising and channel input A = 1 causes counter to clear.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_B_RISING_A_0</name>
                <description>For this channel, channel input B is rising and channel input A = 0 causes counter to clear.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_FALLING_B_1</name>
                <description>For this channel, channel input A is falling and channel input B = 1 causes counter to clear.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_FALLING_B_0</name>
                <description>For this channel, channel input A is falling and channel input B = 0 causes counter to clear.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_RISING_B_1</name>
                <description>For this channel, channel input A is rising and channel input B = 1 causes counter to clear.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_RISING_B_0</name>
                <description>For this channel, channel input A is rising and channel input B = 0 causes counter to clear.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_UP_0_SRC</name>
            <description>Channel (n) Counter Up Count Source 0 Register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRIG15_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 15 causes counter to increment.
For QEC channels: Reserved, not used.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG15_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 15 causes counter to increment.
For QEC channels: Reserved, not used.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG14_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 14 causes counter to increment.
For QEC channels: Reserved, not used.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG14_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 14 causes counter to increment.
For QEC channels: Reserved, not used.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG13_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 13 causes counter to increment.
For QEC channels: Reserved, not used.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG13_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 13 causes counter to increment.
For QEC channels: Reserved, not used.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG12_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 12 causes counter to increment.
For QEC channels: Reserved, not used.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG12_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 12 causes counter to increment.
For QEC channels: Reserved, not used.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG11_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 11 causes counter to increment.
For QEC channels: Falling edge of QEC_TRIGGER11 causes counter to increment.</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG11_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 11 causes counter to increment.
For QEC channels: Rising edge of QEC_TRIGGER11 causes counter to increment.</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG10_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 10 causes counter to increment.
For QEC channels: Falling edge of QEC_TRIGGER10 causes counter to increment.</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG10_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 10 causes counter to increment.
For QEC channels: Rising edge of QEC_TRIGGER10 causes counter to increment.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG9_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 9 causes counter to increment.
For QEC channels: Falling edge of QEC_TRIGGER9 causes counter to increment.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG9_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 9 causes counter to increment.
For QEC channels: Rising edge of QEC_TRIGGER9 causes counter to increment.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG8_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 8 causes counter to increment.
For QEC channels: Falling edge of QEC_TRIGGER8 causes counter to increment.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG8_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 8 causes counter to increment.
For QEC channels: Rising edge of QEC_TRIGGER8 causes counter to increment.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG7_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 7 causes counter to increment.
For QEC channels: Falling edge of QEC_TRIGGER7 causes counter to increment.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG7_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 7 causes counter to increment.
For QEC channels: Rising edge of QEC_TRIGGER7 causes counter to increment.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG6_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 6 causes counter to increment.
For QEC channels: Falling edge of QEC_TRIGGER6 causes counter to increment.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG6_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 6 causes counter to increment.
For QEC channels: Rising edge of QEC_TRIGGER6 causes counter to increment.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG5_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 5 causes counter to increment.
For QEC channels: Falling edge of QEC_TRIGGER5 causes counter to increment.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG5_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 5 causes counter to increment.
For QEC channels: Rising edge of QEC_TRIGGER5 causes counter to increment.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG4_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 4 causes counter to increment.
For QEC channels: Falling edge of QEC_TRIGGER4 causes counter to increment.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG4_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 4 causes counter to increment.
For QEC channels: Rising edge of QEC_TRIGGER4 causes counter to increment.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG3_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 3 causes counter to increment.
For QEC channels: Falling edge of QEC_TRIGGER3 causes counter to increment.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG3_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 3 causes counter to increment.
For QEC channels: Rising edge of QEC_TRIGGER3 causes counter to increment.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG2_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 2 causes counter to increment.
For QEC channels: Falling edge of QEC_TRIGGER2 causes counter to increment.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG2_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 2 causes counter to increment.
For QEC channels: Rising edge of QEC_TRIGGER2 causes counter to increment.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG1_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 1 causes counter to increment.
For QEC channels: Falling edge of QEC_TRIGGER1 causes counter to increment.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG1_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 1 causes counter to increment.
For QEC channels: Rising edge of QEC_TRIGGER1 causes counter to increment.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG0_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 0 causes counter to increment.
For QEC channels: Falling edge of QEC_TRIGGER0 causes counter to increment.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG0_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 0 causes counter to increment.
For QEC channels: Rising edge of QEC_TRIGGER0 causes counter to increment.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_UP_1_SRC</name>
            <description>Channel (n) Counter Up Count Source 1 Register</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DRIVE_B_FALLING_A_1</name>
                <description>For this channel, channel input B is falling and channel input A = 1 causes counter to increment.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_B_FALLING_A_0</name>
                <description>For this channel, channel input B is falling and channel input A = 0 causes counter to increment.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_B_RISING_A_1</name>
                <description>For this channel, channel input B is rising and channel input A = 1 causes counter to increment.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_B_RISING_A_0</name>
                <description>For this channel, channel input B is rising and channel input A = 0 causes counter to increment.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_FALLING_B_1</name>
                <description>For this channel, channel input A is falling and channel input B = 1 causes counter to increment.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_FALLING_B_0</name>
                <description>For this channel, channel input A is falling and channel input B = 0 causes counter to increment.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_RISING_B_1</name>
                <description>For this channel, channel input A is rising and channel input B = 1 causes counter to increment.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_RISING_B_0</name>
                <description>For this channel, channel input A is rising and channel input B = 0 causes counter to increment.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_DOWN_0_SRC</name>
            <description>Channel (n) Counter Down Count Source 0 Register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRIG15_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 15 causes counter to decrement.
For QEC channels: Reserved, not used.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG15_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 15 causes counter to decrement.
For QEC channels: Reserved, not used.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG14_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 14 causes counter to decrement.
For QEC channels: Reserved, not used.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG14_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 14 causes counter to decrement.
For QEC channels: Reserved, not used.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG13_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 13 causes counter to decrement.
For QEC channels: Reserved, not used.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG13_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 13 causes counter to decrement.
For QEC channels: Reserved, not used.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG12_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 12 causes counter to decrement.
For QEC channels: Reserved, not used.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG12_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 12 causes counter to decrement.
For QEC channels: Reserved, not used.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG11_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 11 causes counter to decrement.
For QEC channels: Falling edge of QEC_TRIGGER11 causes counter to decrement.</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG11_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 11 causes counter to decrement.
For QEC channels: Rising edge of QEC_TRIGGER11 causes counter to decrement.</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG10_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 10 causes counter to decrement.
For QEC channels: Falling edge of QEC_TRIGGER10 causes counter to decrement.</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG10_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 10 causes counter to decrement.
For QEC channels: Rising edge of QEC_TRIGGER10 causes counter to decrement.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG9_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 9 causes counter to decrement.
For QEC channels: Falling edge of QEC_TRIGGER9 causes counter to decrement.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG9_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 9 causes counter to decrement.
For QEC channels: Rising edge of QEC_TRIGGER9 causes counter to decrement.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG8_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 8 causes counter to decrement.
For QEC channels: Falling edge of QEC_TRIGGER8 causes counter to decrement.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG8_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 8 causes counter to decrement.
For QEC channels: Rising edge of QEC_TRIGGER8 causes counter to decrement.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG7_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 7 causes counter to decrement.
For QEC channels: Falling edge of QEC_TRIGGER7 causes counter to decrement.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG7_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 7 causes counter to decrement.
For QEC channels: Rising edge of QEC_TRIGGER7 causes counter to decrement.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG6_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 6 causes counter to decrement.
For QEC channels: Falling edge of QEC_TRIGGER6 causes counter to decrement.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG6_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 6 causes counter to decrement.
For QEC channels: Rising edge of QEC_TRIGGER6 causes counter to decrement.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG5_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 5 causes counter to decrement.
For QEC channels: Falling edge of QEC_TRIGGER5 causes counter to decrement.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG5_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 5 causes counter to decrement.
For QEC channels: Rising edge of QEC_TRIGGER5 causes counter to decrement.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG4_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 4 causes counter to decrement.
For QEC channels: Falling edge of QEC_TRIGGER4 causes counter to decrement.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG4_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 4 causes counter to decrement.
For QEC channels: Rising edge of QEC_TRIGGER4 causes counter to decrement.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG3_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 3 causes counter to decrement.
For QEC channels: Falling edge of QEC_TRIGGER3 causes counter to decrement.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG3_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 3 causes counter to decrement.
For QEC channels: Rising edge of QEC_TRIGGER3 causes counter to decrement.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG2_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 2 causes counter to decrement.
For QEC channels: Falling edge of QEC_TRIGGER2 causes counter to decrement.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG2_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 2 causes counter to decrement.
For QEC channels: Rising edge of QEC_TRIGGER2 causes counter to decrement.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG1_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 1 causes counter to decrement.
For QEC channels: Falling edge of QEC_TRIGGER1 causes counter to decrement.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG1_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 1 causes counter to decrement.
For QEC channels: Rising edge of QEC_TRIGGER1 causes counter to decrement.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG0_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 0 causes counter to decrement.
For QEC channels: Falling edge of QEC_TRIGGER0 causes counter to decrement.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG0_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 0 causes counter to decrement.
For QEC channels: Rising edge of QEC_TRIGGER0 causes counter to decrement.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_DOWN_1_SRC</name>
            <description>Channel (n) Counter Down Count Source 1 Register</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DRIVE_B_FALLING_A_1</name>
                <description>For this channel, channel input B is falling and channel input A = 1 causes counter to decrement.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_B_FALLING_A_0</name>
                <description>For this channel, channel input B is falling and channel input A = 0 causes counter to decrement.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_B_RISING_A_1</name>
                <description>For this channel, channel input B is rising and channel input A = 1 causes counter to decrement.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_B_RISING_A_0</name>
                <description>For this channel, channel input B is rising and channel input A = 0 causes counter to decrement.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_FALLING_B_1</name>
                <description>For this channel, channel input A is falling and channel input B = 1 causes counter to decrement.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_FALLING_B_0</name>
                <description>For this channel, channel input A is falling and channel input B = 0 causes counter to decrement.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_RISING_B_1</name>
                <description>For this channel, channel input A is rising and channel input B = 1 causes counter to decrement.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_RISING_B_0</name>
                <description>For this channel, channel input A is rising and channel input B = 0 causes counter to decrement.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_TRIG_CAPTURE_SRC_A_0</name>
            <description>Channel (n) Trigger Capture Source A 0 Register</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRIG_CAPTURE_SRC_A</name>
                <description>Capture the counter value, when channel input A is the source (decoding is the same as in the UTIMERn_START_0_SRC register).</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_TRIG_CAPTURE_SRC_A_1</name>
            <description>Channel (n) Trigger Capture Source A 1 Register</description>
            <addressOffset>0x2C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRIG_CAPTURE_SRC_A</name>
                <description>Capture the counter value, when channel input A is the source (decoding is the same as in the UTIMERn_START_1_SRC register).</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_TRIG_CAPTURE_SRC_B_0</name>
            <description>Channel (n) Trigger Capture Source B 0 Register</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRIG_CAPTURE_SRC_B</name>
                <description>Capture the counter value, when channel input B is the source (decoding is the same as in the UTIMERn_START_0_SRC register).</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_TRIG_CAPTURE_SRC_B_1</name>
            <description>Channel (n) Trigger Capture Source B 1 Register</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRIG_CAPTURE_SRC_B</name>
                <description>Capture the counter value, when channel input A is the source (decoding is the same as in the UTIMERn_START_1_SRC register).</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_DMA_CLEAR_SRC_A_0</name>
            <description>Channel (n) DMA Clear Source A 0 Register</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DMA_CLEAR_SRC_A</name>
                <description>Clear DMA when driver A is the source (decoding is the same as in the UTIMERn_START_0_SRC register).</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_DMA_CLEAR_SRC_A_1</name>
            <description>Channel (n) DMA Clear Source A 1 Register</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DMA_CLEAR_SRC_A</name>
                <description>Clear DMA when driver A is the source (decoding is the same as in the UTIMERn_START_1_SRC register).</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_DMA_CLEAR_SRC_B_0</name>
            <description>Channel (n) DMA Clear Source B 0 Register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DMA_CLEAR_SRC_B</name>
                <description>Clear DMA when driver B is the source (decoding is the same as in the UTIMERn_START_0_SRC register).</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_DMA_CLEAR_SRC_B_1</name>
            <description>Channel (n) DMA Clear Source B 1 Register</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DMA_CLEAR_SRC_B</name>
                <description>Clear DMA when driver B is the source (decoding is the same as in the UTIMERn_START_1_SRC register).</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CNTR_PAUSE_SRC</name>
            <description>Channel (n) Counter Pause Source Register</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PAUSE_SRC_1_LO_EN</name>
                <description>While PAUSE_TRIGGER[1] = 0x0, pause the channel counter.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAUSE_SRC_1_HI_EN</name>
                <description>While PAUSE_TRIGGER[1] = 0x1, pause the channel counter.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAUSE_SRC_0_LO_EN</name>
                <description>While PAUSE_TRIGGER[0] = 0x0, pause the channel counter.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAUSE_SRC_0_HI_EN</name>
                <description>While PAUSE_TRIGGER[0] = 0x1, pause the channel counter.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CNTR_CTRL</name>
            <description>Channel (n) Counter Control Register</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNTR_DIR</name>
                <description>Counter Direction:
Note: For triangle counter, this will be the direction at a start event
Note: If the direction is changed while the counter is running, it will take effect at the next over/underrun. Changes during triangle wave have no effect.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Up</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Down</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CNTR_TRIG</name>
                <description>Set this bit if incrementing or decrementing the counter via triggers.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Not in trigger based increment/decrement mode.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Trigger based increment/decrement mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CNTR_TYPE</name>
                <description>Counter Type:</description>
                <bitRange>[4:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Sawtooth</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Sawtooth one shot</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x4</name>
                    <description>Triangle</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x6</name>
                    <description>Triangle one shot</description>
                    <value>0x6</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CNTR_RUNNING</name>
                <description>Counter Running:
Note: Writing this bit have no effect.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Count operation is stopped</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Count operation is running </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CNTR_EN</name>
                <description>Counter Enable:</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Counter is disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Counter is enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_FILTER_CTRL_A</name>
            <description>Channel (n) Filter Control A Register</description>
            <addressOffset>0x84</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PRESCALER</name>
                <description>Prescaler function. Allows the input A to be sampled periodically according to the programmed value.
For example, if programmed to 0x10, the input A is sampled every 16 clocks before entering the filter taps.</description>
                <bitRange>[21:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Input A is sampled every clock before entering the filter taps.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Input A is sampled every clock before entering the filter taps.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x4</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x5</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x6</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x7</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x8</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x9</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xA</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xB</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xC</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xD</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xE</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xF</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0xF</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x10</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x11</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x12</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x13</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x14</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x14</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x15</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x15</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x16</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x16</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x17</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x17</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x18</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x18</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x19</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x19</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1A</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x1A</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1B</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x1B</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1C</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x1C</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1D</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x1D</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1E</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x1E</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1F</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x1F</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x20</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x20</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x21</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x21</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x22</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x22</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x23</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x23</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x24</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x24</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x25</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x25</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x26</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x26</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x27</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x27</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x28</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x28</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x29</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x29</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2A</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x2A</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2B</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x2B</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2C</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x2C</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2D</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x2D</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2E</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x2E</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2F</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x2F</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x30</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x30</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x31</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x31</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x32</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x32</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x33</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x33</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x34</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x34</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x35</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x35</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x36</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x36</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x37</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x37</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x38</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x38</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x39</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x39</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3A</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x3A</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3B</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x3B</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3C</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x3C</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3D</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x3D</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3E</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x3E</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3F</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x3F</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FILTER_TAPS</name>
                <description>Number of filter taps.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILTER_EN</name>
                <description>Enable the filtering function.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_FILTER_CTRL_B</name>
            <description>Channel (n) Filter Control B Register</description>
            <addressOffset>0x88</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PRESCALER</name>
                <description>Prescaler function. Allows the input B to be sampled periodically according to the programmed value.
For example, if programmed to 0x10, the input B is sampled every 16 clocks before entering the filter taps.</description>
                <bitRange>[21:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Input B is sampled every clock before entering the filter taps.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Input B is sampled every clock before entering the filter taps.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x4</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x5</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x6</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x7</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x8</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x9</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xA</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xB</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xC</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xD</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xE</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xF</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0xF</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x10</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x11</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x12</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x13</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x14</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x14</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x15</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x15</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x16</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x16</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x17</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x17</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x18</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x18</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x19</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x19</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1A</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x1A</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1B</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x1B</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1C</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x1C</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1D</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x1D</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1E</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x1E</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1F</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x1F</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x20</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x20</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x21</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x21</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x22</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x22</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x23</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x23</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x24</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x24</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x25</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x25</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x26</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x26</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x27</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x27</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x28</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x28</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x29</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x29</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2A</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x2A</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2B</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x2B</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2C</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x2C</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2D</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x2D</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2E</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x2E</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2F</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x2F</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x30</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x30</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x31</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x31</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x32</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x32</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x33</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x33</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x34</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x34</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x35</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x35</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x36</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x36</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x37</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x37</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x38</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x38</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x39</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x39</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3A</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x3A</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3B</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x3B</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3C</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x3C</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3D</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x3D</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3E</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x3E</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3F</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x3F</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FILTER_TAPS</name>
                <description>Number of filter taps.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILTER_EN</name>
                <description>Enable the filtering function.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_COMPARE_CTRL_A</name>
            <description>Channel (n) Compare Control A Register</description>
            <addressOffset>0x8C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DMA_CLEAR_EN</name>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Disable DMA_CLEAR function.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Enable DMA_CLEAR function.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COMPARE_TRIG_EN</name>
                <description>Enable compare match for trigger input:
Note: Only enable if desire compare function during trigger driven counting.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Compare match when trigger count disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Compare match when trigger count enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COMPARE_EN</name>
                <description>Enable compare match:</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Compare match is disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Compare match is enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DISABLE_VAL</name>
                <description>Driver value when output is disabled via bit [8] of this register.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVER_EN</name>
                <description>Driver output enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Driver output is disabled, will take value at bit [9] of this register.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Driver output is controlled by compare logic.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DRV_START_STOP_LEVEL</name>
                <description>Driver output level at start or stop:</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Driver output at start or stop reflects value at bit [4] and bit [6] of this register.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Driver output at start or stop is retained.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DRV_STOP_VAL</name>
                <description>Driver value when counting stops.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRV_START_VAL</name>
                <description>Driver value when counting starts.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRV_CYCLE_END</name>
                <description>Driver value at cycle end:</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Driver value retained at cycle end</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Driver value is 0x0 at cycle end</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Driver value is 0x1 at cycle end </description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Driver value toggles at cycle end</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DRV_MATCH</name>
                <description>Driver A value at compare match:</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Driver value retained at compare match</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Driver value is 0x0 at compare match</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Driver value is 0x1 at compare match</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Driver value toggles at compare match</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_COMPARE_CTRL_B</name>
            <description>Channel (n) Compare Control B Register</description>
            <addressOffset>0x90</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DMA_CLEAR_EN</name>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Disable DMA_CLEAR function.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Enable DMA_CLEAR function.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COMPARE_TRIG_EN</name>
                <description>Enable compare match for trigger input:
Note: Only enable if desire compare function during trigger driven counting.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Compare match when trigger count disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Compare match when trigger count enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COMPARE_EN</name>
                <description>Enable compare match:</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Compare match is disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Compare match is enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DISABLE_VAL</name>
                <description>Driver value when output is disabled via bit [8] of this register.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVER_EN</name>
                <description>Driver output enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Driver output is disabled, will take value at bit [9] of this register.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Driver output is controlled by compare logic.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DRV_START_STOP_LEVEL</name>
                <description>Driver output level at start or stop:</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Driver output at start or stop reflects value at bit [4] and bit [6] of this register.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Driver output at start or stop is retained.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DRV_STOP_VAL</name>
                <description>Driver value when counting stops.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRV_START_VAL</name>
                <description>Driver value when counting starts.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRV_CYCLE_END</name>
                <description>Driver value at cycle end:</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Driver value retained at cycle end</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Driver value is 0x0 at cycle end</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Driver value is 0x1 at cycle end </description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Driver value toggles at cycle end</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DRV_MATCH</name>
                <description>Driver B value at compare match:</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Driver value retained at compare match</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Driver value is 0x0 at compare match</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Driver value is 0x1 at compare match</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Driver value toggles at compare match</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_BUF_OP_CTRL</name>
            <description>Channel (n) Buffer Operation Control Register</description>
            <addressOffset>0x94</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>COMPARE_B_BUF_OP</name>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Single buffer operation</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Double buffer operation</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COMPARE_B_BUF_EVENT</name>
                <description>For triangle wave:
0x0: No transfer (except triangle one shot)
0x1: Transfer at crest
0x2: Transfer at trough
0x3: Transfer at both crest and trough
For sawtooth wave:
0x0: No transfer (except sawtooth one shot)
Any other value: transfer at overflow or underflow (depends on direction)</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COMPARE_A_BUF_OP</name>
                <description>Buffer operation at compare on driver A:</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Single buffer operation</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Double buffer operation</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COMPARE_A_BUF_EVENT</name>
                <description>For triangle wave:
0x0: No transfer (except triangle one shot)
0x1: Transfer at crest
0x2: Transfer at trough
0x3: Transfer at both crest and trough
For sawtooth wave:
0x0: No transfer (except sawtooth one shot)
Any other value: transfer at overflow or underflow (depends on direction)</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_COMPARE_BUF_OP</name>
                <description>Writing 1 forces buffer operation of UTIMERn_COMPARE_A and UTIMERn_COMPARE_B registers for one shot modes. For more information, see the explanation on fixed buffering in UTIMER Buffers, including UTIMER Fixed Buffering Block Diagram.</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CNTR_BUF_OP</name>
                <description>Buffer operation is at overflow/underflow (for triangle wave, only underflow):</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>No buffer operation</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Single buffer operation</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Double buffer operation</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CAPTURE_B_BUF_OP</name>
                <description>Buffer operation at capture on driver B:</description>
                <bitRange>[19:18]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>No buffer operation</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Single buffer operation</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Double buffer operation</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CAPTURE_A_BUF_OP</name>
                <description>Buffer operation at capture on driver A:</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>No buffer operation</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Single buffer operation</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Double buffer operation</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COMPARE_BUF_ENABLE</name>
                <description>Enable buffer operation at compare:</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Buffer operation at compare is disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Buffer operation at compare is enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CNTR_BUF_ENABLE</name>
                <description>Enable counter buffer:</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Counter buffer operation is disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Counter buffer operation is enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CAPTURE_BUF_ENABLE</name>
                <description>Enable buffer operation at capture:</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Buffer operation at capture is disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Buffer operation at capture is enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CNTR</name>
            <description>Channel (n) Counter Register</description>
            <addressOffset>0xA0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNTR</name>
                <description>Write or read value of the counter.
Note: Value must be written only when the counter is stopped.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CNTR_PTR</name>
            <description>Channel (n) Counter Pointer Register</description>
            <addressOffset>0xA4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNTR_PTR</name>
                <description>Counter maximum value.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CNTR_PTR_BUF1</name>
            <description>Channel (n) Counter Pointer Buffer 1 Register</description>
            <addressOffset>0xA8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNTR_PTR_BUF1</name>
                <description>Counter pointer for buffer 1.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CNTR_PTR_BUF2</name>
            <description>Channel (n) Counter Pointer Buffer 2 Register</description>
            <addressOffset>0xAC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNTR_PTR_BUF2</name>
                <description>Counter pointer for buffer 2.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CAPTURE_A</name>
            <description>Channel (n) Capture A Register</description>
            <addressOffset>0xB0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_A</name>
                <description>Top register for capture operation on driver A.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CAPTURE_A_BUF1</name>
            <description>Channel (n) Capture A Buffer 1 Register</description>
            <addressOffset>0xB4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_A_BUF1</name>
                <description>Value of buffer 1 for capture operation on driver A.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CAPTURE_A_BUF2</name>
            <description>Channel (n) Capture A Buffer 2 Register</description>
            <addressOffset>0xB8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_A_BUF2</name>
                <description>Value of buffer 2 for capture operation on driver A.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CAPTURE_B</name>
            <description>Channel (n) Capture B Register</description>
            <addressOffset>0xC0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_B</name>
                <description>Top register for capture operation on driver B.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CAPTURE_B_BUF1</name>
            <description>Channel (n) Capture B Buffer 1 Register</description>
            <addressOffset>0xC4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_B_BUF1</name>
                <description>Value of buffer 1 for capture operation on driver B.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CAPTURE_B_BUF2</name>
            <description>Channel (n) Capture B Buffer 2 Register</description>
            <addressOffset>0xC8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_B_BUF2</name>
                <description>Value of buffer 2 for capture operation on driver B.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_COMPARE_A</name>
            <description>Channel (n) Compare A Register</description>
            <addressOffset>0xD0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>COMPARE_A</name>
                <description>Top register for compare operation on driver A.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_COMPARE_A_BUF1</name>
            <description>Channel (n) Compare A Buffer 1 Register</description>
            <addressOffset>0xD4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>COMPARE_A_BUF1</name>
                <description>Value of buffer 1 for compare operation on driver A.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_COMPARE_A_BUF2</name>
            <description>Channel (n) Compare A Buffer 2 Register</description>
            <addressOffset>0xD8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>COMPARE_A_BUF2</name>
                <description>Value of buffer 2 for compare operation on driver A.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_COMPARE_B</name>
            <description>Channel (n) Compare B Register</description>
            <addressOffset>0xE0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>COMPARE_B</name>
                <description>Top register for compare operation on driver B.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_COMPARE_B_BUF1</name>
            <description>Channel (n) Compare B Buffer 1 Register</description>
            <addressOffset>0xE4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>COMPARE_B_BUF1</name>
                <description>Value of buffer 1 for compare operation on driver B.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_COMPARE_B_BUF2</name>
            <description>Channel (n) Compare B Buffer 2 Register</description>
            <addressOffset>0xE8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>COMPARE_B_BUF2</name>
                <description>Value of buffer 2 for compare operation on driver B.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_DT_UP</name>
            <description>Channel (n) Dead-time Up Register</description>
            <addressOffset>0xF0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DT_UP</name>
                <description>Dead-time in counter direction up.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_DT_UP_BUF1</name>
            <description>Channel (n) Dead-time Up Buffer 1 Register</description>
            <addressOffset>0xF4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DT_UP_BUF1</name>
                <description>Dead-time in counter direction up for buffer 1.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_DT_DOWN</name>
            <description>Channel (n) Dead-time Down Register</description>
            <addressOffset>0xF8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DT_DOWN</name>
                <description>Dead-time in counter direction down.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_DT_DOWN_BUF1</name>
            <description>Channel (n) Dead-time Down Buffer 1 Register</description>
            <addressOffset>0xFC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DT_DOWN_BUF1</name>
                <description>Dead-time in counter direction down for buffer 1.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CHAN_STATUS</name>
            <description>Channel (n) Status Register</description>
            <addressOffset>0x114</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DRV_A_B_0</name>
                <description>Drivers A and B are both 0.
Note: This bit contains the current status.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRV_A_B_1</name>
                <description>Drivers A and B are both 1.
Note: This bit contains the current status.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COMPARE_B_DOWN</name>
                <description>Compare on driver B during down counting.
 Note: This status bit is only valid when the counter is free-running.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COMPARE_B_UP</name>
                <description>Compare on driver B during up counting.
 Note: This status bit is only valid when the counter is free-running.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COMPARE_A_DOWN</name>
                <description>Compare on driver A during down counting.
 Note: This status bit is only valid when the counter is free-running.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COMPARE_A_UP</name>
                <description>Compare on driver A during up counting.
 Note: This status bit is only valid when the counter is free-running.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CNTR_DIR</name>
                <description>Counter Direction:
Note: This bit contains the current status, only valid if counter is running.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Counter is downward</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Counter is upward</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CNTR_RUNNING</name>
                <description>Counter running status:
Note: This bit contains the current status.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Counter is not running.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Counter is running.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVER_FLOW</name>
                <description>An overflow (or crest) had occurred.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>UNDER_FLOW</name>
                <description>An underflow (or trough) had occurred.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CAPTURE_B</name>
                <description>Capture event on driver B occurred due to a trigger.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CAPTURE_A</name>
                <description>Capture event on driver A occurred due to a trigger.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CHAN_INTERRUPT</name>
            <description>Channel (n) Interrupt Control Register</description>
            <addressOffset>0x118</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OVER_FLOW</name>
                <description>An overflow event had occurred.
Write 1 to clear bit.</description>
                <bitRange>[7:7]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>UNDER_FLOW</name>
                <description>An underflow event had occurred.
Write 1 to clear bit.</description>
                <bitRange>[6:6]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>COMPARE_B_BUF2</name>
                <description>Compare of COMPARE_B_BUF2.
Write 1 to clear bit.</description>
                <bitRange>[5:5]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>COMPARE_B_BUF1</name>
                <description>Compare of COMPARE_B_BUF1.
Write 1 to clear bit.</description>
                <bitRange>[4:4]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>COMPARE_A_BUF2</name>
                <description>Compare of COMPARE_A_BUF2.
Write 1 to clear bit.</description>
                <bitRange>[3:3]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>COMPARE_A_BUF1</name>
                <description>Compare of COMPARE_A_BUF1.
Write 1 to clear bit.</description>
                <bitRange>[2:2]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>CAPTURE_B</name>
                <description>Capture B or compare B event had occurred.
Write 1 to clear bit.</description>
                <bitRange>[1:1]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>CAPTURE_A</name>
                <description>Capture A or compare A event had occurred.
Write 1 to clear bit.</description>
                <bitRange>[0:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CHAN_INTERRUPT_MASK</name>
            <description>Channel (n) Interrupt Mask Register</description>
            <addressOffset>0x11C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x000000FF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OVER_FLOW</name>
                <description>Mask for channel interrupts.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>UNDER_FLOW</name>
                <description>Mask for channel interrupts.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COMPARE_B_BUF2</name>
                <description>Mask for channel interrupts.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COMPARE_B_BUF1</name>
                <description>Mask for channel interrupts.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COMPARE_A_BUF2</name>
                <description>Mask for channel interrupts.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COMPARE_A_BUF1</name>
                <description>Mask for channel interrupts.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CAPTURE_B</name>
                <description>Mask for channel interrupts.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CAPTURE_A</name>
                <description>Mask for channel interrupts.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_DUTY_CYCLE_CTRL</name>
            <description>Channel (n) Duty Cycle Control Register</description>
            <addressOffset>0x120</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DC_UNDERFLOW_B</name>
                <description>Apply duty cycle at underflow of driver B.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DC_OVERFLOW_B</name>
                <description>Apply duty cycle at overflow of driver B.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DC_SETTING_B</name>
                <description>Duty cycle setting for driver B:</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Compare match determines duty cycle (no masking)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Compare match determines duty cycle (no masking)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>0% duty cycle</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>100% duty cycle</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DC_FORCE_B</name>
                <description>Force duty cycle for output B at cycle start, reflecting the UTIMERn_DUTY_CYCLE_CTRL[DC_SETTING_B] bit field.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DC_ENABLE_B</name>
                <description>Enable the duty cycle function for driver B.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DC_UNDERFLOW_A</name>
                <description>Apply duty cycle at underflow of driver A.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DC_OVERFLOW_A</name>
                <description>Apply duty cycle at overflow of driver A.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DC_SETTING_A</name>
                <description>Duty cycle setting for driver A:</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Compare match determines duty cycle (no masking)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Compare match determines duty cycle (no masking)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>0% duty cycle</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>100% duty cycle</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DC_FORCE_A</name>
                <description>Force duty cycle for output A at cycle start, reflecting the UTIMERn_DUTY_CYCLE_CTRL[DC_SETTING_A] bit field.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DC_ENABLE_A</name>
                <description>Enable the duty cycle function for driver A.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_DEAD_TIME_CTRL</name>
            <description>Channel (n) Dead-time Control Register</description>
            <addressOffset>0x124</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DT_BUF_EN</name>
                <description>Enable dead-time buffer operation.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DT_EN</name>
                <description>Dead-time enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_INT_CNTR_CTRL</name>
            <description>Channel (n) Interrupt Counter Control Register</description>
            <addressOffset>0x130</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>INT_CNTR_EN</name>
                <description>Enables the counting of overflow or underflow events.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INT_CNTR</name>
                <description>Interrupt counter. This number of overflow or underflow events must occur before the corresponding interrupt is triggered.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_FAULT_CTRL</name>
            <description>Channel (n) Fault Control Register</description>
            <addressOffset>0x134</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FAULT_TYPE_B</name>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Will force output driver B low and keep low until overflow or underflow.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Will force output driver B low and keep low until a counter stop event is seen.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FAULT_POLARITY_B</name>
                <description>Bit enable to determine FAULT_TRIGGER[3-0] active polarity for output driver B.</description>
                <bitRange>[23:20]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Will force output driver B low when associated FAULT_TRIGGER[3-0] is low.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Will force output driver B low when associated FAULT_TRIGGER[3-0] is high.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FAULT_ENABLE_B</name>
                <description>Bit enable to use FAULT_TRIGGER[3-0] to control channel output driver B.</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Associated FAULT_TRIGGER has no effect on output drivers.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Associated FAULT_TRIGGER active to control output drivers.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FAULT_TYPE_A</name>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Will force output driver A low and keep low until overflow or underflow.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Will force output driver A low and keep low until a counter stop event is seen.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FAULT_POLARITY_A</name>
                <description>Bit enable to determine FAULT_TRIGGER[3-0] active polarity for output driver A</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Will force output driver A low when associated FAULT_TRIGGER[3-0] is low.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Will force output driver A low when associated FAULT_TRIGGER[3-0] is high.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FAULT_ENABLE_A</name>
                <description>Bit enable to use FAULT_TRIGGER[3-0] to control channel output driver A.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Associated FAULT_TRIGGER has no effect on output drivers.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Associated FAULT_TRIGGER active to control output drivers.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral derivedFrom="LPUTIMER">
      <name>UTIMER</name>
      <baseAddress>0x48000000</baseAddress>
    </peripheral>
    <peripheral>
      <name>ETH</name>
      <baseAddress>0x48100000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4456</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ETH_MAC_CONFIGURATION</name>
          <description>MAC Configuration Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00008000</resetValue>
          <resetMask>0x8FFBFFFF</resetMask>
          <fields>
            <field>
              <name>ARPEN</name>
              <description>ARP Offload Enable
When this bit is set, the MAC can recognize an incoming ARP request packet and schedules the ARP packet for transmission. It forwards the ARP packet to the application and also indicate the events in the RxStatus.
When this bit is reset, the MAC receiver does not recognize any ARP packet and indicates them as Type frame in the RxStatus.
This bit is available only when the Enable IPv4 ARP Offload is selected.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>ARP offload is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ARP offload is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IPC</name>
              <description>Checksum Offload
When set, this bit enables the IPv4 header checksum checking and IPv4 or IPv6 TCP, UDP, or ICMP payload checksum checking. When this bit is reset, the COE function in the receiver is disabled.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>IP header/payload checksum checking is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>IP header/payload checksum checking is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IPG</name>
              <description>Inter-Packet Gap
These bits control the minimum IPG between packets during transmission. This range of minimum IPG is valid in full-duplex mode.
In the half-duplex mode, the minimum IPG can be configured only for 64-bit times (IPG = 100). Lower values are not considered.
When a JAM pattern is being transmitted because of backpressure activation, the MAC does not consider the minimum IPG.
This above function (IPG less than 96-bit times) is valid only when the ETH_MAC_EXT_CONFIGURATION[EIPGEN] bit is reset. When EIPGEN is set, then the minimum IPG (greater than 96-bit times) is controlled as per the description given in the ETH_MAC_EXT_CONFIGURATION[EIPG] field.</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>96-bit times IPG</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>88-bit times IPG</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>80-bit times IPG</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>72-bit times IPG</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>64-bit times IPG</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>56-bit times IPG</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>48-bit times IPG</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>40-bit times IPG</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GPSLCE</name>
              <description>Giant Packet Size Limit Control Enable
When this bit is set, the MAC considers the value in the ETH_MAC_EXT_CONFIGURATION[GPSL] field to declare a received packet as Giant packet. This field must be programmed to more than 1,518 bytes. Otherwise, the MAC considers 1,518 bytes as giant packet limit.
When this bit is reset, the MAC considers a received packet as Giant packet when its size is greater than 1,518 bytes (1522 bytes for tagged packet).
The watchdog timeout limit, Jumbo Packet Enable and 2KB Packet Enable have higher precedence over this bit, that is the MAC considers a received packet as Giant packet when its size is greater than 9,018 bytes (9,022 bytes for tagged packet) with Jumbo Packet Enabled and greater than 2,000 bytes with 2KB Packet Enabled. The watchdog timeout, if enabled, terminates the received packet when watchdog limit is reached. Therefore, the programmed giant packet limit must be less than the watchdog limit to get the giant packet status.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Giant packet size limit control is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Giant packet size limit control is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>S2KP</name>
              <description>IEEE 802.3as Support for 2KB Packets
When this bit is set, the MAC considers all packets with up to 2,000 bytes length as normal packets. When the JE bit is not set, the MAC considers all received packets of size more than 2KB as Giant packets.
When this bit is reset and the JE bit is not set, the MAC considers all received packets of size more than 1,518 bytes (1,522 bytes for tagged) as giant packets.
Note: When the JE bit is set, setting this bit has no effect on the giant packet status.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Support upto 2KB packet is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Support upto 2KB packet is Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CST</name>
              <description>CRC stripping for Type packets
When this bit is set, theMAC strips and drops the last four bytes (FCS) of all Ether type packets, as indicated by the Length/Type field of the packet, before forwarding the packet to the application</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>CRC stripping for type packets is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CRC stripping for type packets is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ACS</name>
              <description>Automatic Pad or CRC Stripping
When this bit is set, the MAC strips the pad or the FCS field of the incoming
Ethernet Length packets. For the Ethernet Type packets, MAC
transfers the packets to the application without stripping the
Pad or FCS field.
When this bit is reset, the MAC passes all incoming packets to the application, without any modification.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Automatic Pad or CRC stripping is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Automatic Pad or CRC stripping is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WD</name>
              <description>Watchdog Disable
When this bit is set, the MAC disables the watchdog timer on the receiver. The MAC can receive packets of up to 16,383 bytes.
When this bit is reset, the MAC does not allow more than 2,048 bytes (10,240 if JE is set high) of the packet being received. The MAC cuts off any bytes received after 2,048 bytes.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Watchdog is enabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Watchdog is disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>JD</name>
              <description>Jabber Disable
When this bit is set, the MAC disables the jabber timer on the transmitter. The MAC can transfer packets of up to 16,383 bytes.
When this bit is reset, if the application sends more than 2,048 bytes of data (10,240 if JE is set high) during transmission, the MAC does not send rest of the bytes in that packet.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Jabber is enabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Jabber is disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>JE</name>
              <description>Jumbo Packet Enable
When this bit is set, the MAC allows jumbo packets of 9,018 bytes (9,022 bytes for VLAN tagged packets) without reporting a giant packet error in the Rx packet status.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Jumbo packet is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Jumbo packet is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PS</name>
              <description>Port Select
This bit selects the Ethernet line speed. This bit, along with the FES bit, selects the exact line speed. Their value is also reflected in the ETH_STAT0[MAC_SPEED_O] field.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>For 10 or 100 Mbps operations</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FES</name>
              <description>Speed
This bit selects the speed mode. Its value along with the PS bit value is also reflected in the ETH_STAT0[MAC_SPEED_O] field.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>10 Mbps</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>100 Mbps</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DM</name>
              <description>Duplex Mode
When this bit is set, the MAC operates in the full-duplex mode in which it can transmit and receive simultaneously.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Half-duplex mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Full-duplex mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LM</name>
              <description>Loopback Mode
When this bit is set, the MAC operates in the loopback mode at RMII.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Loopback is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Loopback is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ECRSFD</name>
              <description>Enable Carrier Sense Before Transmission in Full-Duplex Mode
When this bit is set, the MAC transmitter checks the ETH_CRS_DV signal before packet transmission in the full-duplex mode. The MAC starts the transmission only when the ETH_CRS_DV signal is low.
When this bit is reset, the MAC transmitter ignores the status of the ETH_CRS_DV signal.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>ECRSFD is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ECRSFD is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DO</name>
              <description>Disable Receive Own
When this bit is set, the MAC disables the reception of packets when the ETH_TXEN signal is asserted in the half-duplex mode. When this bit is reset, the MAC receives all packets given by the PHY.
This bit is not applicable in the full-duplex mode.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Enable receive own</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Disable receive own</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DCRS</name>
              <description>Disable Carrier Sense During Transmission
When this bit is set, the MAC transmitter ignores the RMII ETH_CRS_DV signal during packet transmission in the half-duplex mode. As a result, no errors are generated because of Loss of Carrier or No Carrier during transmission.
When this bit is reset, the MAC transmitter generates errors because of Carrier Sense. The MAC can even abort the transmission.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Enable carrier sense during transmission</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Disable carrier sense during transmission</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DR</name>
              <description>Disable Retry
When this bit is set, the MAC attempts only one transmission. When a collision occurs on the RMII interface, the MAC ignores the current packet transmission and reports a Packet Abort with excessive collision error in the Tx packet status.
When this bit is reset, the MAC retries based on the settings of the BL field. This bit is applicable only in the half-duplex mode.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Enable retry</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Disable retry</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BL</name>
              <description>Back-Off Limit
The back-off limit determines the random integer number (r) of slot time delays (512-bit times) for which the MAC waits before rescheduling a transmission attempt during retries after a collision.n = retransmission attempt.
The random integer r takes the value in the range 0 &lt;= r &lt; 2^k
This bit is applicable only in the half-duplex mode.</description>
              <bitRange>[6:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>k = min(n, 10)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>k = min(n, 8)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>k = min(n, 4)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>k = min(n, 1)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DC</name>
              <description>Deferral Check
When this bit is set, the deferral check function is enabled in the MAC. The MAC issues a Packet Abort status, along with the excessive deferral error bit set in the Tx packet status, when the Tx state machine is deferred for more than 24,288-bit times in 10 or 100 Mbps mode.
The defer time is not cumulative. For example, if the transmitter defers for 10,000-bit times because the ETH_CRS_DV signal is active and the ETH_CRS_DV signal becomes inactive, the transmitter transmits and collision happens. Because of collision, the transmitter needs to back off and then defer again after back off completion. In such a scenario, the deferral timer is reset to 0, and it is restarted.
When this bit is reset, the deferral check function is disabled and the MAC defers until the ETH_CRS_DV signal goes inactive.
This bit is applicable only in the half-duplex mode.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Deferral check function is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Deferral check function is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRELEN</name>
              <description>Preamble Length for Transmit packets
These bits control the number of preamble bytes that are added to the beginning of every Tx packet. The preamble reduction occurs only when the MAC is operating in the full-duplex mode.</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>7 bytes of preamble</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>5 bytes of preamble</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>3 bytes of preamble</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TE</name>
              <description>Transmitter Enable
When this bit is set, the Tx state machine of the MAC is enabled for transmission on the RMII interface. When this bit is reset, the MAC Tx state machine is disabled after it completes the transmission of the current packet. The Tx state machine does not transmit any more packets.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmitter is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmitter is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RE</name>
              <description>Receiver Enable
When this bit is set, the Rx state machine of the MAC is enabled for receiving packets from the RMII interface. When this bit is reset, the MAC Rx state machine is disabled after it completes the reception of the current packet. The Rx state machine does not receive any more packets from the RMII interface.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receiver is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receiver is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_EXT_CONFIGURATION</name>
          <description>MAC Extended Configuration Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x7FFFFFFF</resetMask>
          <fields>
            <field>
              <name>APDIM</name>
              <description>ARP Packet Drop if IP Address Mismatch
When this bit is set, packet for which Target Protocol Address does not match IPv4 address is dropped in the MTL layer.
When this bit is reset, when target Protocol Address does not match, packet is forwarded to MTL maintaining backward compatibility.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>mux select to drop the arp packet if target protocol address mismatches IPv4 address disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>mux select to drop the arp packet if target protocol address mismatches IPv4 address enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EIPG</name>
              <description>Extended Inter-Packet Gap
The value in this field is applicable when the EIPGEN bit is set.
The five bits of this field are the most significant bits; the ETH_MAC_CONFIGURATION[IPG] field has the three least significant bits. Together, the eight bits represent the value of the minimum IPG greater than 96-bit times, in steps of 8-bit times: {EIPG, IPG}.
0x0: 104-bit times
0x1: 112-bit times
0x2: 120-bit times
0xFF: 2144-bit times</description>
              <bitRange>[29:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EIPGEN</name>
              <description>Extended Inter-Packet Gap Enable
When this bit is set, the MAC uses the EIPG field for the extended inter-packet gap. For details, see the description of the EIPG field.
When this bit is reset, the MAC ignores the EIPG field and uses the ETH_MAC_CONFIGURATION[IPG] field as the minimum IPG less than or equal to 96-bit times, in steps of 8-bit times.
Note: The extended Inter-Packet Gap feature must be enabled when operating in Full-Duplex mode only. There may be undesirable effects on back-pressure function and frame transmission if it is enabled in Half-Duplex mode.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Extended inter-packet gap is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Extended inter-packet gap is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USP</name>
              <description>Unicast Slow Protocol Packet Detect
When this bit is set, the MAC detects the Slow Protocol packets with unicast address of the station specified in the ETH_MAC_ADDRESS0_HIGH and ETH_MAC_ADDRESS0_LOW registers. The MAC also detects the Slow Protocol packets with the Slow Protocols multicast address (01-80-C2-00-00-02).
When this bit is reset, the MAC detects only Slow Protocol packets with the Slow Protocol multicast address specified in the IEEE 802.3-2015 Specification, Section </description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Unicast slow protocol packet detection is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Unicast slow protocol packet detection is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPEN</name>
              <description>Slow Protocol Detection Enable
When this bit is set, MAC processes the Slow Protocol packets (Ether Type 0x8809) and provides the Rx status. The MAC discards the Slow Protocol packets with invalid sub-types.
When this bit is reset, the MAC forwards all the error-free Slow Protocol packets to the application. The MAC considers such packets as normal Type packets.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slow protocol detection is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slow protocol detection is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DCRCC</name>
              <description>Disable CRC Checking for Received Packets
When this bit is set, the MAC receiver does not check the CRC field in the received packets. When this bit is reset, the MAC receiver always checks the CRC field in the received packets.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>CRC checking is enabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CRC checking is disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GPSL</name>
              <description>Giant Packet Size Limit
If the received packet size is greater than the value programmed in this field in units of bytes, the MAC declares the received packet as Giant packet. The value programmed in this field must be greater than or equal to 1,518 bytes. Any other programmed value is considered as 1,518 bytes.
For VLAN tagged packets, the MAC adds 4 bytes to the programmed value. When the Enable Double VLAN Processing option is selected, the MAC adds 8 bytes to the programmed value for double VLAN tagged packets. The value in this field is applicable when the GPSLCE bit is set in ETH_MAC_CONFIGURATION register.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_PACKET_FILTER</name>
          <description>MAC Packet Filter Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF9</resetMask>
          <fields>
            <field>
              <name>RA</name>
              <description>Receive All
When this bit is set, the MAC receiver transfers all the received packets to the application regardless of the address filter status. MAC updates the SA or DA filtering status in the corresponding bit of the MAC Filter Status Word.
When this bit is reset, the MAC receiver transfers to the application only the packets that pass the SA or DA address filter.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive all is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive all is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VTFE</name>
              <description>VLAN Tag Filter Enable
When this bit is set, the MAC drops the VLAN tagged packets that do not match the VLAN Tag. When this bit is reset, the MAC forwards all packets irrespective of the match status of the VLAN Tag.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>VLAN tag filter is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>VLAN tag filter is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PCF</name>
              <description>Pass Control Packets
These bits control the forwarding of all control packets (including unicast and multicast Pause packets).</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MAC filters all control packets from reaching the application</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MAC forwards all control packets except pause packets to the application even if they fail the address filter</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>MAC forwards all control packets to the application even if they fail the address filter</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>MAC forwards the control packets that pass the address filter</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBF</name>
              <description>Disable Broadcast Packets
When this bit is set, the AFM module blocks all incoming broadcast packets. In addition, it overrides all other filter settings.
When this bit is reset, the AFM module passes all received broadcast packets.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Enable broadcast packets</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Disable broadcast packets</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PM</name>
              <description>Pass All Multicast
When this bit is set, it indicates that all the received packets with a multicast destination address (first bit in the destination address field is '1') are passed. When this bit is reset, filtering of multicast packet depends on HMC bit.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Pass all multicast is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Pass all multicast is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DAIF</name>
              <description>DA Inverse Filtering
When this bit is set, the Address Check block operates in inverse filtering mode for the DA address comparison for both unicast and multicast packets. When this bit is reset, normal filtering of packets is performed.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DA inverse filtering is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DA inverse filtering is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PR</name>
              <description>Promiscuous Mode
When this bit is set, the MAC transfers all incoming packets to the application regardless of the destination or source address filtering status. The MAC clears the SA or DA Filter Fail status bits of the MAC Rx Status Word.
When this bit is reset, the MAC transfers to the application only the packets that pass destination or source address filtering.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Promiscuous mode is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Promiscuous mode is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_WD_JB_TIMEOUT</name>
          <description>Watchdog Timeout Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PJE</name>
              <description>Programmable Jabber Enable
When this bit is set and the ETH_MAC_CONFIGURATION[JD] bit is reset, the JTO field in this register is used as jabber timeout limit for a transmitted packet. When the PJE bit is cleared, the jabber timeout for a received packet is controlled by setting of the ETH_MAC_CONFIGURATION[JD] and [JE] bits.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Programmable Jabber is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Programmable Jabber is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>JTO</name>
              <description>Jabber Timeout
When the PJE bit is set and the ETH_MAC_CONFIGURATION[JD] bit is reset, this field is used as jabber timeout limit for a transmitted packet. If the length of a transmitted packet exceeds the value of this field, such packet is terminated and declared as an error packet.
Note: When the PJE bit is set, the value in this field must be more than 1,522 (0x05F2). Otherwise, the IEEE 802.3-specified valid tagged packets are declared as error packets and terminated.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>2KB</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>3KB</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>4KB</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>5KB</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>6KB</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>7KB</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>8KB</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>9KB</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>10KB</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>11KB</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>12KB</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>13KB</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>14KB</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xD</name>
                  <description>15KB</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xE</name>
                  <description>16383 bytes</description>
                  <value>0xE</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PWE</name>
              <description>Programmable Watchdog Enable
When this bit is set and the ETH_MAC_CONFIGURATION[WD] bit is reset, the WTO field is used as watchdog timeout limit for a received packet. When this bit is cleared, the watchdog timeout for a received packet is controlled by setting of the ETH_MAC_CONFIGURATION[WD] and ETH_MAC_CONFIGURATION[JE] bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Programmable watchdog is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Programmable watchdog is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WTO</name>
              <description>Watchdog Timeout
When the PWE bit is set and the ETH_MAC_CONFIGURATION[WD] bit is reset, this field is used as watchdog timeout limit for a received packet. If the length of a received packet exceeds the value of this field, such packet is terminated and declared as an error packet.
Note: When the PWE bit is set, the value in this field must be more than 1,522 (0x5F2). Otherwise, the IEEE 802.3-specified valid tagged packets are declared as error packets and then dropped.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>2KB</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>3KB</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>4KB</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>5KB</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>6KB</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>7KB</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>8KB</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>9KB</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>10KB</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>11KB</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>12KB</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>13KB</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>14KB</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xD</name>
                  <description>15KB</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xE</name>
                  <description>16383 bytes</description>
                  <value>0xE</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_VLAN_TAG</name>
          <description>VLAN Tag Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x01FFFFFF</resetMask>
          <fields>
            <field>
              <name>EVLRXS</name>
              <description>Enable VLAN Tag in Rx status
When this bit is set, MAC provides the outer VLAN Tag in the Rx status. When this bit is reset, the MAC does not provide the outer VLAN Tag in Rx status.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>VLAN tag in Rx status is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>VLAN tag in Rx status is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVLS</name>
              <description>Enable VLAN Tag Stripping on Receive
This field indicates the stripping operation on the outer VLAN Tag in the received packet.</description>
              <bitRange>[22:21]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Do not strip</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Strip if VLAN filter passes</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Strip if VLAN filter fails</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Always strip</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DOVLTC</name>
              <description>Disable VLAN Type Check
When this bit is set, the MAC does not check whether the VLAN Tag specified by the ERIVLT bit is of type S-VLAN or C-VLAN.
When this bit is reset, the MAC filters or matches the VLAN Tag specified by the ERIVLT bit only when VLAN Tag type is similar to the one specified by the ERSVLM bit. The VLAN filter is bypassed when VLAN Type of received packet do not match the programmed VLAN Type in the VLAN filter.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>VLAN type check is enabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>VLAN type check is disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ERSVLM</name>
              <description>Enable Receive S-VLAN Match
When this bit is set, the MAC receiver enables filtering or matching for S-VLAN (Type = 0x88A8) packets. When this bit is reset, the MAC receiver enables filtering or matching for C-VLAN (Type = 0x8100) packets.
The ERIVLT bit determines the VLAN tag position considered for filtering or matching.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive S-VLAN match is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive S-VLAN match is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ESVL</name>
              <description>Enable S-VLAN
When this bit is set, the MAC transmitter and receiver consider the S-VLAN packets (Type = 0x88A8) as valid VLAN tagged packets.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>S-VLAN is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>S-VLAN is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VTIM</name>
              <description>VLAN Tag Inverse Match Enable
When this bit is set, this bit enables the VLAN Tag inverse matching. The packets without matching VLAN Tag are marked as matched. When reset, this bit enables the VLAN Tag perfect matching. The packets with matched VLAN Tag are marked as matched.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>VLAN tag inverse match is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>VLAN tag inverse match is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ETV</name>
              <description>Enable 12-Bit VLAN Tag Comparison
When this bit is set, a 12-bit VLAN identifier is used for comparing and filtering instead of the complete 16-bit VLAN tag. Bits[11-0] of the VLAN tag are compared with the corresponding field in the received VLAN-tagged packet. Similarly, when enabled, only 12 bits of the VLAN tag in the received packet are used for hash-based VLAN filtering.
When this bit is reset, all 16 bits of the 15th and 16th bytes of the received VLAN packet are used for comparison and VLAN hash filtering.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>12-Bit VLAN tag comparison is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>12-Bit VLAN tag comparison is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VL</name>
              <description>VLAN Tag Identifier for Receive Packets
This field contains the 802.1Q VLAN tag to identify the VLAN packets. This VLAN tag identifier is compared to the 15th and 16th bytes of the packets being received for VLAN packets. The following list describes the bits of this field:
Bits[15-13]: User Priority
Bit 12: Canonical Format Indicator (CFI) or Drop Eligible Indicator (DEI)
Bits[11-0]: VLAN Identifier (VID) field of VLAN tag
If this field ([11-0] if ETV is set) is all zeros, the MAC does not check the 15th and 16th bytes for VLAN tag comparison and declares all packets with Type field value of 0x8100 or 0x88A8 as VLAN packets.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_Q0_TX_FLOW_CTRL</name>
          <description>Flow Control Register</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PT</name>
              <description>Pause Time
This field holds the value to be used in the Pause Time field in the Tx control packet. If the Pause Time bits are configured to be double-synchronized to the RMII clock domain, consecutive writes to this register must be performed only after at least four clock cycles in the destination clock domain.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DZPQ</name>
              <description>Disable Zero-Quanta Pause
When this bit is set, it disables the automatic generation of the zero-quanta Pause packets.
When this bit is reset, normal operation with automatic zero-quanta Pause packet generation is enabled.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Zero-quanta pause packet generation is enabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Zero-quanta pause packet generation is disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PLT</name>
              <description>Pause Low Threshold
This field configures the automatic retransmission interval of the Pause packet.
The value must always be less than the Pause Time configured in the PT field. For example, if PT = 0x100 (256 slot times), and PLT = 0x1, a second Pause packet is automatically transmitted at 228 (256-28) slot times after the first Pause packet is transmitted.
The following list provides the threshold values for different values.The slot time is defined as the time taken to transmit 512 bits (64 bytes) on the RMII interface.
This (approximate) computation is based on the packet size (64, 1518, 2000, 9018, 16384, or 32768) + 2 Pause Packet Size + IPG in Slot Times.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Pause time minus 4 slot times (PT - 4 slot times)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Pause time minus 28 slot times (PT - 28 slot times)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Pause time minus 36 slot times (PT - 36 slot times)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Pause time minus 144 slot times (PT - 144 slot times)</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Pause time minus 256 slot times (PT - 256 slot times)</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>Pause time minus 512 slot times (PT - 512 slot times)</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TFE</name>
              <description>Transmit Flow Control Enable
Full-Duplex Mode:
In the full-duplex mode, when this bit is set, the MAC enables the flow control operation to Tx Pause packets. When this bit is reset, the flow control operation in the MAC is disabled, and the MAC does not transmit any Pause packets.
Half-Duplex Mode:
In the half-duplex mode, when this bit is set, the MAC enables the backpressure operation. When this bit is reset, the backpressure feature is disabled.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit flow control is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit flow control is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FCB_BPA</name>
              <description>Flow Control Busy or Backpressure Activate
This bit initiates a Pause packet in the full-duplex mode and activates the backpressure function in the half-duplex mode if the TFE bit is set.
Full-Duplex Mode:
In the full-duplex mode, this bit must be read as 0x0 before writing to this register. To initiate a Pause packet, the application must set this bit to 0x1. During Control packet transfer, this bit continues to be set to indicate that a packet transmission is in progress. When Pause packet transmission is complete, the MAC resets this bit to 0x0. The user must not write to this register until this bit is cleared.
Half-Duplex Mode:
When this bit is set (and TFE bit is set) in the half-duplex mode, the MAC asserts the backpressure. During backpressure, when the MAC receives a new packet, the transmitter starts sending a JAM pattern resulting in a collision.
Access restriction applies.
- MAC initiates the pause packet or activates the backpressure, when application writes 1.
- MAC writes 0 after the operation is complete.
- MAC ignores when application writes 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Flow control busy or backpressure activate is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Flow control busy or backpressure activate is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_RX_FLOW_CTRL</name>
          <description>Receive Flow Control Register</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UP</name>
              <description>Unicast Pause Packet Detect
A pause packet is processed when it has the unique multicast address specified in the IEEE 802.3 Specification. When this bit is set, the MAC can also detect Pause packets with unicast address of the station. This unicast address must be as specified in ETH_MAC_ADDRESS0_HIGH and ETH_MAC_ADDRESS0_LOW.
When this bit is reset, the MAC only detects Pause packets with unique multicast address.
Note: The MAC does not process a Pause packet if the multicast address is different from the unique multicast address. This is also applicable to the received PFC packet when the Priority Flow Control (PFC) is enabled. The unique multicast address (0x1_80_C2_00_00_01) is as specified in the IEEE 802.1 Qbb-2011 Specification.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Unicast pause packet detect disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Unicast pause packet detect enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFE</name>
              <description>Receive Flow Control Enable
When this bit is set and the MAC is operating in full-duplex mode, the MAC decodes the received Pause packet and disables its transmitter for a specified (Pause) time. When this bit is reset or the MAC is operating in half-duplex mode, the decode function of the Pause packet is disabled.
When PFC is enabled, flow control is enabled for PFC packets. The MAC decodes the received PFC packet and disables the Transmit queue, with matching priorities, for a duration of received Pause time.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive flow control is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive flow control is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_INTERRUPT_STATUS</name>
          <description>Interrupt Status Register</description>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFCF018</resetMask>
          <fields>
            <field>
              <name>MDIOIS</name>
              <description>MDIO Interrupt Status
When set, this bit indicates to the application that MDIO operation is complete. MAC writes 0 to this bit when the application reads this bit. Application can write 1 to clear this bit when ETH_MAC_CSR_SW_CTRL[RCWE] = 1.
Following access restrictions apply:
- Clears on read
- Clears on write 1, when ETH_MAC_CSR_SW_CTRL[RCWE] = 1
- Self-set to 1 on internal event</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MDIO interrupt status not active</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MDIO interrupt status active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GPIIS</name>
              <description>GPI Interrupt Status
This bit is set when any active event (LL or LH) occurs on the ETH_MAC_GPIO_STATUS[GPIS] field and the corresponding bit is enabled in the ETH_MAC_GPIO_CONTROL[GPIE] field. This bit is cleared on reading the ETH_MAC_GPIO_STATUS[GPIS] field.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>GPI Interrupt status not active</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>GPI Interrupt status active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXSTSIS</name>
              <description>Receive Status Interrupt
This bit indicates the status of received packets. This bit is set when the RWT bit is set in the ETH_MAC_RX_TX_STATUS register. This bit is cleared when the corresponding interrupt source bit is read (or corresponding interrupt source bit is written to 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set) in the ETH_MAC_RX_TX_STATUS register.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive interrupt status not active</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive interrupt status active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXSTSIS</name>
              <description>Transmit Status Interrupt
This bit indicates the status of transmitted packets. This bit is set when any of the following bits is set:
- ETH_MAC_RX_TX_STATUS[EXCOL]
- ETH_MAC_RX_TX_STATUS[LCOL]
- ETH_MAC_RX_TX_STATUS[EXDEF]
- ETH_MAC_RX_TX_STATUS[LCARR]
- ETH_MAC_RX_TX_STATUS[NCARR]
- ETH_MAC_RX_TX_STATUS[TJT]</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit interrupt status not active</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit interrupt status active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSIS</name>
              <description>Timestamp Interrupt Status
This bit is set when any of the following conditions is true:
- The ETH_MAC_TIMESTAMP_STATUS[TSTRGTERR0] bit is set.
- The ETH_MAC_TIMESTAMP_STATUS[TSTARGT0] bit is set.
- The ETH_MAC_TIMESTAMP_STATUS[TSSOVF] bit is set.
- When drop transmit status is enabled in MTL, this bit is set when the captured transmit timestamp is updated in the ETH_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS and ETH_MAC_TX_TIMESTAMP_STATUS_SECONDS registers.
This bit is cleared when the corresponding interrupt source bit is read in the ETH_MAC_TIMESTAMP_STATUS register or the corresponding interrupt source bit is written to 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timestamp interrupt status not active</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timestamp interrupt status active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PMTIS</name>
              <description>PMT Interrupt Status
This bit is set when a Magic packet or Wake-on-LAN packet is received in the power-down mode (the ETH_MAC_PMT_CONTROL_STATUS[RWKPRCVD] and ETH_MAC_PMT_CONTROL_STATUS[MGKPRCVD] bits). This bit is cleared when corresponding interrupt source bit are cleared because of a Read operation to the ETH_MAC_PMT_CONTROL_STATUS register (or corresponding interrupt source bit of ETH_MAC_PMT_CONTROL_STATUS register is written to 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>PMT interrupt status not active</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>PMT interrupt status active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PHYIS</name>
              <description>PHY Interrupt
This bit is set when rising edge is detected on the ETH_IRQ input. This bit is cleared when this register is read (or this bit is written to 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set).</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>PHY interrupt not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>PHY interrupt detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_INTERRUPT_ENABLE</name>
          <description>Interrupt Enable Register</description>
          <addressOffset>0xB4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFC7FF8</resetMask>
          <fields>
            <field>
              <name>MDIOIE</name>
              <description>MDIO Interrupt Enable
When this bit is set, it enables the assertion of the interrupt when the ETH_MAC_INTERRUPT_STATUS[MDIOIS] bit is set.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MDIO interrupt is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MDIO interrupt is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXSTSIE</name>
              <description>Receive Status Interrupt Enable
When this bit is set, it enables the assertion of the interrupt signal because of the setting of the ETH_MAC_INTERRUPT_STATUS[RXSTSIS] bit.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive status interrupt is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive status interrupt is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXSTSIE</name>
              <description>Transmit Status Interrupt Enable
When this bit is set, it enables the assertion of the interrupt signal because of the setting of the ETH_MAC_INTERRUPT_STATUS[TXSTSIS] bit.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit status interrupt is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit status interrupt is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSIE</name>
              <description>Timestamp Interrupt Enable
When this bit is set, it enables the assertion of the interrupt signal because of the setting of the ETH_MAC_INTERRUPT_STATUS[TSIS] bit.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timestamp interrupt is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timestamp interrupt is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PMTIE</name>
              <description>PMT Interrupt Enable
When this bit is set, it enables the assertion of the interrupt signal because of the setting of the ETH_MAC_INTERRUPT_STATUS[PMTIS] bit.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>PMT interrupt is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>PMT interrupt is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PHYIE</name>
              <description>PHY Interrupt Enable
When this bit is set, it enables the assertion of the interrupt signal because of the setting of the ETH_MAC_INTERRUPT_STATUS[PHYIS] bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>PHY interrupt is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>PHY interrupt is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_RX_TX_STATUS</name>
          <description>Receive Transmit Status Register</description>
          <addressOffset>0xB8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RWT</name>
              <description>Receive Watchdog Timeout
This bit is set when a packet with length greater than 2,048 bytes is received (10, 240 bytes when Jumbo Packet mode is enabled) and the ETH_MAC_CONFIGURATION[WD] bit is reset. This bit is also set when a packet with length greater than 16,383 bytes is received and the ETH_MAC_CONFIGURATION[WD] bit is set.
Access restriction applies. Clears on read (or write of 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set). Self-set to 1 on internal event.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No receive watchdog timeout</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive watchdog timed out</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EXCOL</name>
              <description>Excessive Collisions
When the ETH_MTL_OPERATION_MODE[DTXSTS] bit is set, this bit indicates that the transmission aborted after 16 successive collisions while attempting to transmit the current packet. If the DR bit is set in the ETH_MAC_CONFIGURATION register, this bit is set after the first collision and the packet transmission is aborted.
Access restriction applies. Clears on read (or write of 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set). Self-set to 1 on internal event.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No collision</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Excessive collision is sensed</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCOL</name>
              <description>Late Collision
When the ETH_MTL_OPERATION_MODE[DTXSTS] bit is set, this bit indicates that the packet transmission aborted because a collision occurred after the collision window (64 bytes including preamble).
This bit is not valid if the Underflow error occurs.
Access restriction applies. Clears on read (or write of 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set). Self-set to 1 on internal event.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No collision</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Late collision is sensed</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EXDEF</name>
              <description>Excessive Deferral
When the ETH_MTL_OPERATION_MODE[DTXSTS] bit is set and the DC bit is set in the ETH_MAC_CONFIGURATION register, this bit indicates that the transmission ended because of excessive deferral of over 24,288-bit times (155,680 when Jumbo packet is enabled).
Access restriction applies. Clears on read (or write of 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set). Self-set to 1 on internal event.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No excessive deferral</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Excessive deferral</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCARR</name>
              <description>Loss of Carrier
When the ETH_MTL_OPERATION_MODE[DTXSTS] bit is set, this bit indicates that the loss of carrier occurred during packet transmission, that is, the ETH_CRS_DV signal was inactive for one or more transmission clock periods during packet transmission. This bit is valid only for packets transmitted without collision.
Access restriction applies. Clears on read (or write of 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set). Self-set to 1 on internal event.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Carrier is present</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Loss of carrier</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NCARR</name>
              <description>No Carrier
When the ETH_MTL_OPERATION_MODE[DTXSTS] bit is set, this bit indicates that the carrier signal from the PHY is not present at the end of preamble transmission.
Access restriction applies. Clears on read (or write of 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set). Self-set to 1 on internal event.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Carrier is present</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>No carrier</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TJT</name>
              <description>Transmit Jabber Timeout
This bit indicates that the Transmit Jabber Timer expired which happens when the packet size exceeds 2,048 bytes (10,240 bytes when the Jumbo packet is enabled) and JD bit is reset in the ETH_MAC_CONFIGURATION register. This bit is set when the packet size exceeds 16,383 bytes and the JD bit is set in the ETH_MAC_CONFIGURATION register.
Access restriction applies. Clears on read (or write of 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set). Self-set to 1 on internal event.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No transmit jabber timeout</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit jabber timeout occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_PMT_CONTROL_STATUS</name>
          <description>PMT Control and Status Register</description>
          <addressOffset>0xC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RWKFILTRST</name>
              <description>Remote Wake-Up Packet Filter Register Pointer Reset
When this bit is set, the remote wake-up packet filter register pointer is reset to 0x0. It is automatically cleared after 1 clock cycle.
Access restriction applies. Setting 1 sets. Self-cleared. Setting 0 has no effect.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Remote wake-up packet filter register pointer is not reset</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Remote wake-up packet filter register pointer is reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RWKPTR</name>
              <description>Remote Wake-up FIFO Pointer
This field gives the current value of the Remote Wake-up Packet Filter register pointer.</description>
              <bitRange>[28:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RWKPFE</name>
              <description>Remote Wake-up Packet Forwarding Enable
When this bit is set along with RWKPKTEN, the MAC receiver drops all received frames until it receives the expected wake-up frame. All frames after that event including the received wake-up frame are forwarded to application. This bit is then self-cleared on receiving the wake-up packet. The application can also clear this bit before the expected wake-up frame is received. In such cases, the MAC reverts to the default behavior where packets received are forwarded to the application. This bit must only be set when RWKPKTEN is set high and PWRDWN is set low. The setting of this bit has no effect when PWRDWN is set high.
Note: If Magic Packet Enable and Wake-Up Frame Enable are both set along with setting of this bit and Magic Packet is received prior to wake-up frame, this bit is self-cleared on receiving Magic Packet, the received Magic packet is dropped, and all frames after received Magic Packet are forwarded to application.
Access restriction applies. Setting 1 sets. Self-cleared. Setting 0 has no effect.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Remote wake-up packet forwarding is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Remote wake-up packet forwarding is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GLBLUCAST</name>
              <description>Global Unicast
When this bit set, any unicast packet filtered by the MAC (DAF) address recognition is detected as a remote wake-up packet.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Global unicast is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Global unicast is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RWKPRCVD</name>
              <description>Remote Wake-Up Packet Received
When this bit is set, it indicates that the power management event is generated because of the reception of a remote wake-up packet. This bit is cleared when this register is read.
Access restriction applies. Clears on read or write of 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set. Self-set to 1 on internal event.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Remote wake-up packet is received</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Remote wake-up packet is received</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MGKPRCVD</name>
              <description>Magic Packet Received
When this bit is set, it indicates that the power management event is generated because of the reception of a magic packet. This bit is cleared when this register is read.
Access restriction applies. Clears on read or write of 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set. Self-set to 1 on internal event.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No magic packet is received</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Magic packet is received</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RWKPKTEN</name>
              <description>Remote Wake-Up Packet Enable
When this bit is set, a power management event is generated when the MAC receives a remote wake-up packet.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Remote wake-up packet is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Remote wake-up packet is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MGKPKTEN</name>
              <description>Magic Packet Enable
When this bit is set, a power management event is generated when the MAC receives a magic packet.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Magic packet is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Magic packet is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PWRDWN</name>
              <description>Power Down
When this bit is set, the MAC receiver drops all received packets until it receives the expected magic packet or remote wake-up packet. This bit is then self-cleared and the power-down mode is disabled. The software can clear this bit before the expected magic packet or remote wake-up packet is received. The packets received by the MAC after this bit is cleared are forwarded to the application. This bit must only be set when the MGKPKTEN, GLBLUCAST, or RWKPKTEN bit is set high.
Note: The user can gate-off the CLK_CSR during power-down mode. However, when the CLK_CSR is gated-off, the user cannot perform any read or write operations on this register. Therefore, software cannot clear this bit.
Access restriction applies. Setting 1 sets. Self-cleared. Setting 0 has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Power down is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Power down is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_RWK_PACKET_FILTER</name>
          <description>Remote Wakeup Filter Byte Mask Register</description>
          <addressOffset>0xC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WKUPFRMFTR</name>
              <description>RWK Packet Filter
This field contains the various controls of RWK Packet filter.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_RWK_FILTER_BYTE_MASK</name>
          <description>Remote Wakeup Filter Byte Mask Register</description>
          <alternateRegister>ETH_RWK_PACKET_FILTER</alternateRegister>
          <addressOffset>0xC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FILTER_BYTE_MASK</name>
              <description>Filter0 to Filter3 32-bit Mask
This field defines the bytes of the packet that are examined by the corresponding filter (0 to 3) to determine whether or not a packet is a wake-up packet. Bit 31 must be
zero. Bits [30-0] are the byte mask.
 Each bit in this mask corresponds to one byte in the detected packet. If the bit is 1, the corresponding byte is taken into the CRC16 calculation.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_RWK_FILTER_COMMAND</name>
          <description>Remote Wakeup Filter Command Register</description>
          <alternateRegister>ETH_RWK_PACKET_FILTER</alternateRegister>
          <addressOffset>0xC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FILTER3_COMMAND</name>
              <description>Filter3 Command
The 4-bit filter command controls the filter operation.
Bit 27 specifies the address type, defining the destination address type of the pattern. When the bit is set, the pattern applies to only multicast packets; when the bit is reset, the pattern applies only to unicast packet.
Bit 26 (Inverse Mode), when set, reverses the logic of the CRC16 hash function signal, to reject a packet with matching CRC_16 value.
Bit 26, along with Bit 25, allows a MAC to reject a subset of remote wake-up packets by creating filter logic such as Pattern 1 AND NOT Pattern 2.
Bit 25 (And_Previous) implements the Boolean logic. When set, the result of the current entry is logically ANDed with the result of the previous filter. This AND logic allows a filter pattern longer than 32 bytes by splitting the mask among two, three, or four filters. This depends on the number of filters that have the And_Previous bit set.
Bit 24 is the enable for filter. If Bit 24 is not set, filter is disabled.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER2_COMMAND</name>
              <description>Filter2 Command
The 4-bit filter command controls the filter operation.
Bit 19 specifies the address type, defining the destination address type of the pattern. When the bit is set, the pattern applies to only multicast packets; when the bit is reset, the pattern applies only to unicast packet.
Bit 18 (Inverse Mode), when set, reverses the logic of the CRC16 hash function signal, to reject a packet with matching CRC_16 value.
Bit 18, along with Bit 17, allows a MAC to reject a subset of remote wake-up packets by creating filter logic such as Pattern 1 AND NOT Pattern 2.
Bit 17 (And_Previous) implements the Boolean logic. When set, the result of the current entry is logically ANDed with the result of the previous filter. This AND logic allows a filter pattern longer than 32 bytes by splitting the mask among two, three, or four filters. This depends on the number of filters that have the And_Previous bit set.
Bit 16 is the enable for filter. If Bit 16 is not set, filter is disabled.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER1_COMMAND</name>
              <description>Filter1 Command
The 4-bit filter command controls the filter operation.
Bit 11 specifies the address type, defining the destination address type of the pattern. When the bit is set, the pattern applies to only multicast packets; when the bit is reset, the pattern applies only to unicast packet.
Bit 10 (Inverse Mode), when set, reverses the logic of the CRC16 hash function signal, to reject a packet with matching CRC_16 value.
Bit 10, along with Bit 9, allows a MAC to reject a subset of remote wake-up packets by creating filter logic such as Pattern 1 AND NOT Pattern 2.
Bit 9 (And_Previous) implements the Boolean logic. When set, the result of the current entry is logically ANDed with the result of the previous filter. This AND logic allows a filter pattern longer than 32 bytes by splitting the mask among two, three, or four filters. This depends on the number of filters that have the And_Previous bit set.
Bit 8 is the enable for filter. If Bit 8 is not set, filter is disabled.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER0_COMMAND</name>
              <description>Filter0 Command
The 4-bit filter command controls the filter operation.
Bit 3 specifies the address type, defining the destination address type of the pattern. When the bit is set, the pattern applies to only multicast packets; when the bit is reset, the pattern applies only to unicast packet.
Bit 2 (Inverse Mode), when set, reverses the logic of the CRC16 hash function signal, to reject a packet with matching CRC_16 value.
Bit 2, along with Bit 1, allows a MAC to reject a subset of remote wake-up packets by creating filter logic such as Pattern 1 AND NOT Pattern 2.
Bit 1 (And_Previous) implements the Boolean logic. When set, the result of the current entry is logically ANDed with the result of the previous filter. This AND logic allows a filter pattern longer than 32 bytes by splitting the mask among two, three, or four filters. This depends on the number of filters that have the And_Previous bit set.
Bit 0 is the enable for filter. If Bit 0 is not set, filter is disabled.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_RWK_FILTER_OFFSET</name>
          <description>Remote Wakeup Filter Offset Register</description>
          <alternateRegister>ETH_RWK_PACKET_FILTER</alternateRegister>
          <addressOffset>0xC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FILTER3_OFFSET</name>
              <description>Filter3 Offset
This filter offset defines the offset (within the packet) from which the filter examines the packets.
This 8-bit pattern-offset is the offset for the filter first byte to be examined.
The minimum allowed offset is 12, which refers to the 13th byte of the packet.
The offset value 0 refers to the first byte of the packet.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER2_OFFSET</name>
              <description>Filter2 Offset
This filter offset defines the offset (within the packet) from which the filter examines the packets.
This 8-bit pattern-offset is the offset for the filter first byte to be examined.
The minimum allowed offset is 12, which refers to the 13th byte of the packet.
The offset value 0 refers to the first byte of the packet.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER1_OFFSET</name>
              <description>Filter1 Offset
This filter offset defines the offset (within the packet) from which the filter examines the packets.
This 8-bit pattern-offset is the offset for the filter first byte to be examined.
The minimum allowed offset is 12, which refers to the 13th byte of the packet.
The offset value 0 refers to the first byte of the packet.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER0_OFFSET</name>
              <description>Filter0 Offset
This filter offset defines the offset (within the packet) from which the filter examines the packets.
This 8-bit pattern-offset is the offset for the filter first byte to be examined.
The minimum allowed offset is 12, which refers to the 13th byte of the packet.
The offset value 0 refers to the first byte of the packet.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_RWK_FILTER_CRC</name>
          <description>Remote Wakeup Filter CRC-16 Register</description>
          <alternateRegister>ETH_RWK_PACKET_FILTER</alternateRegister>
          <addressOffset>0xC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FILTER1_CRC</name>
              <description>Filter1 CRC-16
This filter CRC-16 contains the CRC_16 value of the pattern.
The 16-bit CRC calculation uses the following polynomial:
G(x) = x^16 + x^15 + x^2 + 1</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER0_CRC</name>
              <description>Filter0 CRC-16
This filter CRC-16 contains the CRC_16 value of the pattern.
The 16-bit CRC calculation uses the following polynomial:
G(x) = x^16 + x^15 + x^2 + 1</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_VERSION</name>
          <description>Module Version Register</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00001054</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>USERVER</name>
              <description>User-defined version</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SNPSVER</name>
              <description>Vendor-defined version</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_DEBUG</name>
          <description>Debug Register</description>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TFCSTS</name>
              <description>Reserved</description>
              <bitRange>[18:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TPESTS</name>
              <description>MAC RMII Transmit Protocol Engine Status
When this bit is set, it indicates that the MAC RMII transmit protocol engine is actively transmitting data, and it is not in the Idle state.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MAC RMII transmit protocol engine status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MAC RMII transmit protocol engine status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFCFCSTS</name>
              <description>Reserved</description>
              <bitRange>[2:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RPESTS</name>
              <description>MAC RMII Receive Protocol Engine Status
When this bit is set, it indicates that the MAC RMII receive protocol engine is actively receiving data, and it is not in the Idle state.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MAC RMII receive protocol engine status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MAC RMII receive protocol engine status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_HW_FEATURE0</name>
          <description>ETH Hardware Feature Register 0</description>
          <addressOffset>0x11C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x420152E5</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACTPHYSEL</name>
              <description>Active PHY Selected</description>
              <bitRange>[31:28]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>RMII</description>
                  <value>0x4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SAVLANINS</name>
              <description>Source Address or VLAN Insertion Enable</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Source address or VLAN insertion disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSSTSSEL</name>
              <description>Timestamp System Time Source</description>
              <bitRange>[26:25]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Internal</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MACADR64SEL</name>
              <description>MAC Addresses 64-127 Selected</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MAC addresses 64-127 disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MACADR32SEL</name>
              <description>MAC Addresses 32-63 Selected</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MAC addresses 32-63 disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADDMACADRSEL</name>
              <description>MAC Addresses 1-31 Selected</description>
              <bitRange>[22:18]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MAC addresses 1-31 disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXCOESEL</name>
              <description>Receive Checksum Offload Enabled</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive checksum offload enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXCOESEL</name>
              <description>Transmit Checksum Offload Enabled</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit checksum offload enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EEESEL</name>
              <description>Energy Efficient Ethernet Enabled</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Energy efficient ethernet disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSSEL</name>
              <description>IEEE 1588-2008 Timestamp Enabled</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>IEEE 1588-2008 timestamp enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ARPOFFSEL</name>
              <description>ARP Offload Enabled</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ARP offload disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MMCSEL</name>
              <description>RMON Module Enable</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RMON module disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MGKSEL</name>
              <description>PMT Magic Packet Enable</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>PMT magic packet enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RWKSEL</name>
              <description>PMT Remote Wake-up Packet Enable</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>PMT remote wake-up packet enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SMASEL</name>
              <description>SMA (MDIO) Interface</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SMA (MDIO) interface selected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VLHASH</name>
              <description>VLAN Hash Filter Selected</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>VLAN hash filter not selected</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PCSSEL</name>
              <description>PCS Registers (TBI, SGMII, or RTBI PHY interface)</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No PCS registers (TBI, SGMII, or RTBI PHY interface)</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HDSEL</name>
              <description>Half-duplex Support</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Half-duplex supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GMIISEL</name>
              <description>1000 Mbps Support</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No 1000 Mbps supported</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MIISEL</name>
              <description>10 or 100 Mbps Support</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>10 or 100 Mbps supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_HW_FEATURE1</name>
          <description>ETH Hardware Feature Register 1</description>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000C0124</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>L3L4FNUM</name>
              <description>Total number of L3 or L4 Filters</description>
              <bitRange>[30:27]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No L3 or L4 filter</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HASHTBLSZ</name>
              <description>Hash Table Size</description>
              <bitRange>[25:24]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No hash table</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>POUOST</name>
              <description>One Step for PTP over UDP/IP Enable</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>One step for PTP over UDP/IP is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RAVSEL</name>
              <description>Rx Side Only AV Enable</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Rx side only AV is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AVSEL</name>
              <description>AV Enable</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>AV fature is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBGMEMA</name>
              <description>DMA Debug Registers Enable</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA debug registers enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSOEN</name>
              <description>TCP Segmentation Offload Enable</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>TCP segmentation offload is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPHEN</name>
              <description>Split Header Enable</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Split header is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DCBEN</name>
              <description>DCB Enable</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DCB is not selected</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADDR64</name>
              <description>Address Width.</description>
              <bitRange>[15:14]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>32</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADVTHWORD</name>
              <description>IEEE 1588 High Word Register Enable</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>IEEE 1588 high word register is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PTOEN</name>
              <description>PTP Offload Enable</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>PTP offload is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OSTEN</name>
              <description>One-Step Timestamping Enable</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>One-step timestamping is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXFIFOSIZE</name>
              <description>MTL Transmit FIFO Size</description>
              <bitRange>[10:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>2048 bytes</description>
                  <value>0x4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPRAM</name>
              <description>Single Port RAM Enable</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Single port RAM is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFIFOSIZE</name>
              <description>MTL Receive FIFO Size</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>2048 bytes</description>
                  <value>0x4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_HW_FEATURE2</name>
          <description>ETH Hardware Feature Register 2</description>
          <addressOffset>0x124</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AUXSNAPNUM</name>
              <description>Number of Auxiliary Snapshot Inputs</description>
              <bitRange>[30:28]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No auxiliary input</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PPSOUTNUM</name>
              <description>Number of PPS Outputs</description>
              <bitRange>[26:24]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No PPS output</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TDCSZ</name>
              <description>Tx DMA Descriptor Cache Size in terms of 16-bytes descriptors</description>
              <bitRange>[23:22]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Cache not configured</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXCHCNT</name>
              <description>Number of DMA Transmit Channels</description>
              <bitRange>[21:18]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1 DMA Tx channel</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RDCSZ</name>
              <description>Rx DMA Descriptor Cache Size in terms of 16-bytes descriptors</description>
              <bitRange>[17:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Cache not configured</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXCHCNT</name>
              <description>Number of DMA Receive Channels</description>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1 DMA Rx channel</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXQCNT</name>
              <description>Number of MTL Transmit Queues</description>
              <bitRange>[9:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1 MTL Tx Queue</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXQCNT</name>
              <description>Number of MTL Receive Queues</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1 MTL Rx Queue</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_HW_FEATURE3</name>
          <description>ETH Hardware Feature Register 3</description>
          <addressOffset>0x128</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ASP</name>
              <description>Automotive Safety Package</description>
              <bitRange>[29:28]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No safety features selected</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBSSEL</name>
              <description>Time Based Scheduling Enable</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Time based scheduling disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FPESEL</name>
              <description>Frame Preemption Enable</description>
              <bitRange>[26:26]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Frame preemption disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ESTWID</name>
              <description>Width of the Time Interval field in the Gate Control List</description>
              <bitRange>[21:20]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Width not configured</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ESTDEP</name>
              <description>Depth of the Gate Control List</description>
              <bitRange>[19:17]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No depth configured</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ESTSEL</name>
              <description>Enhancements to Scheduled Traffic Enable</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Enhancements to scheduling traffic disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FRPES</name>
              <description>Flexible Receive Parser Table Entries size</description>
              <bitRange>[14:13]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>64 entries</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FRPBS</name>
              <description>Flexible Receive Parser Buffer size</description>
              <bitRange>[12:11]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>64 bytes</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FRPSEL</name>
              <description>Flexible Receive Parser Select</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Flexible receive parser disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PDUPSEL</name>
              <description>Broadcast/Multicast Packet Duplication</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Broadcast/multicast packet duplication disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DVLAN</name>
              <description>Double VLAN Tag Processing Select</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Double VLAN tag processing disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CBTISEL</name>
              <description>Queue/Channel based VLAN tag insertion on Tx Enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Queue/Channel based VLAN tag insertion on Tx disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NRVF</name>
              <description>Number of Extended VLAN Tag Filters Enable</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No extended Rx VLAN filters</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_HW_FEATURE4</name>
          <description>ETH Hardware Feature Register 3</description>
          <addressOffset>0x12C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PCSEL</name>
              <description>Policing Counters Selected</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Policing counter feature is not selected</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_MDIO_ADDRESS</name>
          <description>MDIO Address Register</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PSE</name>
              <description>Preamble Suppression Enable
When this bit is set, the MDIO suppresses the 32-bit preamble and transmits MDIO packets with only 1 preamble bit. When this bit is 0, the MDIO packets always has 32 bits of preamble as defined in the IEEE specifications.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Preamble suppression disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Preamble suppression enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BTB</name>
              <description>Back to Back Transactions
When this bit is set and if NTC &gt; 0, at the end of the frame transfer, MAC acknowledges the completion of a read or write command before transferring the trailing clocks. So, application can initiate the next command and MAC can execute it immediately without waiting for the transmission of the trailing clocks of the previous frame.
When this bit is reset, MAC considers the read or write command to be complete, that is, MAC clears the GB field, only after generating the trailing clocks. This mode ensures that the NTC is always generated after each frame.
Note: Program this field with a value 1, only when NTC &gt; 0.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Back to back transactions disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Back to back transactions enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PA</name>
              <description>Physical Layer Address
Specifies the address of the PHY device, out of the 32 possible PHY devices.
Note: The value programmed in the C45E field determines if the PHY device is Clause 45 capable or Clause 22 capable.</description>
              <bitRange>[25:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RDA</name>
              <description>Register or Device Address
- For Clause 22 PHY: Specifies the PHY register address of the selected PHY device.
- For Clause 45 PHY: Specifies the selected MDIO device.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NTC</name>
              <description>Number of Trailing Clocks
This field controls the number of trailing clock cycles generated on ETH_MDC after the end of MDIO frame transfer. The valid values can be from 0 to 7. When this field is programmed with a value of 0x3, MAC generates three clock cycles on the ETH_MDC line after the end of MDIO frame transfer.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CR</name>
              <description>CSR Clock (CLK_CSR) Range
The CLK_CSR range selection determines the frequency of the MDC clock (ETH_MDC) according to the CLK_CSR frequency:
The suggested range of CLK_CSR frequency applicable for each value (when Bit 11 = 0) ensures that the ETH_MDC is approximately between 1.0 MHz to 2.5 MHz freqency range.
When Bit 11 is set, the user can achieve a higher frequency of the ETH_MDC than the frequency limit of 2.5 MHz (specified in the IEEE 802.3 Specification) and program a clock divider of lower value. For example, when CLK_CSR is of 100 MHz frequency and the user programs the CR field to 0xA, the resultant ETH_MDC is of 12.5 MHz which is beyond the range specified in IEEE 802.3 Specification. Program the following values only if the interfacing chips support faster MDC clocks:</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>CLK_CSR = 60-100 MHz; ETH_MDC = CLK_CSR / 42</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CLK_CSR = 100-150 MHz; ETH_MDC = CLK_CSR / 62</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>CLK_CSR = 20-35 MHz; ETH_MDC = CLK_CSR / 16</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>CLK_CSR = 35-60 MHz; ETH_MDC = CLK_CSR / 26</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>CLK_CSR = 150-250 MHz; ETH_MDC = CLK_CSR / 102</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>CLK_CSR = 250-300 MHz; ETH_MDC = CLK_CSR / 124</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>CLK_CSR = 300-500 MHz; ETH_MDC = CLK_CSR / 204</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>CLK_CSR = 500-800 MHz; ETH_MDC = CLK_CSR / 324</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>CLK_CSR / 4</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>CLK_CSR / 6</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>CLK_CSR / 8</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>CLK_CSR / 10</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>CLK_CSR / 12</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xD</name>
                  <description>CLK_CSR / 14</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xE</name>
                  <description>CLK_CSR / 16</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description>CLK_CSR / 18</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SKAP</name>
              <description>Skip Address Packet
When this bit is set, the MDIO does not send the address packets before read, write, or post-read increment address packets. This bit is valid only when the C45E bit is set.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Skip address packet is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Skip address packet is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GOC_1</name>
              <description>Operation Command 1
This is the higher bit of the operation command to the PHY. GOC_1 and GOC_O are encoded as follows:
0x0: Reserved
0x1: Write
0x2: Post read increment address for Clause 45 PHY
0x3: Read
GOC_1 is encoded as follows:
0x0: Operation command 1 is disabled
0x1: Operation command 1 is enabled</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GOC_0</name>
              <description>Operation Command 0
This is the lower bit of the operation command to the PHY. When in MDIO mode (MDIO master) this bit along with GOC_1 determines the operation to be performed to the PHY.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Operation command 0 is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Operation command 0 is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>C45E</name>
              <description>Clause 45 PHY Enable
When this bit is set, Clause 45 capable PHY is connected to MDIO. When this bit is reset, Clause 22 capable PHY is connected to MDIO.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clause 45 PHY is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clause 45 PHY is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GB</name>
              <description>RMII Busy
The application writes 1 to this bit to instruct the SMA to initiate a read or write access to the MDIO slave.
The MAC writes 0 to this bit after the MDIO frame transfer is complete.
Therefore, the application must modify the fields of the ETH_MAC_MDIO_ADDRESS and ETH_MAC_MDIO_DATA registers only when the value in this bit is 0.
 For write operation, application must follow these steps:
- Write the 16-bit data in the ETH_MAC_MDIO_DATA[GD] field.
- Update the ETH_MAC_MDIO_DATA[RA] field with the register address of the PHY.
- Write 1 to this bit
For read operation, application must follow these steps:
- Update the ETH_MAC_MDIO_DATA[RA] field with the register address of the PHY.
- Write 1 to this bit
- Wait until MAC writes 0 to this bit. When MAC writes 0 to this bit, it implies that the data read from the PHY is available in the ETH_MAC_MDIO_DATA[GD] field and the read transfer is complete.
Note: RA field is valid only when C45E field is 1.
Note: Even if the addressed PHY is not present, there is no change in the functionality of this bit.
Access restriction applies. Setting 1 sets. Self-cleared. Setting 0 has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RMII busy is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RMII busy is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_MDIO_DATA</name>
          <description>MDIO Data Register</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RA</name>
              <description>Register Address
This field is valid only when the ETH_MAC_MDIO_ADDRESS[C45E] bit is set. It contains the Register Address in the PHY to which the MDIO frame is intended for.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GD</name>
              <description>RMII Data
This field contains the 16-bit data value read from the PHY after a Management Read operation or the 16-bit data value to be written to the PHY before a Management Write operation.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_GPIO_CONTROL</name>
          <description>GPIO Control Register</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIT</name>
              <description>GPI Type
When a bit in this field is set, it indicates that the corresponding bit in the ETH_MAC_GPIO_STATUS[GPIS] field is of latched-low (LL) type. When a bit in this field is reset, it indicates that the corresponding bit in the ETH_MAC_GPIO_STATUS[GPIS] field is of latched-high (LH) type.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIE</name>
              <description>GPI Interrupt Enable
When a bit in this field is set and the programmed event (LL or LH) occurs on the corresponding bit in the ETH_MAC_GPIO_STATUS[GPIS] field, the ETH_MAC_INTERRUPT_STATUS[GPIIS] bit is set and an interrupt is generated on the ETH_SBD_IRQ signal. The ETH_MAC_INTERRUPT_STATUS[GPIIS] bit is cleared when the application reads the ETH_MAC_GPIO_STATUS[GPIS] field.
When a bit in this field is reset, the ETH_MAC_INTERRUPT_STATUS[GPIIS] bit is not set when any event occurs on the corresponding bit in the ETH_MAC_GPIO_STATUS[GPIS] field.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_GPIO_STATUS</name>
          <description>GPIO Status Register</description>
          <addressOffset>0x20C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPO</name>
              <description>General Purpose Output
When a bit in this field is set, it directly drives the corresponding bit of the GPO_O output port. When a bit in this field is reset, it does not directly drive the corresponding bit of the GPO_O output port.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIS</name>
              <description>General Purpose Input Status
This field gives the status of the signals connected to the GPI_I port. Each bit in this field is of the following types based on the setting of the corresponding bit in the ETH_MAC_GPIO_CONTROL[GPIT] field:
- Latched-low (LL): This field is cleared when the corresponding GPI_I input becomes low. This field remains low until the application reads it after which this field reflects the current value of GPI_I input.
- Latched-high (LH): This field is set when the corresponding GPI_I input becomes high. This field remains high until the application reads it after which this field reflects the current value of GPI_I input.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_ARP_ADDRESS</name>
          <description>ARP Address Register</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ARPPA</name>
              <description>ARP Protocol Address
This field contains the IPv4 Destination Address of the MAC. This address is used for perfect match with the Protocol Address of Target field in the received ARP packet.
This field is available only when the Enable IPv4 ARP Offload option is selected.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_CSR_SW_CTRL</name>
          <description>CSR Software Control Register</description>
          <addressOffset>0x230</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SEEN</name>
              <description>Slave Error Response Enable
When this bit is set, the MAC responds with Slave Error for accesses to reserved registers in CSR space.
When this bit is reset, the MAC responds with OKAY response to any register accessed from CSR space.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slave error response is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slave error response is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RCWE</name>
              <description>Register Clear on Write 1 Enable
When this bit is set, the access mode of some register fields changes to Clear on Write 1, the application needs to set that respective bit to 1 to clear it.
When this bit is reset, the access mode of these register fields remain as Clear on Read.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Register clear on write 1 is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Register clear on write 1 is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_ADDRESS0_HIGH</name>
          <description>MAC Address 0 High Register</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x8000FFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AE</name>
              <description>Address Enable
This bit is always set to 1.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Ivalid. This bit must be always set to 1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>This bit is always set to 1</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADDRHI</name>
              <description>MAC Address0[47-32]
This field contains the upper 16 bits [47-32] of the first 6-byte MAC address. The MAC uses this field for filtering the received packets and inserting the MAC address in the Transmit Flow Control (Pause) Packets.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_ADDRESS0_LOW</name>
          <description>MAC Address 0 Low Register</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDRLO</name>
              <description>MAC Address0[31-0]
This field contains the lower 32 bits of the first 6-byte MAC address. The MAC uses this field for filtering the received packets and inserting the MAC address in the Transmit Flow Control (Pause) Packets.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_TIMESTAMP_CONTROL</name>
          <description>Timestamp Control Register</description>
          <addressOffset>0xB00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00002000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AV8021ASMEN</name>
              <description>AV 802.1AS Mode Enable
When this bit is set, the MAC processes only untagged PTP over Ethernet packets for providing PTP status and capturing timestamp snapshots, that is, IEEE 802.1AS mode of operation.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>AV 802.1AS mode is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>AV 802.1AS mode is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXTSSTSM</name>
              <description>Transmit Timestamp Status Mode
When this bit is set, the MAC overwrites the earlier transmit timestamp status even if it is not read by the software. The MAC indicates this by setting the ETH_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS[TXTSSMIS] bit.
When this bit is reset, the MAC ignores the timestamp status of current packet if the timestamp status of previous packet is not read by the software. The MAC indicates this by setting the ETH_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS[TXTSSMIS] bit.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit timestamp status mode is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit timestamp status mode is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSENMACADDR</name>
              <description>Enable MAC Address for PTP Packet Filtering
When this bit is set, the DA MAC address (that matches ETH_MAC_ADDRESS0_HIGH[ADDRHI] and ETH_MAC_ADDRESS0_LOW[ADDRLO]) is used to filter the PTP packets when PTP is directly sent over Ethernet.
When this bit is set, received PTP packets with DA containing a special multicast or unicast address that matches the one programmed in the ETH_MAC_ADDRESS0_HIGH and ETH_MAC_ADDRESS0_LOW registers are considered for processing, when PTP is directly sent over Ethernet.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MAC address for PTP packet filtering is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MAC address for PTP packet filtering is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SNAPTYPSEL</name>
              <description>Select PTP packets for Taking Snapshots
This field, along with the TSMSTRENA and TSEVNTENA bits, decide the set of PTP packet types for which snapshot needs to be taken. The encoding is as follows:
- SNAPTYPSEL = 0x0; TSMSTRENA = X; TSEVNTENA = 0x0:
 SYNC, Follow_Up, Delay_Req, Delay_Resp
- SNAPTYPSEL = 0x0; TSMSTRENA = 0x0; TSEVNTENA = 0x1:
 SYNC
- SNAPTYPSEL = 0x0; TSMSTRENA = 0x1; TSEVNTENA = 0x1:
 Delay_Req
- SNAPTYPSEL = 0x1; TSMSTRENA = X; TSEVNTENA = 0x0:
 SYNC, Follow_Up, Delay_Req, Delay_Resp, Pdelay_Req, Pdelay_Resp, Pdelay_Resp_Follow_Up
- SNAPTYPSEL = 0x1; TSMSTRENA = 0x0; TSEVNTENA = 0x1:
 SYNC, Pdelay_Req, Pdelay_Resp
- SNAPTYPSEL = 0x1; TSMSTRENA = 0x1; TSEVNTENA = 0x1:
 Delay_Req, Pdelay_Req, Pdelay_Resp
- SNAPTYPSEL = 0x2; TSMSTRENA = X; TSEVNTENA = X:
 SYNC, Delay_Req
- SNAPTYPSEL = 0x3; TSMSTRENA = X; TSEVNTENA = X:
 Pdelay_Req, Pdelay_Resp
Note: X means 'don't care'.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TSMSTRENA</name>
              <description>Enable Snapshot for Messages Relevant to Master
When this bit is set, the snapshot is taken only for the messages that are relevant to the master node. Otherwise, the snapshot is taken for the messages relevant to the slave node.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Snapshot for messages relevant to master is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Snapshot for messages relevant to master is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSEVNTENA</name>
              <description>Enable Timestamp Snapshot for Event Messages
When this bit is set, the timestamp snapshot is taken only for event messages (SYNC, Delay_Req, Pdelay_Req, or Pdelay_Resp). When this bit is reset, the snapshot is taken for all messages except Announce, Management, and Signaling.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timestamp snapshot for event messages is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timestamp snapshot for event messages is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSIPV4ENA</name>
              <description>Enable Processing of PTP Packets Sent over IPv4-UDP
When this bit is set, the MAC receiver processes the PTP packets encapsulated in IPv4-UDP packets. When this bit is reset, the MAC ignores the PTP transported over IPv4-UDP packets. This bit is set by default.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Processing of PTP packets sent over IPv4-UDP is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Processing of PTP packets sent over IPv4-UDP is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSIPV6ENA</name>
              <description>Enable Processing of PTP Packets Sent over IPv6-UDP
When this bit is set, the MAC receiver processes the PTP packets encapsulated in IPv6-UDP packets. When this bit is clear, the MAC ignores the PTP transported over IPv6-UDP packets.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Processing of PTP packets sent over IPv6-UDP is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Processing of PTP packets sent over IPv6-UDP is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSIPENA</name>
              <description>Enable Processing of PTP over Ethernet Packets
When this bit is set, the MAC receiver processes the PTP packets encapsulated directly in the Ethernet packets. When this bit is reset, the MAC ignores the PTP over Ethernet packets.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Processing of PTP over Ethernet packets is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Processing of PTP over Ethernet packets is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSVER2ENA</name>
              <description>Enable PTP Packet Processing for Version 2 Format
When this bit is set, the IEEE 1588 version 2 format is used to process the PTP packets. When this bit is reset, the IEEE 1588 version 1 format is used to process the PTP packets.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>PTP packet processing for version 2 format is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>PTP packet processing for version 2 format is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSCTRLSSR</name>
              <description>Timestamp Digital or Binary Rollover Control
When this bit is set, the ETH_MAC_SYSTEM_TIME_NANOSECONDS register rolls over after 0x3B9A_C9FF value (that is, 1 nanosecond accuracy) and increments the ETH_MAC_SYSTEM_TIME_SECONDS register. When this bit is reset, the rollover value of the ETH_MAC_SYSTEM_TIME_NANOSECONDS register is 0x7FFF_FFFF. The sub-second increment must be programmed correctly depending on the CLK_PTP frequency and the value of this bit.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timestamp digital or binary rollover control is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timestamp digital or binary rollover control is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSENALL</name>
              <description>Enable Timestamp for All Packets
When this bit is set, the timestamp snapshot is enabled for all packets received by the MAC.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timestamp for all packets disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timestamp for all packets enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSADDREG</name>
              <description>Update the ETH_MAC_TIMESTAMP_ADDEND register
When this bit is set, the content of the ETH_MAC_TIMESTAMP_ADDEND register is updated in the PTP block for fine correction. This bit is cleared when the update is complete. This bit must be zero before it is set.
Access restriction applies. Setting 1 sets. Self-cleared. Setting 0 has no effect.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Addend register is not updated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Addend register is updated</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSTRIG</name>
              <description>Enable Timestamp Interrupt Trigger
When this bit is set, the timestamp interrupt is generated when the System Time becomes greater than the value written in the Target Time register. This bit is reset after the Timestamp Trigger Interrupt is generated.
Access restriction applies. Setting 1 sets. Self-cleared. Setting 0 has no effect.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timestamp interrupt trigger is not enabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timestamp interrupt trigger is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSUPDT</name>
              <description>Update Timestamp
When this bit is set, the system time is updated (added or subtracted) with the value specified in ETH_MAC_SYSTEM_TIME_SECONDS_UPDATE and ETH_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE registers.
This bit must be zero before updating it. This bit is reset when the update is complete in hardware.
Access restriction applies. Setting 1 sets. Self-cleared. Setting 0 has no effect.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timestamp is not updated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timestamp is updated</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSINIT</name>
              <description>Initialize Timestamp
When this bit is set, the system time is initialized (overwritten) with the value specified in the ETH_MAC_SYSTEM_TIME_SECONDS_UPDATE and ETH_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE registers.
This bit must be zero before it is updated. This bit is reset when the initialization is complete. Only the ETH_MAC_SYSTEM_TIME_SECONDS register can be initialized.
Access restriction applies. Setting 1 sets. Self-cleared. Setting 0 has no effect.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timestamp is not initialized</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timestamp is initialized</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSCFUPDT</name>
              <description>Fine or Coarse Timestamp Update
When this bit is set, the Fine method is used to update system timestamp. When this bit is reset, Coarse method is used to update the system timestamp.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Coarse method is used to update system timestamp</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Fine method is used to update system timestamp</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSENA</name>
              <description>Enable Timestamp
When this bit is set, the timestamp is added for Transmit and Receive packets. When disabled, timestamp is not added for transmit and receive packets and the Timestamp Generator is also suspended. The user needs to initialize the Timestamp (system time) after enabling this mode.
On the Receive side, the MAC processes the 1588 packets only if this bit is set.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timestamp is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timestamp is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_SUB_SECOND_INCREMENT</name>
          <description>Sub-second Increment Register</description>
          <addressOffset>0xB04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF0000</resetMask>
          <fields>
            <field>
              <name>SSINC</name>
              <description>Sub-second Increment Value
The value programmed in this field is accumulated every clock cycle (of CLK_PTP) with the contents of the ETH_MAC_SYSTEM_TIME_NANOSECONDS register. For example, when the PTP clock is 50 MHz (period is 20 ns), the user must program 20 (0x14) when the ETH_MAC_SYSTEM_TIME_NANOSECONDS register has an accuracy of 1 ns (the ETH_MAC_TIMESTAMP_CONTROL[TSCTRLSSR] bit is set). When TSCTRLSSR is cleard, the ETH_MAC_SYSTEM_TIME_NANOSECONDS register has a resolution of ~0.465 ns. In this case, the user must program a value of 43 (0x2B) which is derived by 20 ns/0.465.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_SYSTEM_TIME_SECONDS</name>
          <description>System Time Seconds Register</description>
          <addressOffset>0xB08</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSS</name>
              <description>Timestamp Second
The value in this field indicates the current value in seconds of the System Time maintained by the MAC.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_SYSTEM_TIME_NANOSECONDS</name>
          <description>System Time Nanoseconds Register</description>
          <addressOffset>0xB0C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSSS</name>
              <description>Timestamp Sub Seconds
The value in this field has the sub-second representation of time, with an accuracy of 0.46 ns. When the ETH_MAC_TIMESTAMP_CONTROL[TSCTRLSSR] bit is set, each bit represents 1 ns. The maximum value is 0x3B9A_C9FF after which it rolls-over to zero.</description>
              <bitRange>[30:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_SYSTEM_TIME_SECONDS_UPDATE</name>
          <description>System Time Seconds Update Register</description>
          <addressOffset>0xB10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSS</name>
              <description>Timestamp Seconds
The value in this field is the seconds part of the update.
When ETH_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE[ADDSUB] is reset, this field must be programmed with the seconds part of the update value.
When ETH_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE[ADDSUB] is set, this field must be programmed with the complement of the seconds part of the update value.
For example, to subtract 2.000000001 seconds from the system time, the TSS field must be 0xFFFF_FFFE (that is, 2^32 - 2).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE</name>
          <description>System Time Nanoseconds Update Register</description>
          <addressOffset>0xB14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDSUB</name>
              <description>Add or Subtract Time
When this bit is set, the time value is subtracted with the contents of the update register. When this bit is reset, the time value is added with the contents of the update register.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Add time</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Subtract time</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSSS</name>
              <description>Timestamp Sub Seconds
The value in this field is the sub-seconds part of the update.
When ETH_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE[ADDSUB] is reset, this field must be programmed with the sub-seconds part of the update value, with an accuracy based on the ETH_MAC_TIMESTAMP_CONTROL[TSCTRLSSR] bit.
When ETH_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE[ADDSUB] is set, this field must be programmed with the complement of the sub-seconds part of the update value as described below.
When the ETH_MAC_TIMESTAMP_CONTROL[TSCTRLSSR] bit set, the programmed value must be 10^9 - &lt;sub-second value&gt;. When the ETH_MAC_TIMESTAMP_CONTROL[TSCTRLSSR] bit reset, the programmed value must be 2^31 - &lt;sub-second_value&gt;.
When the TSCTRLSSR bit is reset in the ETH_MAC_TIMESTAMP_CONTROL register, each bit represents an accuracy of 0.46 ns. When the TSCTRLSSR bit is set in the ETH_MAC_TIMESTAMP_CONTROL register, each bit represents 1 ns and the programmed value should not exceed 0x3B9A_C9FF.
For example, to subtract 2.000000001 seconds from the system time, then the TSSS field must be 0x7FFF_FFFF (that is, 2^31 - 1), when the ETH_MAC_TIMESTAMP_CONTROL[TSCTRLSSR] bit reset and 0x3B9A_C9FF (that is, 10^9 - 1), when the ETH_MAC_TIMESTAMP_CONTROL[TSCTRLSSR] bit set.</description>
              <bitRange>[30:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_TIMESTAMP_ADDEND</name>
          <description>Timestamp Addend Register</description>
          <addressOffset>0xB18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSAR</name>
              <description>Timestamp Addend Register
This field indicates the 32-bit time value to be added to the Accumulator register to achieve time synchronization.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_TIMESTAMP_STATUS</name>
          <description>Timestamp Status Register</description>
          <addressOffset>0xB20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFB</resetMask>
          <fields>
            <field>
              <name>TXTSSIS</name>
              <description>Tx Timestamp Status Interrupt Status
When drop transmit status is enabled in MTL, this bit is set when the captured transmit timestamp is updated in the ETH_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS and ETH_MAC_TX_TIMESTAMP_STATUS_SECONDS registers.
This bit is cleared when the ETH_MAC_TX_TIMESTAMP_STATUS_SECONDS register is read (or write to ETH_MAC_TX_TIMESTAMP_STATUS_SECONDS register when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Tx timestamp status interrupt status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Tx timestamp status interrupt status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSTRGTERR0</name>
              <description>Timestamp Target Time Error
This bit is set when the latest target time programmed in the ETH_MAC_PPS0_TARGET_TIME_SECONDS and ETH_MAC_PPS0_TARGET_TIME_NANOSECONDS registers elapses.
Access restriction applies. Clears on read (or this bit is written to 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set). Self-set to 1 on internal event.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timestamp target time error status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timestamp target time error status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSTARGT0</name>
              <description>Timestamp Target Time Reached
When this bit is set, it indicates that the value of system time is greater than or equal to the value specified in the ETH_MAC_PPS0_TARGET_TIME_SECONDS and ETH_MAC_PPS0_TARGET_TIME_NANOSECONDS registers.
Access restriction applies. Clears on read (or this bit is written to 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set). Self-set to 1 on internal event.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timestamp target time reached status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timestamp target time reached status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSSOVF</name>
              <description>Timestamp Seconds Overflow
When this bit is set, it indicates that the ETH_MAC_SYSTEM_TIME_SECONDS[TSS] value has overflowed beyond 0xFFFF_FFFF.
Access restriction applies. Clears on read (or this bit is written to 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set). Self-set to 1 on internal event.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timestamp seconds overflow status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timestamp seconds overflow status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_RX_DOMAIN_TIME_INCR</name>
          <description>Rx Domain Time Increment Register</description>
          <addressOffset>0xB24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXNS</name>
              <description>Receive Domain Time Increment Value in Nanoseconds
This field indicates the Nanosecond part of the increment value of the PTP time maintained in Receive clock domain that is used for timestamping.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_TX_DOMAIN_TIME_INCR</name>
          <description>Tx Domain Time Increment Register</description>
          <addressOffset>0xB28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXNS</name>
              <description>Transmit Domain Time Increment Value in Nanoseconds
This field indicates the Nanosecond part of the increment value of the PTP time maintained in Transmit clock domain that is used for timestamping.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS</name>
          <description>Transmit Timestamp Status Nanoseconds Register</description>
          <addressOffset>0xB30</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXTSSMIS</name>
              <description>Transmit Timestamp Status Missed
When this bit is set, it indicates one of the following:
The timestamp of the current packet is ignored if the ETH_MAC_TIMESTAMP_CONTROL[TXTSSTSM] bit is reset
The timestamp of the previous packet is overwritten with timestamp of the current packet if the ETH_MAC_TIMESTAMP_CONTROL[TXTSSTSM] bit is set.
Access restriction applies. Clears on read. Self-set to 1 on internal event.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit timestamp status missed status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit timestamp status missed status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXTSSLO</name>
              <description>Transmit Timestamp Status Low
This field contains the 31 bits of the Nanoseconds field of the Transmit packet's captured timestamp.</description>
              <bitRange>[30:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_TX_TIMESTAMP_STATUS_SECONDS</name>
          <description>Transmit Timestamp Status Seconds Register</description>
          <addressOffset>0xB34</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXTSSHI</name>
              <description>Transmit Timestamp Status High
This field contains the lower 32 bits of the Seconds field of Transmit packet's captured timestamp.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND</name>
          <description>Timestamp Ingress Correction Nanoseconds Register</description>
          <addressOffset>0xB58</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSIC</name>
              <description>Timestamp Ingress Correction
This field contains the ingress path correction value as defined by the Ingress Correction expression.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND</name>
          <description>Timestamp Egress Correction Nanoseconds Register</description>
          <addressOffset>0xB5C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSEC</name>
              <description>Timestamp Egress Correction
This field contains the nanoseconds part of the egress path correction value as defined by the Egress Correction expression.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_TIMESTAMP_INGRESS_LATENCY</name>
          <description>Ingress MAC latency Register</description>
          <addressOffset>0xB68</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x03200000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ITLNS</name>
              <description>Ingress Timestamp Latency, in nanoseconds
This register holds the average latency in nanoseconds between the input ports (ETH_RXD[1-0]) of MAC and the actual point (RMII) where the ingress timestamp is taken.</description>
              <bitRange>[27:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ITLSNS</name>
              <description>Ingress Timestamp Latency, in sub-nanoseconds
This register holds the average latency in sub-nanoseconds between the input ports (ETH_RXD[1-0]) of MAC and the actual point (RMII) where the ingress timestamp is taken.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_TIMESTAMP_EGRESS_LATENCY</name>
          <description>Egress MAC latency Register</description>
          <addressOffset>0xB6C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x01900000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ETLNS</name>
              <description>Egress Timestamp Latency, in nanoseconds
This register holds the average latency in nanoseconds between the actual point (RMII) where the egress timestamp is taken and the output ports (ETH_TXD[1-0]) of the MAC.</description>
              <bitRange>[27:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ETLSNS</name>
              <description>Egress Timestamp Latency, in sub-nanoseconds
This register holds the average latency in sub-nanoseconds between the actual point (RMII) where the egress timestamp is taken and the output ports (ETH_TXD[1-0]) of the MAC.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_PPS_CONTROL</name>
          <description>PPS Control Register</description>
          <addressOffset>0xB70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>PPSCTRL</name>
              <description>Pulse Per Second (PPS) Frequency Control
This field controls the PPS frequency. The default value of PPSCTRL is 0x0, and the PPS frequency is 1 pulse every second. For other values of PPSCTRL, the PPS becomes a generated clock of the following frequencies:
Note:
In the binary rollover mode, the PPS frequency has a duty cycle of 50 percent with these frequencies.
In the digital rollover mode, the PPS frequency is an average number. The actual clock is of different frequency that gets synchronized every second. For example:
When PPSCTRL = 0x1, the PPS (1 Hz) has a low period of 537 ms and a high period of 463 ms
When PPSCTRL = 0x2, the PPS (2 Hz) is a sequence of:
- One clock of 50 percent duty cycle and 537 ms period
- Second clock of 463 ms period (268 ms low and 195 ms high)
When PPSCTRL = 0x3, the PPS (4 Hz) is a sequence of:
- Fourth clock of 195 ms period (134 ms low and 61 ms high)
This behavior is because of the non-linear toggling of bits in the digital rollover mode in the ETH_MAC_SYSTEM_TIME_NANOSECONDS register.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The binary rollover is 2 Hz, and the digital rollover is 1 Hz.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>The binary rollover is 4 Hz, and the digital rollover is 2 Hz.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>The binary rollover is 8 Hz, and the digital rollover is 4 Hz.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>The binary rollover is 16 Hz, and the digital rollover is 8 Hz.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description>The binary rollover is 32.768 kHz and the digital rollover is 16.384 kHz.</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_PPS0_TARGET_TIME_SECONDS</name>
          <description>PPS0 Target Time Seconds Register</description>
          <addressOffset>0xB80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSTRH0</name>
              <description>PPS Target Time Seconds
This field stores the time in seconds. When the timestamp value matches or exceeds both ETH_MAC_PPS0_TARGET_TIME_SECONDS and ETH_MAC_PPS0_TARGET_TIME_NANOSECONDS registers, the MAC generates an interrupt (if enabled).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_PPS0_TARGET_TIME_NANOSECONDS</name>
          <description>PPS0 Target Time Nanoseconds Register</description>
          <addressOffset>0xB84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x7FFFFFFF</resetMask>
          <fields>
            <field>
              <name>TTSL0</name>
              <description>Target Time Low for PPS Register
This register stores the time in (signed) nanoseconds. When the value of the timestamp matches the value in both ETH_MAC_PPS0_TARGET_TIME_SECONDS and ETH_MAC_PPS0_TARGET_TIME_NANOSECONDS registers, the MAC generates an interrupt (if enabled).
When the ETH_MAC_TIMESTAMP_CONTROL[TSCTRLSSR] bit is reset, this value must be (time in ns / 0.465).
When the ETH_MAC_TIMESTAMP_CONTROL[TSCTRLSSR] bit is set, this value must not exceed 0x3B9A_C9FF.
Access restriction applies. Setting 1 sets. Self-cleared. Setting 0 has no effect.</description>
              <bitRange>[30:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MTL_OPERATION_MODE</name>
          <description>Operation Mode Register</description>
          <addressOffset>0xC00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTCLR</name>
              <description>Counters Reset
When this bit is set, all counters are reset. This bit is cleared automatically after 1 clock cycle.
If this bit is set along with the CNTPRST bit, CNTPRST has precedence.
Access restrictions apply.
MAC initiates the counters reset when application writes 1.
MAC writes 0 after the counters reset is complete.
MAC ignores when application writes 0.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Counters are not reset</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>All counters are reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CNTPRST</name>
              <description>Counters Preset
When this bit is set,
The ETH_MTL_TXQ0_UNDERFLOW register is initialized/preset to 0x7F0.
The ETH_MTL_RXQ0_MISSED_PACKET_OVERFLOW_CNT[MISPKTCNT] and ETH_MTL_RXQ0_MISSED_PACKET_OVERFLOW_CNT[OVFPKTCNT] fields are initialized/preset to 0x7F0.
MAC initiates the counters reset when application writes 1.
MAC writes 0 after the counters reset is complete.
MAC ignores when application writes 0.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Counters preset is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Counters preset is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTXSTS</name>
              <description>Drop Transmit Status
When this bit is set, the Tx packet status received from the MAC is dropped in the MTL. When this bit is reset, the Tx packet status received from the MAC is forwarded to the application.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Drop transmit status is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Drop transmit status is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MTL_DBG_CTL</name>
          <description>FIFO Debug Access Control and Status Register</description>
          <addressOffset>0xC08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STSIE</name>
              <description>Transmit Status Available Interrupt Status Enable
When this bit is set, an interrupt is generated when Transmit status is available in slave mode.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit packet available interrupt status is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit packet available interrupt status is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PKTIE</name>
              <description>Receive Packet Available Interrupt Status Enable
When this bit is set, an interrupt is generated when EOP of received packet is written to the Rx FIFO.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive packet available interrupt status is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive packet available interrupt status is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FIFOSEL</name>
              <description>FIFO Selected for Access
This field indicates the FIFO selected for debug access:</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Tx FIFO</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Tx Status FIFO (only read access when SLVMOD is set) / DC Memory FIFO read-write access when DBGMOD is set</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>TSO FIFO (cannot be accessed when SLVMOD is set)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Rx FIFO</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FIFOWREN</name>
              <description>FIFO Write Enable
When this bit is set, it enables the Write operation on selected FIFO when FIFO Debug Access is enabled.
This bit must not be written to 1 when FIFO Debug Access is not enabled, that is FDBGEN bit is 0.
Access restriction applies. Self-cleared. Setting 0 clears. Setting 1 sets.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>FIFO write is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>FIFO write is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FIFORDEN</name>
              <description>FIFO Read Enable
When this bit is set, it enables the Read operation on selected FIFO when FIFO Debug Access is enabled.
This bit must not be written to 1 when FIFO Debug Access is not enabled, that is FDBGEN bit is 0.
Access restriction applies. Self-cleared. Setting 0 clears. Setting 1 sets.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>FIFO read is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>FIFO read is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RSTSEL</name>
              <description>Reset Pointers of Selected FIFO
When this bit is set, the pointers of the currently-selected FIFO are reset when FIFO Debug Access is enabled.
This bit must not be written to 1 when FIFO Debug Access is not enabled, that is FDBGEN bit is 0.
Access restriction applies. Self-cleared. Setting 0 clears. Setting 1 sets.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Reset pointers of selected FIFO is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Reset pointers of selected FIFO is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RSTALL</name>
              <description>Reset All Pointers
When this bit is set, the pointers of all FIFOs are reset when FIFO Debug Access is enabled.
This bit must not be written to 1 when FIFO Debug Access is not enabled, that is FDBGEN bit is 0.
Access restriction applies. Self-cleared. Setting 0 clears. Setting 1 sets.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Reset all pointers is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Reset all pointers is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PKTSTATE</name>
              <description>Encoded Packet State
This field is used to write the control information to the Tx FIFO or Rx FIFO.
Tx FIFO:
0x0: Packet data
0x1: Control word
0x2: SOP data
0x3: EOP data
Rx FIFO:
0x0: Packet data
0x1: Normal status
0x2: Last status
0x3: EOP</description>
              <bitRange>[6:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTEEN</name>
              <description>Byte Enables
This field indicates the number of data bytes valid in the data register during Write operation. This is valid only when PKTSTATE is 0x2 (EOP) and Tx FIFO or Rx FIFO is selected.</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Byte 0 valid</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Byte 0 and Byte 1 are valid</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Byte 0, Byte 1, and Byte 2 are valid</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>All four bytes are valid</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBGMOD</name>
              <description>Debug Mode Access to FIFO
When this bit is set, it indicates that the current access to the FIFO is read, write, and debug access (that is, data can be written and read to specified or all locations through FIFO Debug Interface). In this mode, the following access types are allowed:
- Read and Write access to Tx FIFO, TSO FIFO, DCACHE FIFO and Rx FIFO
- Read access is allowed to Tx Status FIFO.
When this bit is reset, it indicates that the current access to the FIFO is slave access bypassing the DMA (that is, packets can be transmitted or received through FIFO Debug Interface). In this mode, the following access are allowed:
- Write access to the Tx FIFO
- Read access to the Rx FIFO and Tx Status FIFO</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Debug mode access to FIFO is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Debug mode access to FIFO is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FDBGEN</name>
              <description>FIFO Debug Access Enable
When this bit is set, it indicates that the debug mode access to the FIFO through CSR Slave Interface is enabled. When this bit is reset, it indicates that the FIFO can be accessed only through a master interface.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>FIFO debug access through CSR Slave Interface is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>FIFO debug access through CSR Slave Interface is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MTL_DBG_STS</name>
          <description>FIFO Debug Status Register</description>
          <addressOffset>0xC0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00800018</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCR</name>
              <description>Remaining Locations in the FIFO
Slave Access Mode:
This field indicates the space available in the selected FIFO.
Debug Access Mode:
This field contains the Write or Read pointer value of the selected FIFO during Write or Read operation, respectively.</description>
              <bitRange>[31:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STSI</name>
              <description>Transmit Status Available Interrupt Status
When set, this bit indicates that the Slave mode Tx packet is transmitted, and the status is available in Tx Status FIFO. This bit is reset when 1 is written to this bit.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit status available interrupt status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit status available interrupt status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PKTI</name>
              <description>Receive Packet Available Interrupt Status
When set, this bit indicates that MAC layer has written the EOP of received packet to the Rx FIFO. This bit is reset when 1 is written to this bit.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive packet available interrupt status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive packet available interrupt status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BYTEEN</name>
              <description>Byte Enables
This field indicates the number of data bytes valid in the data register during Read operation. This is valid only when PKTSTATE is 0x2 (EOP) and Tx FIFO or Rx FIFO is selected.</description>
              <bitRange>[4:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Byte 0 valid</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Byte 0 and Byte 1 are valid</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Byte 0, Byte 1, and Byte 2 are valid</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>All four bytes are valid</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PKTSTATE</name>
              <description>Encoded Packet State
This field is used to get the control or status information of the selected FIFO.
Tx FIFO:
0x0: Packet data
0x1: Control word
0x2: SOP data
0x3: EOP data
Rx FIFO:
0x0: Packet data
0x1: Normal status
0x2: Last status
0x3: EOP</description>
              <bitRange>[2:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFOBUSY</name>
              <description>FIFO Busy
When set, this bit indicates that a FIFO operation is in progress in the MAC and content of the following fields is not valid:
All other fields of this register
All fields of the ETH_MTL_FIFO_DEBUG_DATA register</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>FIFO busy not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>FIFO busy detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MTL_FIFO_DEBUG_DATA</name>
          <description>FIFO Debug Data Register</description>
          <addressOffset>0xC10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FDBGDATA</name>
              <description>FIFO Debug Data
During debug or slave access write operation, this field contains the data to be written to the Tx FIFO, Rx FIFO, or TSO FIFO. During debug or slave access read operation, this field contains the data read from the Tx FIFO, Rx FIFO, TSO FIFO, or Tx Status FIFO.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MTL_INTERRUPT_STATUS</name>
          <description>MTL Interrupt Status Register</description>
          <addressOffset>0xC20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFE0001</resetMask>
          <fields>
            <field>
              <name>DBGIS</name>
              <description>Debug Interrupt status
This bit indicates an interrupt event during the slave access. To reset this bit, the application must read the ETH_MTL_DBG_STS register to get the exact cause of the interrupt and clear its source.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Debug interrupt status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Debug interrupt status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>Q0IS</name>
              <description>Queue 0 Interrupt status
This bit indicates that there is an interrupt from Queue 0. To reset this bit, the application must read Queue 0 Interrupt Control and Status register to get the exact cause of the interrupt and clear its source.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Queue 0 interrupt status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Queue 0 interrupt status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MTL_TXQ0_OPERATION_MODE</name>
          <description>Queue 0 Transmit Operation Mode Register</description>
          <addressOffset>0xD00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF3</resetMask>
          <fields>
            <field>
              <name>TTC</name>
              <description>Transmit Threshold Control
These bits control the threshold level of the MTL Tx Queue. The transmission starts when the packet size within the MTL Tx Queue is larger than the threshold. In addition, full packets with length less than the threshold are also transmitted. These bits are used only when the TSF bit is reset.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>32</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>64</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>96</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>128</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>192</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>256</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>384</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>512</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSF</name>
              <description>Transmit Store and Forward
When this bit is set, the transmission starts when a full packet resides in the MTL Tx Queue. When this bit is set, the TTC value is ignored. This bit should be changed only when the transmission is stopped.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit store and forward is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit store and forward is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FTQ</name>
              <description>Flush Transmit Queue
When this bit is set, the Tx Queue controller logic is reset to its default values. Therefore, all the data in the Tx Queue is lost or flushed. This bit is internally reset when the flushing operation is complete. Until this bit is reset, the user must not write to the ETH_MTL_TXQ0_OPERATION_MODE register. The data which is already accepted by the MAC transmitter is not flushed. It is scheduled for transmission and results in underflow and runt packet transmission.
Note: The flush operation is complete only when the Tx Queue is empty and the application has accepted the pending Tx Status of all transmitted packets.
Access restrictions apply.
MAC initiates the Tx queue flush when application writes 1.
MAC writes 0 after the Tx queue flush is complete.
MAC ignores when application writes 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Flush transmit queue is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Flush transmit queue is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MTL_TXQ0_UNDERFLOW</name>
          <description>Queue 0 Underflow Counter Register</description>
          <addressOffset>0xD04</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UFCNTOVF</name>
              <description>Overflow Bit for Underflow Packet Counter
This bit is set every time the Tx Queue Underflow Packet Counter field overflows, that is, it has crossed the maximum count. In such a scenario, the overflow packet counter is reset to all-zeros and this bit indicates that the rollover happened.
Access restriction applies. Clears on read. Self-set to 1 on internal event.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Overflow not detected for underflow packet counter</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Overflow detected for underflow packet counter</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UFFRMCNT</name>
              <description>Underflow Packet Counter
This field indicates the number of packets aborted by the controller because of Tx Queue Underflow. This counter is incremented each time the MAC aborts outgoing packet because of underflow.
Access restriction applies. Clears on read. Self-set to 1 on internal event.</description>
              <bitRange>[10:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MTL_TXQ0_DEBUG</name>
          <description>Queue 0 Transmit Debug Register</description>
          <addressOffset>0xD08</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STXSTSF</name>
              <description>Number of Status Words in Tx Status FIFO of Queue
This field indicates the current number of status in the Tx Status FIFO of this queue.
When the ETH_MTL_OPERATION_MODE[DTXSTS] bit is set to 1, this field does not reflect the number of status words in Tx Status FIFO.</description>
              <bitRange>[22:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PTXQ</name>
              <description>Number of Packets in the Transmit Queue
This field indicates the current number of packets in the Tx Queue.
When the ETH_MTL_OPERATION_MODE[DTXSTS] bit is set to 1, this field does not reflect the number of packets in the Transmit queue.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TXSTSFSTS</name>
              <description>MTL Tx Status FIFO Full Status
When high, this bit indicates that the MTL Tx Status FIFO is full. Therefore, the MTL cannot accept any more packets for transmission.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MTL Tx Status FIFO full status is not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MTL Tx Status FIFO full status is detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXQSTS</name>
              <description>MTL Tx Queue Not Empty Status
When this bit is high, it indicates that the MTL Tx Queue is not empty and some data is left for transmission.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MTL Tx Queue not empty status is not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MTL Tx Queue not empty status is detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TWCSTS</name>
              <description>MTL Tx Queue Write Controller Status
When high, this bit indicates that the MTL Tx Queue Write Controller is active, and it is transferring the data to the Tx Queue.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MTL Tx Queue write controller status is not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MTL Tx Queue write controller status is detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRCSTS</name>
              <description>MTL Tx Queue Read Controller Status
This field indicates the state of the Tx Queue Read Controller:</description>
              <bitRange>[2:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Idle state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Read state (transferring data to the MAC transmitter)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Waiting for pending Tx status from the MAC transmitter</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Flushing the Tx Queue because of the packet abort request from the MAC</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXQPAUSED</name>
              <description>Transmit Queue in Pause
When this bit is high and the Rx flow control is enabled, it indicates that the Tx Queue is in the Pause condition (in the full-duplex only mode) because of the following:
Reception of the PFC packet for the priorities assigned to the Tx Queue when PFC is enabled
Reception of 802.3x Pause packet when PFC is disabled</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit queue in pause status is not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit queue in pause status is detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MTL_Q0_INTERRUPT_CONTROL_STATUS</name>
          <description>Queue 0 Interrupt Enable and Status Register</description>
          <addressOffset>0xD2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXOIE</name>
              <description>Receive Queue Overflow Interrupt Enable
When this bit is set, the receive queue overflow interrupt is enabled. When this bit is reset, the Receive Queue Overflow interrupt is disabled.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive queue overflow interrupt is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive queue overflow interrupt is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXOVFIS</name>
              <description>Receive Queue Overflow Interrupt Status
This bit indicates that the receive queue had an overflow while receiving the packet. If a partial packet is transferred to the application, the overflow status is set in RDES3[21]. This bit is cleared when the application writes 1 to this bit.
Access restriction applies. Self-set to 1 on internal event. Setting 1 clears. Setting 0 has no effect.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive queue overflow interrupt status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive queue overflow interrupt status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXUIE</name>
              <description>Transmit Queue Underflow Interrupt Enable
When this bit is set, the transmit queue underflow interrupt is enabled. When this bit is reset, the Transmit Queue Underflow interrupt is disabled.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit queue underflow interrupt status is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit queue underflow interrupt status is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXUNFIS</name>
              <description>Transmit Queue Underflow Interrupt Status
This bit indicates that the transmit queue had an underflow while transmitting the packet. Transmission is suspended and an Underflow Error TDES3[2] is set. This bit is cleared when the application writes 1 to this bit.
Access restriction applies. Self-set to 1 on internal event. Setting 1 clears. Setting 0 has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit queue underflow interrupt status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit queue underflow interrupt status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MTL_RXQ0_OPERATION_MODE</name>
          <description>Queue 0 Receive Operation Mode Register</description>
          <addressOffset>0xD30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DIS_TCP_EF</name>
              <description>Disable Dropping of TCP/IP Checksum Error Packets
When this bit is set, the MAC does not drop the packets which only have the errors detected by the Receive Checksum Offload engine. Such packets have errors only in the encapsulated payload. There are no errors (including FCS error) in the Ethernet packet received by the MAC.
When this bit is reset, all error packets are dropped if the FEP bit is reset.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Dropping of TCP/IP checksum error packets is enabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Dropping of TCP/IP checksum error packets is disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RSF</name>
              <description>Receive Queue Store and Forward
When this bit is set, the ETH module reads a packet from the Rx Queue only after the complete packet has been written to it, ignoring the RTC field of this register. When this bit is reset, the Rx Queue operates in the Threshold (cut-through) mode, subject to the threshold specified by the RTC field of this register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive queue store and forward is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive queue store and forward is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FEP</name>
              <description>Forward Error Packets
When this bit is reset, the Rx Queue drops packets with error status (CRC error, GMII_ER, watchdog timeout, or overflow). However, if the start byte (write) pointer of a packet is already transferred to the read controller side (in Threshold mode), the packet is not dropped.
When this bit is set, all packets except the runt error packets are forwarded to the application or DMA. If the RSF bit is set and the Rx Queue overflows when a partial packet is written, the packet is dropped irrespective of the setting of this bit. However, if the RSF bit is reset and the Rx Queue overflows when a partial packet is written, a partial packet might be forwarded to the application or DMA.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Forward error packets is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Forward error packets is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FUP</name>
              <description>Forward Undersized Good Packets
When this bit is set, the Rx Queue forwards the undersized good packets (packets with no error and length less than 64 bytes), including pad-bytes and CRC. When this bit is reset, the Rx Queue drops all packets of less than 64 bytes, unless a packet is already transferred because of the lower value of Rx Threshold, for example, RTC = 01.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Forward undersized good packets is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Forward undersized good packets is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RTC</name>
              <description>Receive Queue Threshold Control
These bits control the threshold level of the MTL Rx Queue (in bytes):The received packet is transferred to the application or DMA when the packet size within the MTL Rx Queue is larger than the threshold. In addition, full packets with length less than the threshold are automatically transferred.
This field is valid only when the RSF bit is zero. This field is ignored when the RSF bit is set to 1.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>64</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>32</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>96</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>128</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MTL_RXQ0_MISSED_PACKET_OVERFLOW_CNT</name>
          <description>Queue 0 Missed Packet and Overflow Counter Register</description>
          <addressOffset>0xD34</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MISCNTOVF</name>
              <description>Missed Packet Counter Overflow Bit
When set, this bit indicates that the Rx Queue Missed Packet Counter crossed the maximum limit.
Access restriction applies. Clears on read. Self-set to 1 on internal event.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Missed packet counter overflow not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Missed packet counter overflow detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MISPKTCNT</name>
              <description>Missed Packet Counter
This counter is incremented by 1 when the DMA discards the packet because of buffer unavailability.
Access restriction applies. Clears on read. Self-set to 1 on internal event.</description>
              <bitRange>[26:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVFCNTOVF</name>
              <description>Overflow Counter Overflow Bit
When set, this bit indicates that the Rx Queue Overflow Packet Counter field crossed the maximum limit.
Access restriction applies. Clears on read. Self-set to 1 on internal event.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Overflow counter overflow not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Overflow counter overflow detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OVFPKTCNT</name>
              <description>Overflow Packet Counter
This field indicates the number of packets discarded by the ETH module because of Receive queue overflow. This counter is incremented each time the ETH module discards an incoming packet because of overflow.
Access restriction applies. Clears on read. Self-set to 1 on internal event.</description>
              <bitRange>[10:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MTL_RXQ0_DEBUG</name>
          <description>Queue 0 Receive Debug Register</description>
          <addressOffset>0xD38</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRXQ</name>
              <description>Number of Packets in Receive Queue
This field indicates the current number of packets in the Rx Queue. The theoretical maximum value for this field is 256KB/16B = 16KB Packets, that is, Max_Queue_Size/Min_Packet_Size.</description>
              <bitRange>[29:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RXQSTS</name>
              <description>MTL Rx Queue Fill-Level Status
This field gives the status of the fill-level of the Rx Queue:</description>
              <bitRange>[5:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Rx Queue empty</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Rx Queue fill-level below flow-control deactivate threshold</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Rx Queue fill-level above flow-control activate threshold</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Rx Queue full</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RRCSTS</name>
              <description>MTL Rx Queue Read Controller State
This field gives the state of the Rx Queue Read controller:</description>
              <bitRange>[2:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Idle state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Reading packet data</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Reading packet status (or timestamp)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Flushing the packet data and status</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RWCSTS</name>
              <description>MTL Rx Queue Write Controller Active Status
When high, this bit indicates that the MTL Rx Queue Write controller is active, and it is transferring a received packet to the Rx Queue.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MTL Rx Queue write controller active status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MTL Rx Queue write controller active status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_MODE</name>
          <description>Bus Mode Register</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INTM</name>
              <description>Interrupt Mode
This field defines the interrupt mode of the ETH module and changes the behavior of the ETH_SBD_IRQ signal.
It also changes the behavior of the ETH_DMA_CH0_STATUS[RI] and ETH_DMA_CH0_STATUS[TI] bits.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>ETH_SBD_IRQ is asserted when corresponding interrupts are enabled, and cleared only when software clears the corresponding RI/TI status bits.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ETH_SBD_IRQ is not asserted on TX/RX packet transfer completion event.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>ETH_SBD_IRQ is not asserted on TX/RX packet transfer completion event.</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXPR</name>
              <description>Transmit Priority
When set, this bit indicates that the Tx DMA has priority over the Rx DMA during arbitration for the system-side bus.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit Priority is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit Priority is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSPW</name>
              <description>Descriptor Posted Write
When this bit is set to 0, the descriptor writes are non-posted.
When this bit is set to 1, the descriptor writes are non-posted only when IOC = 1 (Interrupt on completion) in last descriptor; otherwise, the descriptor writes are always posted.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Descriptor posted write is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Descriptor posted write is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SWR</name>
              <description>Software Reset
When this bit is set, the MAC and the DMA controller reset the logic and all internal registers of the DMA, MTL, and MAC. This bit is automatically cleared after the reset operation is complete in all ETH module clock domains. Before reprogramming any ETH
module register, a value of zero should be read in this bit.
This bit must be read at least 4 CLK_CSR cycles after it is written to
1.
Note: The reset operation is complete only when the ETH module has de-asserted all resets in all active clock domains. Therefore, it is essential that all PHY input clocks of the selected PHY interface are present for the completion of the software reset. The time required to complete the software reset operation depends on the frequency of the slowest active clock.
Access restrictions apply.
MAC initiates the software reset when application writes 1.
MAC writes 0 after the software reset is complete.
MAC ignores when application writes 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Software reset is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Software reset is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_SYSBUS_MODE</name>
          <description>System Bus Mode Register</description>
          <addressOffset>0x1004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x01010000</resetValue>
          <resetMask>0xFFFF37FF</resetMask>
          <fields>
            <field>
              <name>EN_LPI</name>
              <description>Enable Low Power Interface (LPI)
When set to 1, this bit enables the LPI mode and accepts the LPI request from the AXI System Clock controller.
When set to 0, this bit disables the LPI mode and denies the LPI request from the AXI System Clock controller.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>LPI is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>LPI is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPI_XIT_PKT</name>
              <description>Unlock on Magic Packet or Remote Wake-Up Packet
When set to 1, this bit enables the AXI master to come out of the LPI mode only when the magic packet or remote wake-up packet is received. When set to 0, this bit enables the AXI master to come out of the LPI mode when any packet is received.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Unlock on magic packet or remote wake-up packet is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Unlock on magic packet or remote wake-up packet is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WR_OSR_LMT</name>
              <description>AXI Maximum Write Outstanding Request Limit
This value limits the maximum outstanding request on the AXI write interface. Maximum outstanding requests = WR_OSR_LMT + 1.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RD_OSR_LMT</name>
              <description>AXI Maximum Read Outstanding Request Limit
This value limits the maximum outstanding request on the AXI read interface. Maximum outstanding requests = RD_OSR_LMT + 1.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ONEKBBE</name>
              <description>1KB Boundary Crossing Enable for the AXI Master
When set, the burst transfers performed by the AXI master do not cross 1KB boundary. When reset, the burst transfers performed by the AXI master do not cross 4KB boundary.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1KB boundary crossing for the AXI master beats is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>1KB boundary crossing for the AXI master beats is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AAL</name>
              <description>Address-Aligned Beats
When this bit is set to 1, the AXI master performs address-aligned burst transfers on Read and Write channels.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Address-aligned beats is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Address-aligned beats is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AALE</name>
              <description>Automatic AXI LPI enable
When set to 1, enables the AXI master to enter into LPI state when there is no activity in the ETH module for number of system clock cycles programmed in the ETH_AXI_LPI_ENTRY_INTERVAL[LPIEI] field.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Automatic AXI LPI is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Automatic AXI LPI is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BLEN256</name>
              <description>AXI Burst Length 256
When set to
- 1: the AXI master can select a burst length of 256 on the AXI interface.
- 0: the AXI master cannot select a burst length of greater than 128 on the AXI interface.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>AXI Burst Length 256</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BLEN128</name>
              <description>AXI Burst Length 128
When set to
- 1: the AXI master can select a burst length of 128 on the AXI interface.
- 0: the AXI master cannot select a burst length of greater than 64 on the AXI interface.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>AXI Burst Length 128</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BLEN64</name>
              <description>AXI Burst Length 64
When set to
- 1: the AXI master can select a burst length of 64 on the AXI interface.
- 0: the AXI master cannot select a burst length of greater than 32 on the AXI interface.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>AXI Burst Length 64</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BLEN32</name>
              <description>AXI Burst Length 32
When set to
- 1: the AXI master can select a burst length of 32 on the AXI interface.
- 0: the AXI master cannot select a burst length of greater than 16 on the AXI interface.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>AXI Burst Length 32</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BLEN16</name>
              <description>AXI Burst Length 16
When this bit is set to 1 or the FB bit is set to 0, the AXI master can select a burst length of 16 on the AXI interface.
When the FB bit is set to 0, setting this bit has no effect.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>AXI burst length 16</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BLEN8</name>
              <description>AXI Burst Length 8
When this bit is set to 1 or the FB bit is set to 0, the AXI master can select a burst length of 8 on the AXI interface.
When the FB bit is set to 0, setting this bit has no effect.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>AXI burst length 8</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BLEN4</name>
              <description>AXI Burst Length 4
When this bit is set to 1 or the FB bit is set to 0, the AXI master can select a burst length of 4 on the AXI interface.
When the FB bit is set to 0, setting this bit has no effect.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>AXI burst length 4</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FB</name>
              <description>Fixed Burst Length
When this bit is set to 1, the AXI master initiates burst transfers of specified lengths as given below.
Burst transfers of length 1
When this bit is set to 0, the AXI master initiates burst transfers that are equal to or less than the maximum allowed burst length programmed in Bits[3-1].</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Fixed burst length is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Fixed burst length is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_INTERRUPT_STATUS</name>
          <description>DMA, MTL, and MAC Interrupt Status Register</description>
          <addressOffset>0x1008</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MACIS</name>
              <description>MAC Interrupt Status
This bit indicates an interrupt event in the MAC. To reset this bit to 0x0, the software must read the corresponding register in the MAC to get the exact cause of the interrupt and clear its source.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MAC interrupt status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MAC interrupt status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MTLIS</name>
              <description>MTL Interrupt Status
This bit indicates an interrupt event in the MTL. To reset this bit to 0x0, the software must read the corresponding register in the MTL to get the exact cause of the interrupt and clear its source.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MTL interrupt status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MTL interrupt status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DC0IS</name>
              <description>DMA Channel 0 Interrupt Status
This bit indicates an interrupt event in DMA Channel 0. To reset this bit to 0x0, the software must read the corresponding register in DMA Channel 0 to get the exact cause of the interrupt and clear its source.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DMA channel 0 interrupt status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA channel 0 interrupt status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_DEBUG_STATUS0</name>
          <description>Debug Status 0 Register</description>
          <addressOffset>0x100C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>TPS0</name>
              <description>DMA Channel 0 Transmit Process State
This field indicates the Tx DMA FSM state for Channel 0. The MSB of this field always returns 0. This field does not generate an interrupt.</description>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Stopped (reset or stop transmit command issued)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Running (fetching Tx transfer descriptor)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Running (waiting for status)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Running (reading data from system memory buffer and queuing it to the Tx buffer (Tx FIFO))</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Timestamp write state</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>Suspended (Tx descriptor unavailable or Tx buffer underflow)</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>Running (closing Tx descriptor)</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RPS0</name>
              <description>DMA Channel 0 Receive Process State
This field indicates the Rx DMA FSM state for Channel 0. The MSB of this field always returns 0. This field does not generate an interrupt.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Stopped (reset or stop receive command issued)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Running (fetching Rx transfer descriptor)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Running (waiting for Rx packet)</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Suspended (Rx descriptor unavailable)</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>Running (closing the Rx descriptor)</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>Timestamp write state</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>Running (transferring the received packet data from the Rx buffer to the system memory)</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AXRHSTS</name>
              <description>AXI Master Read Channel Status
When high, this bit indicates that the read channel of the AXI master is active, and it is transferring the data.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>AXI master read channel status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>AXI master read channel status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AXWHSTS</name>
              <description>AXI Master Write Channel
When high, this bit indicates that the write channel of the AXI master is active, and it is transferring data.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>AXI master write channel status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>AXI master write channel status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_AXI4_TX_AR_ACE_CONTROL</name>
          <description>AXI4 TX DMA Read ACE Control Register</description>
          <addressOffset>0x1020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>THD</name>
              <description>Transmit DMA First Packet Buffer or TSO Header Domain Control
When TSO is NOT enabled, This field is used to drive ardomain_m_o[1:0] signal when Transmit DMA is accessing First Buffer of the Packet (First valid buffer with FD being set in the TDES3 of the Descriptor).When TSO is enabled, This field is used to drive ardomain_m_o[1:0] signal when the Transmit DMA is accessing the TSO Header data.</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>THC</name>
              <description>Transmit DMA First Packet Buffer or TSO Header Cache Control
When TSO is NOT enabled, This field is used to drive arcache_m_o[3:0] signal when Transmit DMA is accessing First Buffer of the Packet (First valid buffer with FD being set in the TDES3 of the Descriptor).When TSO is enabled, This field is used to drive arcache_m_o[3:0] signal when the Transmit DMA is accessing the TSO Header data.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TED</name>
              <description>Transmit DMA Extended Packet Buffer or TSO Payload Domain Control
When TSO is NOT enabled, This field is used to drive ardomain_m_o[1:0] signal when Transmit DMA is accessing the extended buffers (when packet is distributed across multiple buffers).When TSO is enabled, This field is used to drive ardomain_m_o[1:0] signal when the Transmit DMA is accessing the TSO payload data.</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TEC</name>
              <description>Transmit DMA Extended Packet Buffer or TSO Payload Cache Control
When TSO is NOT enabled, This field is used to drive arcache_m_o[3:0] signal when Transmit DMA is accessing the extended buffers (when packet is distributed across multiple buffers).When TSO is enabled, This field is used to drive arcache_m_o[3:0] signal when the Transmit DMA is accessing the TSO payload data.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TDRD</name>
              <description>Transmit DMA Read Descriptor Domain Control
This field is used to drive ardomain_m_o[1:0] signal when Transmit DMA engines access the Descriptor.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TDRC</name>
              <description>Transmit DMA Read Descriptor Cache Control
This field is used to drive arcache_m_o[3:0] signal when Transmit DMA engines access the Descriptor.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_AXI4_RX_AW_ACE_CONTROL</name>
          <description>AXI4 RX DMA Write ACE Control Register</description>
          <addressOffset>0x1024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDD</name>
              <description>Receive DMA Buffer Domain Control
This field is used to drive the awdomain_m_o[1:0] signal when Receive DMA is accessing the Buffer when Header and payload are NOT separated.</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RDC</name>
              <description>Receive DMA Buffer Cache Control
This field is used to drive awcache_m_o[3:0] signal when Receive DMA is accessing the Buffer when Header and payload are NOT separated.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RHD</name>
              <description>Receive DMA Header Domain Control
This field is used to drive awdomain_m_o[1:0] and signal when Receive DMA is accessing the header Buffer when Header and payload are separated.</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RHC</name>
              <description>Receive DMA Header Cache Control
This field is used to drive awcache_m_o[3:0] and signal when Receive DMA is accessing the header Buffer when Header and payload are separated.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RPD</name>
              <description>Receive DMA Payload Domain Control
This field is used to drive awdomain_m_o[1:0] signal when Receive DMA is accessing the Payload Buffer when Header and payload are separated.</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RPC</name>
              <description>Receive DMA Payload Cache Control
This field is used to drive awcache_m_o[3:0] signal when Receive DMA is accessing the Payload Buffer when Header and payload are separated.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RDWD</name>
              <description>Receive DMA Write Descriptor Domain Control
This field is used to drive awdomain_m_o[1:0] signal when Receive DMA accesses the Descriptor.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RDWC</name>
              <description>Receive DMA Write Descriptor Cache Control
This field is used to drive awcache_m_o[3:0] signal when Receive DMA accesses the Descriptor.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_AXI4_TXRX_AWAR_ACE_CONTROL</name>
          <description>AXI4 TX/RX DMA Read/Write ACE Control Register</description>
          <addressOffset>0x1028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRP</name>
              <description>DMA Write Protection control
This field is used to drive awprot_m_o[2:0] signal on the AXI Write Channel.</description>
              <bitRange>[22:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RDP</name>
              <description>DMA Read Protection control
This field is used to drive arprot_m_o[2:0] signal during all read requests.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RDRD</name>
              <description>Receive DMA Read Descriptor Domain control
This field is used to drive ardomain_m_o[1:0] signal when Receive DMA engines read the Descriptor.</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RDRC</name>
              <description>Receive DMA Read Descriptor Cache control
This field is used to drive arcache_m_o[3:0] signal when Receive DMA engines read the Descriptor.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TDWD</name>
              <description>Transmit DMA Write Descriptor Domain control
This field is used to drive awdomain_m_o[1:0] signal when Transmit DMA write to the Descriptor.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TDWC</name>
              <description>Transmit DMA Write Descriptor Cache control
This field is used to drive awcache_m_o[3:0] signal when Transmit DMA writes to the Descriptor.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_AXI_LPI_ENTRY_INTERVAL</name>
          <description>AXI LPI Entry Interval Register</description>
          <addressOffset>0x1040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LPIEI</name>
              <description>LPI Entry Interval
Contains the number of system clock cycles, multiplied by 64, to wait for an activity in the ETH module to enter into the AXI low power state.
0x0 indicates 64 clock cycles</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_CONTROL</name>
          <description>DMA Channel 0 Control Register</description>
          <addressOffset>0x1100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DSL</name>
              <description>Descriptor Skip Length
This bit specifies the Dword to skip between two unchained descriptors. The address skipping starts from the end of the current descriptor to the start of the next descriptor.
When the DSL value is equal to zero, the DMA takes the descriptor table as contiguous.</description>
              <bitRange>[20:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PBLX8</name>
              <description>8xPBL mode
When this bit is set, the PBL value programmed in the ETH_DMA_CH0_TX_CONTROL[TXPBL] and ETH_DMA_CH0_RX_CONTROL[RXPBL] fields is multiplied by eight times. Therefore, the DMA transfers the data in 8, 16, 32, 64, 128, and 256 beats depending on the PBL value.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>8xPBL mode is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>8xPBL mode is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MSS</name>
              <description>Maximum Segment Size
This field specifies the maximum segment size that must be used while segmenting the packet. This field is valid only if the ETH_DMA_CH0_TX_CONTROL[TSE] bit is set.
Program a value in this field that is more than the configured datawidth in bytes. Use MSS value of 64 bytes or more.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_TX_CONTROL</name>
          <description>DMA Channel 0 Transmit Control Register</description>
          <addressOffset>0x1104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF9FF1</resetMask>
          <fields>
            <field>
              <name>TXPBL</name>
              <description>Transmit Programmable Burst Length
These bits indicate the maximum number of beats to be transferred in one DMA block data transfer. The DMA always attempts max burst as specified in PBL each time it starts a burst transfer on the application bus. The user can program PBL with any of the following values: 1, 2, 4, 8, 16, or 32. Any other value results in undefined behavior.
To transfer more than 32 beats, perform the following steps:
1. Set the 8xPBL mode in ETH_DMA_CH0_CONTROL register.
2. Set the TxPBL.
Note: The maximum value of TxPBL must be less than or equal to half the Tx Queue size in terms of beats. This is required so that the Tx Queue has space to store at least another Tx PBL worth of data while the MTL Tx Queue Controller is transferring data to MAC. For example, the total locations in Tx Queue of size 512 bytes is 64, TxPBL and 8xPBL needs to be programmed to less than or equal to 32.</description>
              <bitRange>[21:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IPBL</name>
              <description>Ignore PBL Requirement
When this bit is set, the DMA does not check for PBL number of locations in the MTL before initiating a transfer. If space is not available, the MTL might use handshaking to slow the DMA.
Note: This bit/mode must not be used when multiple Transmit DMA Channels are enabled as it might block other Transmit and Receive DMA Channels from accessing the Read Data Channel of the AXI bus until space is available in Transmit Queue for current transfer.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Ignore PBL requirement is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Ignore PBL requirement is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSE</name>
              <description>TCP Segmentation Enabled
When this bit is set, the DMA performs the TCP segmentation or UDP Segmentation/Fragmentation for packets in this channel. The TCP segmentation or UDP packet's segmentation/Fragmentation is done only for those packets for which the TSE bit (TDES0[19]) is set in the Tx Normal descriptor.When this bit is set, the TxPBL value must be greater than 4.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>TCP segmentation is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>TCP segmentation is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OSF</name>
              <description>Operate on Second Packet
When this bit is set, it instructs the DMA to process the second packet of the Transmit data even before the status for the first packet is obtained.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Operate on second packet disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Operate on second packet enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ST</name>
              <description>Start or Stop Transmission Command
When this bit is set, transmission is placed in the Running state. The DMA checks the Transmit list at the current position for a packet to be transmitted.
The DMA tries to acquire descriptor from either of the following positions:
The current position in the list
The position at which the transmission was previously stopped
When this bit is reset, the transmission process is placed in the Stopped state after completing the transmission of the current packet. The Next Descriptor position in the Transmit list is saved, and it becomes the current position when the transmission is restarted. To change the list address, the user needs to program ETH_DMA_CH0_TXDESC_LIST_ADDRESS register with a new value when this bit is reset. The new value is considered when this bit is set again. The stop transmission command is effective only when the transmission of the current packet is complete or the transmission is in the Suspended state.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Stop transmission command</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Start transmission command</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_RX_CONTROL</name>
          <description>DMA Channel 0 Receive Control Register</description>
          <addressOffset>0x1108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RPF</name>
              <description>Rx Packet Flush.
When this bit is set to 1, then the ETH module automatically flushes the packet from the Rx Queues destined to this DMA Rx Channel, when it is stopped. When this bit remains set and the DMA is re-started by the software driver, the packets residing in the Rx Queues that were received when this Rx DMA was stopped, still get flushed out. The packets received by the MAC only after the DMA is re-started is routed to the Rx DMA. The flushing is done on the Read side of the Rx Queue. When the packet is duplicated to multiple Rx DMA, it is flushed by the Rx DMA to which it is routed only when it is stopped to prevent head-of-line blocking. The packet duplicated to multiple Rx DMA is not flushed when the Rx DMA is re-started, irrespective of whether the packet was received during one or more Rx DMAs were stopped.
When this bit is set to 0, the ETH module does not flush the packet in the Rx Queue destined to this Rx DMA Channel when it is in STOP state. This might in turn cause head-of-line blocking in the corresponding RxQueue.
Note: The stopping of packet flow from a Rx DMA Channel to the application by setting RPF works only when there is one-to-one mapping of Rx Queue to Rx DMA channels. In Dynamic mapping mode, setting RPF bit in any ETH_DMA_CH0_RX_CONTROL register might flush packets from unintended Rx Queues which are destined to the stopped Rx DMA Channel.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Rx packet flush is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Rx packet flush is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXPBL</name>
              <description>Receive Programmable Burst Length
These bits indicate the maximum number of beats to be transferred in one DMA block data transfer. The DMA always attempts max burst as specified in PBL each time it starts a burst transfer on the application bus. The user can program PBL with any of the following values: 1, 2, 4, 8, 16, or 32. Any other value results in undefined behavior.
To transfer more than 32 beats, perform the following steps:
1. Set the 8xPBL mode in the ETH_DMA_CH0_CONTROL register.
2. Set the RxPBL.
Note: The maximum value of RxPBL must be less than or equal to half the Rx Queue size in terms of beats. This is required so that the Rx Queue has space to store at least another Rx PBL worth of data while the Rx DMA is transferring a block of data. For example, the total locations in Rx Queue of size 512 bytes is 64, so RxPBL and 8xPBL needs to be programmed to less than or equal to 32.</description>
              <bitRange>[21:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RBSZ_13_Y</name>
              <description>Receive Buffer Size High
RBSZ[13-0] is split into two fields higher RBSZ_13_y and lower RBSZ_x_0. The RBSZ[13-0] field indicates the size of the Rx buffers specified in bytes. The maximum buffer size is limited to 16KB. The buffer size is applicable to payload buffers when split headers are enabled.
Note: The buffer size must be a multiple of 8. This is required even if the value of buffer address pointer is not aligned to data bus width. Hence the lower RBSZ_x_0 bits are read-only and the value is considered as all-zero. Thus the RBSZ_13_y indicates the buffer size in terms of locations.</description>
              <bitRange>[14:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RBSZ_X_0</name>
              <description>Receive Buffer Size Low
RBSZ[13-0] is split into two fields RBSZ_13_Y and RBSZ_X_0. The RBSZ_X_0 is the lower field.</description>
              <bitRange>[3:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SR</name>
              <description>Start or Stop Receive
When this bit is set, the DMA tries to acquire the descriptor from the Receive list and processes the incoming packets.
The DMA tries to acquire descriptor from either of the following positions:
- The current position in the list. This is the address set by the ETH_DMA_CH0_RXDESC_LIST_ADDRESS register.
- The position at which the Rx process was previously stopped. If the DMA does not own the current descriptor, the reception is suspended and the ETH_DMA_CH0_STATUS[RBU] bit is set. The Start Receive command is effective only when the reception is stopped. If the command is issued before setting the ETH_DMA_CH0_RXDESC_LIST_ADDRESS register, the DMA behavior is unpredictable.
When this bit is reset, the Rx DMA operation stops after the transfer of the current packet. The next descriptor position in the Receive list is saved, and it becomes the current position after the Rx process is restarted. The Stop Receive command is effective only when the Rx process is in the Running (waiting for Rx packet) or Suspended state.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Stop receive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Start receive</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_TXDESC_LIST_ADDRESS</name>
          <description>DMA Channel 0 Transmit Descriptor List Address Register</description>
          <addressOffset>0x1114</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDESLA</name>
              <description>Start of Transmit List
This field contains the base address of the first descriptor in the Transmit descriptor list.</description>
              <bitRange>[31:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_RXDESC_LIST_ADDRESS</name>
          <description>DMA Channel 0 Receive Descriptor List Address Register</description>
          <addressOffset>0x111C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDESLA</name>
              <description>Start of Receive List
This field contains the base address of the first descriptor in the Rx Descriptor list.</description>
              <bitRange>[31:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_TXDESC_TAIL_POINTER</name>
          <description>DMA Channel 0 Transmit Descriptor Tail Pointer Register</description>
          <addressOffset>0x1120</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDTP</name>
              <description>Transmit Descriptor Tail Pointer
This field contains the tail pointer for the Tx descriptor ring. The software writes the tail pointer to add more descriptors to the Tx channel. The hardware tries to transmit all packets referenced by the descriptors between the head and the tail pointer registers.</description>
              <bitRange>[31:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_RXDESC_TAIL_POINTER</name>
          <description>DMA Channel 0 Receive Descriptor Tail Pointer Register</description>
          <addressOffset>0x1128</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDTP</name>
              <description>Receive Descriptor Tail Pointer
This field contains the tail pointer for the Rx descriptor ring. The software writes the tail pointer to add more descriptors to the Rx channel. The hardware tries to write all received packets to the descriptors referenced between the head and the tail pointer registers.</description>
              <bitRange>[31:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_TXDESC_RING_LENGTH</name>
          <description>DMA Channel 0 Transmit Descriptor Ring Length Register</description>
          <addressOffset>0x112C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDRL</name>
              <description>Transmit Descriptor Ring Length
This field sets the maximum number of Tx descriptors in the circular descriptor ring. The maximum number of descriptors is limited to 1KB descriptors. It is recommended a minimum ring descriptor length of 4. For example, any value up to 0x3FF can be programmed in this field. If 0x3FF is programmed, the descriptors are 1024. If 10 descriptors are needed, program it to a value of 0x9.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_RXDESC_RING_LENGTH</name>
          <description>DMA Channel 0 Receive Descriptor Ring Length Register</description>
          <addressOffset>0x1130</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ARBS</name>
              <description>Alternate Receive Buffer Size
When ARBS is programmed to a non-zero value and split header feature is not enabled, ARBS indicates the size (in bytes) for Rx Buffer 1. When split header feature is enabled, ARBS indicates the buffer size for header data. The maximum alternate buffer is limited to 1016 bytes.
When ARBS = 0, Rx Buffer 1 and Rx Buffer 2 sizes are based on the RBSZ field of the ETH_DMA_CH0_RX_CONTROL register.</description>
              <bitRange>[23:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RDRL</name>
              <description>Receive Descriptor Ring Length
This register sets the maximum number of Rx descriptors in the circular descriptor ring. The maximum number of descriptors is limited to 1KB descriptors. For example, any value up to 0x3FF can be programmed in this field. If 0x3FF is programmed, the descriptors are 1024. If 10 descriptors are needed, program it to a value of 0x9.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_INTERRUPT_ENABLE</name>
          <description>DMA Channel 0 Interrupt Enable Register</description>
          <addressOffset>0x1134</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NIE</name>
              <description>Normal Interrupt Summary Enable
When this bit is set, the normal interrupt summary is enabled. This bit enables the following interrupts in the ETH_DMA_CH0_STATUS register:
Bit 0: Transmit Interrupt
Bit 2: Transmit Buffer Unavailable
Bit 6: Receive Interrupt
Bit 11: Early Receive Interrupt</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Normal interrupt summary is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Normal interrupt summary is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AIE</name>
              <description>Abnormal Interrupt Summary Enable
When this bit is set, the abnormal interrupt summary is enabled. This bit enables the following interrupts in the ETH_DMA_CH0_STATUS register:
Bit 1: Transmit Process Stopped
Bit 7: Rx Buffer Unavailable
Bit 8: Receive Process Stopped
Bit 9: Receive Watchdog Timeout
Bit 10: Early Transmit Interrupt
Bit 12: Fatal Bus Error
Bit 13: Context Descriptor Error</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Abnormal interrupt summary is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Abnormal interrupt summary is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CDEE</name>
              <description>Context Descriptor Error Enable
When this bit is set along with the AIE bit, the descriptor error interrupt is enabled. When this bit is reset, the descriptor error interrupt is disabled.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Context descriptor error is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Context descriptor error is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FBEE</name>
              <description>Fatal Bus Error Enable
When this bit is set along with the AIE bit, the fatal bus error interrupt is enabled. When this bit is reset, the fatal bus error error interrupt is disabled.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Fatal bus error is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Fatal bus error is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ERIE</name>
              <description>Early Receive Interrupt Enable
When this bit is set along with the NIE bit, the early receive interrupt is enabled. When this bit is reset, the early receive interrupt is disabled.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Early receive interrupt is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Early receive interrupt is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ETIE</name>
              <description>Early Transmit Interrupt Enable
When this bit is set along with the AIE bit, the early transmit interrupt is enabled. When this bit is reset, the early transmit interrupt is disabled.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Early transmit interrupt is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Early transmit interrupt is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RWTE</name>
              <description>Receive Watchdog Timeout Enable
When this bit is set along with the AIE bit, the receive watchdog timeout interrupt is enabled. When this bit is reset, the receive watchdog timeout interrupt is disabled.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive watchdog timeout is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive watchdog timeout is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RSE</name>
              <description>Receive Stopped Enable
When this bit is set along with the AIE bit, the receive stopped interrupt is enabled. When this bit is reset, the receive stopped interrupt is disabled.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive stopped is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive stopped is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RBUE</name>
              <description>Receive Buffer Unavailable Enable
When this bit is set along with the AIE bit, the receive buffer unavailable interrupt is enabled. When this bit is reset, the receive buffer unavailable interrupt is disabled.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive buffer unavailable is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive buffer unavailable is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RIE</name>
              <description>Receive Interrupt Enable
When this bit is set along with the NIE bit, the receive interrupt is enabled. When this bit is reset, the receive interrupt is disabled.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive interrupt is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive interrupt is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBUE</name>
              <description>Transmit Buffer Unavailable Enable
When this bit is set along with the NIE bit, the transmit buffer unavailable interrupt is enabled. When this bit is reset, the transmit buffer unavailable interrupt is disabled.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit buffer unavailable is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit buffer unavailable is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXSE</name>
              <description>Transmit Stopped Enable
When this bit is set along with the AIE bit, the transmission stopped interrupt is enabled. When this bit is reset, the transmission stopped interrupt is disabled.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit stopped is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit stopped is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIE</name>
              <description>Transmit Interrupt Enable
When this bit is set along with the NIE bit, the transmit interrupt is enabled. When this bit is reset, the transmit interrupt is disabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit interrupt is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit interrupt is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_RX_INTERRUPT_WATCHDOG_TIMER</name>
          <description>DMA Channel 0 Receive Interrupt Watchdog Timer Register</description>
          <addressOffset>0x1138</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PSEL</name>
              <description>Packet Count Interrupt Select
When this bit is set, RBCT field indicates the number of packet threshold at which the Receive Interrupt (RI) is activated and the watchdog timer reset.
When this bit is low, RBCT field indicates the number of data byte threshold at which the Receive Interrupt (RI) is activated and the watchdog timer reset.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RBCT field is used to generate interrupt based on number of bytes received.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RBCT field is used to generate interrupt based on number of packets received.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RBCT</name>
              <description>Receive Byte Count Threshold
This field sets the limit in number of bytes or number of RX packets (based on PSEL) transferred without the assertion of Receive Interrupt. Once this limit is crossed, Receive interrupt is asserted, and the watchdog timer (corresponding to RWT) is also reset.
This function is valid only when set to a non-zero value. When RBCT = 0, RX Packet/Byte counter is inactive.
When PSEL = 0, this field is multiplied by 1024, to get the actual number of byte threshold. When PSEL =1, RBCT value is directly used. Thus the maximum limit is 511 packets or 511 x 1024 bytes, respectively.</description>
              <bitRange>[29:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ITCU</name>
              <description>Receive Idle Timer Count Units
This fields indicates the number of system clock cycles corresponding to one unit in ITW field.</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>256</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>512</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>1024</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>2048</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RWTU</name>
              <description>Receive Interrupt Watchdog Timer Count Units
This fields indicates the number of system clock cycles corresponding to one unit in RWT field.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>256</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>512</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>1024</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>2048</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ITW</name>
              <description>Receive Idle Timer Window
This field when programmed with a non-zero value, enables operation of the Rx Idle Timer. The timer window is determined in number of system clock cycles when this field is multiplied by the ITCU unit.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RWT</name>
              <description>Receive Interrupt Watchdog Timer Count
This field indicates the number of system clock cycles, multiplied by factor indicated in RWTU field, for which the watchdog timer is set.
The watchdog timer is triggered with the programmed value after the Rx DMA completes the transfer of a packet for which the RI bit is not set in the ETH_DMA_CH0_STATUS register, because of the setting of Interrupt Enable bit in the corresponding descriptor RDES3[30].
When the watchdog timer runs out, the RI bit is set and the timer is stopped. The watchdog timer is reset when the RI bit is set high because of automatic setting of RI as per the Interrupt Enable bit RDES3[30] of any received packet.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_CURRENT_APP_TXDESC</name>
          <description>DMA Channel 0 Current Application Transmit Descriptor Register</description>
          <addressOffset>0x1144</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CURTDESAPTR</name>
              <description>Application Transmit Descriptor Address Pointer
The DMA updates this pointer during Tx operation. This pointer is cleared on reset.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_CURRENT_APP_RXDESC</name>
          <description>DMA Channel 0 Current Application Receive Descriptor Register</description>
          <addressOffset>0x114C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CURRDESAPTR</name>
              <description>Application Receive Descriptor Address Pointer
The DMA updates this pointer during Rx operation. This pointer is cleared on reset.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_CURRENT_APP_TXBUFFER</name>
          <description>DMA Channel 0 Current Application Transmit Buffer Address Register</description>
          <addressOffset>0x1154</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CURTBUFAPTR</name>
              <description>Application Transmit Buffer Address Pointer
The DMA updates this pointer during Tx operation. This pointer is cleared on reset.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_CURRENT_APP_RXBUFFER</name>
          <description>DMA Channel 0 Current Application Receive Buffer Address Register</description>
          <addressOffset>0x115C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CURRBUFAPTR</name>
              <description>Application Receive Buffer Address Pointer
The DMA updates this pointer during Rx operation. This pointer is cleared on reset.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_STATUS</name>
          <description>DMA Channel 0 Status Register</description>
          <addressOffset>0x1160</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REB</name>
              <description>Rx DMA Error Bits
This field indicates the type of error that caused a Bus Error. For example, error response on the AXI interface.
Bit 21
0x0: No error during data transfer by Rx DMA
0x1: Error during data transfer by Rx DMA
Bit 20
0x0: Error during data buffer access
0x1: Error during descriptor access
Bit 19
0x0: Error during write transfer
0x1: Error during read transfer</description>
              <bitRange>[21:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TEB</name>
              <description>Tx DMA Error Bits
This field indicates the type of error that caused a Bus Error. For example, error response on the AXI interface.
Bit 18
0x0: No error during data transfer by Tx DMA
0x1: Error during data transfer by Tx DMA
Bit 17
0x0: Error during data buffer access
0x1: Error during descriptor access
Bit 16
0x0: Error during write transfer
0x1: Error during read transfer</description>
              <bitRange>[18:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NIS</name>
              <description>Normal Interrupt Summary
Normal Interrupt Summary bit value is the logical OR of the following bits when the corresponding interrupt bits are enabled in the ETH_DMA_CH0_INTERRUPT_ENABLE register:
Bit 0: Transmit Interrupt
Bit 2: Transmit Buffer Unavailable
Bit 6: Receive Interrupt
Bit 11: Early Receive Interrupt
This is a sticky bit. The user must clear this bit (by writing 1 to this bit) each time a corresponding bit which causes NIS to be set is cleared.
Access restriction applies. Self-set to 1 on internal event. Setting 1 clears. Setting 0 has no effect.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Normal interrupt summary status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Normal interrupt summary status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AIS</name>
              <description>Abnormal Interrupt Summary
Abnormal Interrupt Summary bit value is the logical OR of the following when the corresponding interrupt bits are enabled in the ETH_DMA_CH0_INTERRUPT_ENABLE register:
Bit 1: Transmit Process Stopped
Bit 7: Receive Buffer Unavailable
Bit 8: Receive Process Stopped
Bit 10: Early Transmit Interrupt
Bit 12: Fatal Bus Error
Bit 13: Context Descriptor Error
This is a sticky bit. The user must clear this bit (by writing 1 to this bit) each time a corresponding bit, which causes AIS to be set, is cleared.
Access restriction applies. Self-set to 1 on internal event. Setting 1 clears. Setting 0 has no effect.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Abnormal interrupt summary status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Abnormal interrupt summary status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CDE</name>
              <description>Context Descriptor Error
This bit indicates that the DMA Tx/Rx engine received a descriptor error, which indicates invalid context in the middle of packet flow ( intermediate descriptor) or all one's descriptor in Tx case and on Rx side it indicates DMA has read a descriptor with either of the buffer address as ones which is considered to be invalid.
Access restriction applies. Self-set to 1 on internal event. Setting 1 clears. Setting 0 has no effect.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Context descriptor error status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Context descriptor error status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FBE</name>
              <description>Fatal Bus Error
This bit indicates that a bus error occurred (as described in the EB field). When this bit is set, the corresponding DMA channel engine disables all bus accesses.
Access restriction applies. Self-set to 1 on internal event. Setting 1 clears. Setting 0 has no effect.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Fatal bus error status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Fatal bus error status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ERI</name>
              <description>Early Receive Interrupt
This bit when set indicates that the Rx DMA has completed the transfer of packet data to the memory.
The setting of RI bit automatically clears this bit.
Access restriction applies. Self-set to 1 on internal event. Setting 1 clears. Setting 0 has no effect.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Early receive interrupt status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Early receive interrupt status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ETI</name>
              <description>Early Transmit Interrupt
This bit when set indicates that the Tx DMA has completed the transfer of packet data to the MTL TXFIFO memory.
Access restriction applies. Self-set to 1 on internal event. Setting 1 clears. Setting 0 has no effect.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Early transmit interrupt status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Early transmit interrupt status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RWT</name>
              <description>Receive Watchdog Timeout
This bit is asserted when a packet with length greater than 2,048 bytes (10,240 bytes when Jumbo Packet mode is enabled) is received.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive watchdog timeout status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive watchdog timeout status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RPS</name>
              <description>Receive Process Stopped
This bit is asserted when the Rx process enters the Stopped state.
Access restriction applies. Self-set to 1 on internal event. Setting 1 clears. Setting 0 has no effect.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive process stopped status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive process stopped status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RBU</name>
              <description>Receive Buffer Unavailable
This bit indicates that the application owns the next descriptor in the Receive list, and the DMA cannot acquire it. The Rx process is suspended. To resume processing Rx descriptors, the application should change the ownership of the descriptor and issue a Receive Poll Demand command. If this command is not issued, the Rx process resumes when the next recognized incoming packet is received. In ring mode, the application must advance the Receive Descriptor Tail Pointer register of a channel. This bit is set only when the DMA owns the previous Rx descriptor.
Access restriction applies. Self-set to 1 on internal event. Setting 1 clears. Setting 0 has no effect.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive buffer unavailable status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive buffer unavailable status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RI</name>
              <description>Receive Interrupt
This bit indicates that the packet reception is complete. When packet reception is complete, Bit 31 of RDES3 is reset in the last descriptor, and the specific packet status information is updated in the descriptor.
The reception remains in the Running state.
Access restriction applies. Self-set to 1 on internal event. Setting 1 clears. Setting 0 has no effect.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive interrupt status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive interrupt status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBU</name>
              <description>Transmit Buffer Unavailable
This bit indicates that the application owns the next descriptor in the Transmit list, and the DMA cannot acquire it. Transmission is suspended. the ETH_DMA_DEBUG_STATUS0[TPS0] field explains the Transmit Process state transitions.
To resume processing the Transmit descriptors, the application must do the following:
1. Change the ownership of the descriptor by setting Bit 31 of TDES3.
2. Issue a Transmit Poll Demand command.
For ring mode, the application should advance the Transmit Descriptor Tail Pointer register of a channel.
Access restriction applies. Self-set to 1 on internal event. Setting 1 clears. Setting 0 has no effect.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit buffer unavailable status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit buffer unavailable status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TPS</name>
              <description>Transmit Process Stopped
This bit is set when the transmission is stopped.
Access restriction applies. Self-set to 1 on internal event. Setting 1 clears. Setting 0 has no effect.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit process stopped status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit process stopped status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TI</name>
              <description>Transmit Interrupt
This bit indicates that the packet transmission is complete. When transmission is complete, Bit 31 of TDES3 is reset in the last descriptor, and the specific packet status information is updated in the descriptor.
Access restriction applies. Self-set to 1 on internal event. Setting 1 clears. Setting 0 has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit interrupt status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit interrupt status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_MISS_FRAME_CNT</name>
          <description>DMA Channel 0 Dropped Packet Counter Register</description>
          <addressOffset>0x1164</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MFCO</name>
              <description>Overflow status of the MFC Counter
When this bit is set then the MFC counter does not get incrementedfurther. The bit gets cleared when this register is read.
Access restriction applies. Clears on read. Self-set to 1 on internal event.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Miss frame counter overflow not occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Miss frame counter overflow occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MFC</name>
              <description>Dropped Packet Counters
This counter indicates the number of packet counters that are dropped by the DMA either because of bus error or because of programing the ETH_DMA_CH0_CONTROL[RPF] field. The counter gets cleared when this register is read.
Access restriction applies. Clears on read. Self-set to 1 on internal event.</description>
              <bitRange>[10:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SDMMC</name>
      <baseAddress>0x48102000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>3952</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>SDMMC_SDMASA_R</name>
          <description>SDMA System Address Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BLOCKCNT_SDMASA</name>
              <description>32-bit Block Count-SDMA System Address.
SDMMC_HOST_CTRL2_R[HOST_VER4_ENABLE] = 0x0: The BLOCKCNT_SDMASA bit field contains the system memory address for an SDMA transfer in the 32-bit addressing Mode. When the host controller stops an SDMA transfer, this bit field points to the system address of the next contiguous data position. It can be accessed only if no transaction is executing. Reading this bit field during data transfers may return invalid value.
32-bit Block Count
SDMMC_HOST_CTRL2_R[HOST_VER4_ENABLE] = 0x1: From the host controller version 4.10 specification, the BLOCKCNT_SDMASA bit field is redefined as 32-bit Block Count. The host controller decrements the block count of this bit field for every block transfer and the data transfer stops when the count reaches zero. This bit field must be accessed when no transaction is executing. Reading this bit field during data transfers may return invalid value.
Note: For the SDMMC_HOST_CTRL2_R[HOST_VER4_ENABLE] = 0x0, the host driver does not program the system address in this bit field while operating in ADMA mode. The system address must be programmed in the ADMA System Address register (SDMMC_ADMA_SA_LOW_R).
For the SDMMC_HOST_CTRL2_R[HOST_VER4_ENABLE] = 0x0, the host driver programs a non-zero 32-bit block count value in this bit field when Auto CMD23 is enabled for non-DMA and ADMA modes. Auto CMD23 cannot be used with SDMA.
This bit field must be programmed with a non-zero value for data transfer if the 32-bit Block Count register is used instead of the 16-bit Block Count register (SDMMC_BLOCKCOUNT_R).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0xFFFFFFFF</name>
                  <description>4GB-1 Block</description>
                  <value>0xFFFFFFFF</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x00000002</name>
                  <description>2 Blocks</description>
                  <value>0x00000002</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x00000001</name>
                  <description>1 Block</description>
                  <value>0x00000001</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x00000000</name>
                  <description>Stop count</description>
                  <value>0x00000000</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_BLOCKSIZE_R</name>
          <description>Block Size Register</description>
          <addressOffset>0x4</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>SDMA_BUF_BDARY</name>
              <description>SDMA Buffer Boundary.
These bits specify the size of a contiguous buffer in the system memory. The SDMA transfer waits at every boundary specified by these bits and the host controller generates the DMA interrupt to request the host driver to update the SDMMC_SDMASA_R register.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>4KB Bytes SDMA buffer boundary</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>8KB Bytes SDMA buffer boundary</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>16KB Bytes SDMA buffer boundary</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>32KB Bytes SDMA buffer boundary</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>64KB Bytes SDMA buffer boundary</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>128KB Bytes SDMA buffer boundary</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>256KB Bytes SDMA buffer boundary</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>512KB Bytes SDMA buffer boundary</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>XFER_BLOCK_SIZE</name>
              <description>Transfer Block Size.
These bits specify the block size of data transfers. In case of memory, it is set to 512 bytes. It can be accessed only if no transaction is executing. Read operations during transfers may return an invalid value, and write operations are ignored. Following are the values for this bit field:</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>1 Byte</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>2 Bytes</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>3 Bytes</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1FF</name>
                  <description>511 Byte</description>
                  <value>0x1FF</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x200</name>
                  <description>512 Bytes</description>
                  <value>0x200</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x800</name>
                  <description>2048 Bytes</description>
                  <value>0x800</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_BLOCKCOUNT_R</name>
          <description>16-bit Block Count Register</description>
          <addressOffset>0x6</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>BLOCK_CNT</name>
              <description>16-bit Block Count.
If the SDMMC_HOST_CTRL2_R[HOST_VER4_ENABLE] bit is set to 0x0 or this bit field is set to non-zero, the 16-bit Block Count register is selected.
If the SDMMC_HOST_CTRL2_R[HOST_VER4_ENABLE] bit is set to 0x1 and this bit field is set to zero, the 32-bit Block Count register is selected.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Stop count</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>1 Block</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>2 Blocks</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xFFFF</name>
                  <description>65535 Blocks</description>
                  <value>0xFFFF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_ARGUMENT_R</name>
          <description>Argument Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ARGUMENT</name>
              <description>Command Argument.
These bits specify the SD or eMMC command argument that is specified in bits 39 to 8 of the Command Format.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_XFER_MODE_R</name>
          <description>Transfer Mode Register</description>
          <addressOffset>0xC</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>RESP_INT_DISABLE</name>
              <description>Response Interrupt Disable.
The host controller supports response check function to avoid overhead of response error check by the host driver. Response types of only R1 and R5 can be checked by the host controller.
If the host driver checks the response error, this bit should be set to 0x0 and wait for Command Complete interrupt and then check the respective response register (SDMMC_RESP01_R, SDMMC_RESP23_R, SDMMC_RESP45_R, and SDMMC_RESP67_R).
If the host controller checks the response error, this bit and the SDMMC_XFER_MODE_R[RESP_ERR_CHK_ENABLE] bit should be set to 0x1. The Command Complete interrupt is disabled by this bit regardless of the Command Complete Signal Enable (SDMMC_NORMAL_INT_SIGNAL_EN_R[CMD_COMPLETE_SIGNAL_EN]).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Response interrupt is enabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Response interrupt is disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESP_ERR_CHK_ENABLE</name>
              <description>Response Error Check Enable.
The host controller supports response check function to avoid overhead of response error check by the host driver. Response types of only R1 and R5 can be checked by the Controller. If the host controller checks the response error, this bit and the SDMMC_XFER_MODE_R[RESP_INT_DISABLE] bit should be set to 0x1. If an error is detected, the Response Error interrupt is generated (see SDMMC_ERROR_INT_STAT_R[RESP_ERR] bit).
Note: Response error check must not be enabled for any response types other than R1 and R5.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Response Error Check is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Response Error Check is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESP_TYPE</name>
              <description>Response Type R1/R5.
This bit selects either R1 or R5 as a response type when the Response Error Check is selected (SDMMC_XFER_MODE_R[RESP_ERR_CHK_ENABLE]).
Error statuses checked in R1:
- OUT_OF_RANGE
- ADDRESS_ERROR
- BLOCK_LEN_ERROR
- WP_VIOLATION
- CARD_IS_LOCKED
- COM_CRC_ERROR
- CARD_ECC_FAILED
- CC_ERROR
- ERROR
- COM_CRC_ERROR
- ERROR
- FUNCTION_NUMBER
- OUT_OF_RANGE</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>R1 (Memory)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>R5 (SDIO)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MULTI_BLK_SEL</name>
              <description>Multi/Single Block Select.
This bit is set when issuing multiple-block transfer commands using the DAT line. If this bit is set to 0x0, it is not necessary to set the SDMMC_BLOCKCOUNT_R register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Single block</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Multiple block</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATA_XFER_DIR</name>
              <description>Data Transfer Direction Select.
This bit defines the direction of the DAT line data transfers. This bit is set to 0x1 by the host driver to transfer data from the SD or eMMC card to the host controller and it is set to 0x0 for all other commands.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Write (Host to Card)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Read (Card to Host)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AUTO_CMD_ENABLE</name>
              <description>Auto Command Enable.
This bit field determines use of Auto Command functions.</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Auto Command disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Auto CMD12 enable</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Auto CMD23 enable</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Auto CMD Auto select</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BLOCK_COUNT_ENABLE</name>
              <description>Block Count Enable.
This bit is used to enable the SDMMC_BLOCKCOUNT_R register, which is relevant for multiple block transfers. If this bit is set to 0x0, the SDMMC_BLOCKCOUNT_R register is disabled, which is useful in executing an infinite transfer.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DMA_ENABLE</name>
              <description>DMA Enable.
This bit enables the DMA functionality. If this bit is set to 0x1, a DMA operation begins when the host driver writes to the SDMMC_CMD_R register. One of the DMA modes can be selected by setting the SDMMC_HOST_CTRL1_R[DMA_SEL] bit field.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No data transfer or non-DMA data transfer</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA data transfer</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_CMD_R</name>
          <description>Command Register</description>
          <addressOffset>0xE</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CMD_INDEX</name>
              <description>Command Index.
These bits are set to the command number that is specified in bits 45 to 40 of the Command Format.</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_TYPE</name>
              <description>Command Type.
These bits indicate the command type.
Note: While issuing Abort CMD using CMD12/CMD52 or reset CMD using CMD0/CMD52, CMD_TYPE, these bits must be set to 0x3. In case CMD0 is used for initialization, set this bit field to 0x0.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Normal</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Suspend</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Resume</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Abort</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATA_PRESENT_SEL</name>
              <description>Data Present Select.
This bit is set to 0x1 to indicate that data is present and that the data is transferred using the DAT line. This bit is set to 0x0 in the following instances:
- Command using the CMD line
- Command with no data transfer but using busy signal on the DAT[0] line
- Resume Command</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No data present</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Data present</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_IDX_CHK_ENABLE</name>
              <description>Command Index Check Enable.
This bit enables the host controller to check the index field in the response to verify if it has the same value as the command index. If the value is not the same, it is reported as a Command Index error.
Note: Index Check enable must be set to 0x0 for the command with no response, R2 response, R3 response and R4 response.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_CRC_CHK_ENABLE</name>
              <description>Command CRC Check Enable.
This bit enables the host controller to check the CRC field in the response. If an error is detected, it is reported as a Command CRC error.
Note: CRC Check enable must be set to 0x0 for the command with no response, R3 response, and R4 response.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUB_CMD_FLAG</name>
              <description>Sub-command Flag.
This bit distinguishes between a main command and a Sub-command.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Main command</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Sub-command</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESP_TYPE_SELECT</name>
              <description>Response Type Select.
This bit field indicates the type of response expected from the card.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No response</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Response length 136</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Response length 48</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Response length 48; Check busy after response</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_RESP01_R</name>
          <description>Response Register 0/1</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESP01</name>
              <description>Command Response.
These bits reflect 39 to 8 bits of the SD or eMMC response field.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_RESP23_R</name>
          <description>Response Register 2/3</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESP23</name>
              <description>Command Response.
These bits reflect 71 to 40 bits of the SD or eMMC response field.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_RESP45_R</name>
          <description>Response Register 4/5</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESP45</name>
              <description>Command Response.
These bits reflect 103 to 72 bits of the SD or eMMC response field.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_RESP67_R</name>
          <description>Response Register 6/7</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESP67</name>
              <description>Command Response.
These bits reflect bits 135 to 104 of the SD or eMMC response field.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_BUF_DATA_R</name>
          <description>Buffer Data Port Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUF_DATA</name>
              <description>Buffer Data.
These bits enable access to the host controller packet buffer.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_PSTATE_REG</name>
          <description>Present State Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IN_DORMANT_ST</name>
              <description>In Dormant Status.
for both SD or eMMC modes, this bit always returns 0x0.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not in Dormant state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>In Dormant state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUB_CMD_STAT</name>
              <description>Sub-command Status.
This bit is used to distinguish between a main command and a Sub-command status.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Main command status</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Sub-command status</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_ISSUE_ERR</name>
              <description>Command Not Issued by Error.
This bit is set if a command cannot be issued after setting the SDMMC_CMD_R register due to an error except the Auto CMD12 error.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error for issuing a command</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Command cannot be issued</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_LINE_LVL</name>
              <description>Command-Line Signal Level.
This bit is used to check the CMD line level to recover from errors and for debugging. These bits reflect the value of the SD_CMD input signal.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DAT_3_0</name>
              <description>DAT[3-0] Line Signal Level.
This bit is used to check the DAT line level to recover from errors and for debugging. These bits reflect the value of the SD_D[0-3] input (lower nibble) signals.</description>
              <bitRange>[23:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PROTECT_SW_LVL</name>
              <description>Write Protect Switch Pin Level.
This bit is supported only for memory and combo cards. This bit reflects the synchronized value of the card write protect signal.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Write protected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Write enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_DETECT_PIN_LEVEL</name>
              <description>Card Detect Pin Level.
This bit reflects the inverse synchronized value of the card detect signal.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No card present</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Card present</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_STABLE</name>
              <description>Card Stable.
This bit indicates the stability of the Card Detect Pin Level (see CARD_DETECT_PIN_LEVEL bit). A card is not detected if this bit is set to 0x1 and the value of the CARD_INSERTED bit is 0x0.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Reset or debouncing</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>No card or Inserted</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_INSERTED</name>
              <description>Card Inserted.
This bit indicates whether a card has been inserted. The host controller debounces this signal so that host driver need not wait for it to stabilize.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Reset, debouncing, or no card</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Card inserted</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUF_RD_ENABLE</name>
              <description>Buffer Read Enable.
This bit is used for non-DMA transfers. This bit is set if valid data exists in the Host buffer.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Read disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Read enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUF_WR_ENABLE</name>
              <description>Buffer Write Enable.
This bit is used for non-DMA transfers. This bit is set if space is available for writing data.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Write disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Write enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RD_XFER_ACTIVE</name>
              <description>Read Transfer Active.
This bit indicates whether a read transfer is active for both SD or eMMC modes.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No valid data</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transferring data</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WR_XFER_ACTIVE</name>
              <description>Write Transfer Active.
This status indicates whether a write transfer is active for both SD or eMMC modes.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No valid data</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transferring data</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DAT_7_4</name>
              <description>DAT[7-4] Line Signal Level.
This bit is used to check the DAT line level to recover from errors and for debugging. These bits reflect the value of the SD_D[7-4] input (upper nibble) signals.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DAT_LINE_ACTIVE</name>
              <description>DAT Line Active (SD or eMMC mode only).
This bit indicates whether one of the DAT lines on the SD or eMMC bus is in use.
In the case of read transactions, this bit indicates whether a read transfer is executing on the SD or eMMC bus.
In the case of write transactions, this bit indicates whether a write transfer is executing on the SD or eMMC bus.
For a command with busy, this status indicates whether the command executing busy is executing on an SD or eMMC bus.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DAT line inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DAT line active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_INHIBIT_DAT</name>
              <description>Command Inhibit for DAT line
This bit is applicable for both SD or eMMC modes and is generated if either DAT line active or Read transfer active is set to 0x1. If this bit is set to 0x0, it indicates that the host controller can issue subsequent SD or eMMC commands.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Can issue command which used DAT line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Cannot issue command which used DAT line</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_INHIBIT</name>
              <description>Command Inhibit for CMD line
This bit indicates the following:
SD or eMMC mode: If this bit is set to 0x0, it indicates that the CMD line is not in use and the host controller can issue an SD or eMMC command using the CMD line. This bit is set when the SDMMC_CMD_R register is written. This bit is cleared when the command response is received. This bit is not cleared by the response of auto CMD12/23 but cleared by the response of read/write command.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Host controller is ready to issue a command</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Host controller is not ready to issue a command</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_HOST_CTRL1_R</name>
          <description>Host Control 1 Register</description>
          <addressOffset>0x28</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>CARD_DETECT_SIG_SEL</name>
              <description>Card Detect Signal Selection.
This bit selects a source for card detection. When the source for the card detection is switched, the interrupt must be disabled during the switching period.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Card detect signal is selected (for normal use)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Card detect test level is selected (for test purpose)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_DETECT_TEST_LVL</name>
              <description>Card Detect Test Level.
This bit is enabled while the SDMMC_HOST_CTRL1_R[CARD_DETECT_SIG_SEL] bit is set to 0x1 and it indicates whether a card inserted or not.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No card</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Card inserted</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EXT_DAT_XFER</name>
              <description>Extended Data Transfer Width.
This bit controls 8-bit bus width mode of embedded device.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Bus width is selected by the SDMMC_HOST_CTRL1_R [DAT_XFER_WIDTH] bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>8-bit bus width</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DMA_SEL</name>
              <description>DMA Select.
This field is used to select the DMA type.
When the SDMMC_HOST_CTRL2_R[HOST_VER4_ENABLE] bit is set to 0x1:
0x0: SDMA is selected
0x1: Reserved
0x2: ADMA2 is selected
0x3: ADMA2 or ADMA3 is selected
When the SDMMC_HOST_CTRL2_R[HOST_VER4_ENABLE] bit is set to 0x0:
0x0: SDMA is selected
0x1: Reserved
0x2: 32-bit Address ADMA2 is selected
0x3: 64-bit Address ADMA2 is selected</description>
              <bitRange>[4:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DAT_XFER_WIDTH</name>
              <description>Data Transfer Width.
For both SD or eMMC modes, this bit selects the data transfer width of the host controller. The host driver sets it to match the data width of the SD or eMMC card.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1-bit mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>4-bit mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LED_CTRL</name>
              <description>LED Control.
This bit is used to caution not to remove the card while the SD card is being accessed. The value is reflected on the led control signal.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>LED off</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>LED on</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_PWR_CTRL_R</name>
          <description>Power Control Register</description>
          <addressOffset>0x29</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>SD_BUS_VOL_VDD2</name>
              <description>SD Bus Voltage Select for VDD2.
 This is irrelevant for SD and eMMC card.</description>
              <bitRange>[7:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>VDD2 Not Supported</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>1.8 V</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>Not used</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>Not used</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SD_BUS_PWR_VDD2</name>
              <description>SD Bus Power for VDD2.
 This is irrelevant for SD and eMMC card.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Power off</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Power on</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SD_BUS_VOL_VDD1</name>
              <description>SD Bus Voltage Select for VDD1/eMMC Bus Voltage Select for VDD.
These bits enable the host driver to select the voltage level for an SD or eMMC card. Before setting these bits, the host driver checks the Voltage Support bits in the Capabilities register (SDMMC_CAPABILITIES1_R and SDMMC_CAPABILITIES2_R). If an unsupported voltage is selected, the Host System does not supply the SD Bus voltage. The value set in this field is available on the SDMMC output signal, which is used by the voltage switching circuitry.
SD Bus Voltage Select options:
0x0 - 0x4: Reserved
0x5: 1.8 V (Typical) for Embedded
0x6: 3.0 V (Typical)
0x7: 3.3 V (Typical)
eMMC Bus Voltage Select options:
0x0 - 0x4: Reserved
0x5: 1.2 V (Typical)
0x6: 1.8 V (Typical)
0x7: 3.3 V (Typical)</description>
              <bitRange>[3:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SD_BUS_PWR_VDD1</name>
              <description>SD Bus Power for VDD1.
It can be used to control the VDD1 power supply of the card. Before setting this bit, the SD host driver sets the SD Bus Voltage Select bit. If the host controller detects a No Card state, this bit is cleared.
In SD mode, if this bit is cleared, the host controller stops the SD clock by clearing the SDMMC_CLK_CTRL_R[SD_CLK_IN] bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Power off</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Power on</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_BGAP_CTRL_R</name>
          <description>Block Gap Control Register</description>
          <addressOffset>0x2A</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>INT_AT_BGAP</name>
              <description>Interrupt at Block Gap.
This bit is valid only in the 4-bit mode of an SDIO card and is used to select a sample point in the interrupt cycle. Setting this bit to 0x1 enables interrupt detection at the block gap for a multiple block transfer.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RD_WAIT_CTRL</name>
              <description>Read Wait Control.
This bit is used to enable the read wait protocol to stop read data using SD_D[2] line if the card supports read wait. Otherwise, the host controller has to stop the card clock to hold the read data.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable read wait control</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable read wait control</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CONTINUE_REQ</name>
              <description>Continue Request.
This bit is used to restart the transaction, which was stopped using the Stop at Block Gap Request (SDMMC_BGAP_CTRL_R[STOP_BG_REQ]). The host controller automatically clears this bit when the transaction restarts. If stop at block gap request is set to 0x1, any write to this bit is ignored.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No affect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Restart</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STOP_BG_REQ</name>
              <description>Stop at Block Gap Request.
This bit is used to stop executing read and write transactions at the next block gap for non-DMA, SDMA, and ADMA transfers.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transfer</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Stop</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_WUP_CTRL_R</name>
          <description>Wakeup Control Register</description>
          <addressOffset>0x2B</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>CARD_REMOVAL</name>
              <description>Wakeup Event Enable on SD Card Removal.
This bit enables wakeup event through Card Removal assertion in the SDMMC_NORMAL_INT_STAT_EN_R register. For the SDIO card, wake up support in the Card Information Structure (CIS) register does not affect this bit.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_INSERT</name>
              <description>Wakeup Event Enable on SD Card Insertion.
This bit enables wakeup event through Card Insertion assertion in the SDMMC_NORMAL_INT_STAT_EN_R register. Wake Up Support in CIS register does not affect this bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_INT</name>
              <description>Wakeup Event Enable on Card Interrupt.
This bit enables wakeup event through a Card Interrupt assertion in the SDMMC_NORMAL_INT_STAT_EN_R register. This bit can be set to 0x1 if Wake Up Support in CIS register is set to 0x1.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_CLK_CTRL_R</name>
          <description>Clock Control Register</description>
          <addressOffset>0x2C</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>FREQ_SEL</name>
              <description>SD_CLK Frequency Select.
These bits are used to select the frequency of the SD_CLK signal. These bits depend on setting of the SDMMC_HOST_CTRL2_R[PRESET_VAL_ENABLE] bit. If the SDMMC_HOST_CTRL2_R[PRESET_VAL_ENABLE] = 0x0, these bits are set by the host driver. If the SDMMC_HOST_CTRL2_R[PRESET_VAL_ENABLE] = 0x1, these bits are automatically set to a value specified in one of the Preset Value register.
10-bit Divided Clock Mode:
0x000: Base clock
0x001: 1/2 Divided clock
0x002: 1/4 Divided clock
...
N: 1/2N Divided clock
...
0x3FF: 1/2046 Divided clock
Programmable Clock mode (enables the Host System to select a fine grain SD clock frequency):
0x000: Base clock x M
0x001: Base clock x M/2
0x002: Base clock x M/3
...
N-1: Base clock x M/N
...
0x3FF: Base clock x M/1024</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UPPER_FREQ_SEL</name>
              <description>These bits specify the upper 2 bits of 10-bit SD_CLK Frequency Select control (FREQ_SEL bit field).</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_GEN_SELECT</name>
              <description>Clock Generator Select.
This bit is used to select the clock generator mode in SD_CLK Frequency Select-FREQ_SEL bit. If the SDMMC_HOST_CTRL2_R[PRESET_VAL_ENABLE] = 0x0, this bit is set by the host driver. If the SDMMC_HOST_CTRL2_R[PRESET_VAL_ENABLE] = 0x1, this bit is automatically set to a value specified in one of the Preset Value registers.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Divided clock mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Programmable clock mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PLL_ENABLE</name>
              <description>PLL Enable.
This bit is used to activate the PLL (applicable when the SDMMC_HOST_CTRL2_R[HOST_VER4_ENABLE] = 0x1).
When the SDMMC_HOST_CTRL2_R[HOST_VER4_ENABLE] = 0x0, the INTERNAL_CLK_EN bit may be used to activate PLL.
Note: If this bit is not used to active the PLL when the SDMMC_HOST_CTRL2_R[HOST_VER4_ENABLE] = 0x1, it is recommended to set it to 0x1.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>PLL is in low power mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>PLL is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SD_CLK_EN</name>
              <description>SD or eMMC Clock Enable.
This bit stops the SD_CLK when is set to 0x0. The FREQ_SEL bit field can be changed when this bit is set to 0x0.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable providing SD_CLK</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable providing SD_CLK</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INTERNAL_CLK_STABLE</name>
              <description>Internal Clock Stable.
This bit enables the host driver to check the clock stability twice after the SDMMC_CLK_CTRL_R[INTERNAL_CLK_EN] bit is set and after both INTERNAL_CLK_EN and PLL_ENABLE bits are set.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not ready</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Ready</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INTERNAL_CLK_EN</name>
              <description>Internal Clock Enable.
This bit is set to 0x0 when the host driver is not using the host controller or the host controller awaits a wakeup interrupt. The host controller must stop its internal clock to enter a very low power state. However, registers can still be read and written to.
Note: If this bit is not used to control the internal clock (base clock and master clock), it is recommended to set it to 0x1.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Stop</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Oscillate</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_TOUT_CTRL_R</name>
          <description>Timeout Control Register</description>
          <addressOffset>0x2E</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>TOUT_CNT</name>
              <description>Data Timeout Counter Value.
This value determines the interval by which DAT line timeouts are detected. The timeout clock frequency is generated by dividing the base clock (BCLK) value by this value. When setting this bit field, the user should prevent inadvertent timeout events by clearing the SDMMC_ERROR_INT_STAT_EN_R[DATA_TOUT_ERR_STAT_EN] bit.
The values for these bits are:
Note: During a boot operating in an eMMC mode, an application must configure the boot data timeout value (approximately 1 second) in this bit field.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>TMCLK x 2^13</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>TMCLK x 2^14</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xE</name>
                  <description>TMCLK x 2^27</description>
                  <value>0xE</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_SW_RST_R</name>
          <description>Software Reset Register</description>
          <addressOffset>0x2F</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>SW_RST_DAT</name>
              <description>Software Reset for DAT line.
This bit is used in SD or eMMC modes and it resets only a part of the data circuit and the DMA circuit is also reset.
The following registers and bits are cleared by this bit:
SDMMC_BUF_DATA_R register:
- Buffer is cleared and initialized.
SDMMC_PSTATE_REG register:
- Buffer Read Enable
- Buffer Write Enable
- Read Transfer Active
- Write Transfer Active
- DAT Line Active
- Command Inhibit (DAT)
SDMMC_BGAP_CTRL_R register:
- Continue Request
- Stop at Block Gap Request
SDMMC_NORMAL_INT_STAT_EN_R register:
- Buffer Read Ready
- Buffer Write Ready
- DMA Interrupt
- Block Gap Event
- Transfer Complete</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Work</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_RST_CMD</name>
              <description>Software Reset for CMD line.
This bit resets only a part of the command circuit to be able to issue a command. This reset is effective only for a command issuing circuit (including response error statuses related to Command Inhibit for CMD line control) and does not affect the data transfer circuit. Host controller can continue data transfer even after this reset is executed while handling subcommand-response errors.
The following registers and bits are cleared by this bit:
- SDMMC_PSTATE_REG register: CMD_INHIBIT bit
- SDMMC_NORMAL_INT_STAT_EN_R register: Command Complete bit
- SDMMC_ERROR_INT_STAT_EN_R register: Response error statuses related to CMD_INHIBIT bit</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Work</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_RST_ALL</name>
              <description>Software Reset for All.
This reset affects the entire host controller except for the card detection circuit. During its initialization, the host driver sets this bit to 0x1 to reset the host controller. All registers are reset except the capabilities register (SDMMC_CAPABILITIES1_R and SDMMC_CAPABILITIES2_R). If this bit is set to 0x1, the host driver must issue reset command and reinitialize the card.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Work</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_NORMAL_INT_STAT_R</name>
          <description>Normal Interrupt Status Register</description>
          <addressOffset>0x30</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_INTERRUPT</name>
              <description>Error Interrupt.
If any of the operating bits in the SDMMC_ERROR_INT_STAT_R register are set, then this bit is set.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FX_EVENT</name>
              <description>FX Event.
This status is set when R[14] of response register is set to 0x1 and Response Type R1/R5 is set to 0x0 in the SDMMC_XFER_MODE_R register. This interrupt is used with response check function.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>FX Event is detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INT_C</name>
              <description>INT_C (Embedded).
This bit is set if INT_C is enabled.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INT_B</name>
              <description>INT_B (Embedded).
This bit is set if INT_B is enabled.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INT_A</name>
              <description>INT_A (Embedded).
This bit is set if INT_A is enabled.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CARD_INTERRUPT</name>
              <description>Card Interrupt.
This bit reflects the synchronized value of DAT[1] Interrupt input for SD mode</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No card interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Generate card Interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_REMOVAL</name>
              <description>Card Removal.
This bit is set if the Card Inserted in the Present State register changes from 0x1 to 0x0.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Card state stable or debouncing</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Card removed. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_INSERTION</name>
              <description>Card Insertion.
This bit is set if the Card Inserted in the Present State register changes from 0x0 to 0x1.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Card state stable or debouncing</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Card inserted. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUF_RD_READY</name>
              <description>Buffer Read Ready.
This bit is set if the SDMMC_PSTATE_REG[BUF_RD_ENABLE] bit changes from 0x0 to 0x1.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not ready to read buffer</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Ready to read buffer. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUF_WR_READY</name>
              <description>Buffer Write Ready.
This bit is set if the SDMMC_PSTATE_REG[BUF_WR_ENABLE] bit changes from 0x0 to 0x1.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not ready to write buffer</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Ready to write buffer. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DMA_INTERRUPT</name>
              <description>DMA Interrupt.
This bit is set if the host controller detects the SDMA Buffer Boundary during transfer (refer to SDMMC_BLOCKSIZE_R). In case of ADMA, by setting the Interrupt field in the descriptor table, the host controller generates this interrupt. This interrupt is not generated after a Transfer Complete.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No DMA interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA Interrupt is generated. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BGAP_EVENT</name>
              <description>Block Gap Event.
This bit is set when both read and write transaction is stopped at block gap due to a Stop at Block Gap Request (SDMMC_BGAP_CTRL_R[STOP_BG_REQ]).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No block gap event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transaction stopped at block gap. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>XFER_COMPLETE</name>
              <description>Transfer Complete.
This bit is set when a read and write transfer and a command with status busy is completed.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not complete</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Command execution is completed. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_COMPLETE</name>
              <description>Command Complete.
In both SD and eMMC modes, this bit is set when the end bit of a response except for Auto CMD12 and Auto CMD23.
This interrupt is not generated when the SDMMC_XFER_MODE_R[RESP_INT_DISABLE] bit is set to 0x1.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No command complete</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Command complete. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_ERROR_INT_STAT_R</name>
          <description>Error Interrupt Status Register</description>
          <addressOffset>0x32</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>VENDOR_ERR3</name>
              <description>Reserved. It always returns 0x0.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VENDOR_ERR2</name>
              <description>Reserved. It always returns 0x0.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VENDOR_ERR1</name>
              <description>Reserved. It always returns 0x0.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BOOT_ACK_ERR</name>
              <description>Boot Acknowledgement Error.
This bit is set when there is a timeout for boot acknowledgement or when detecting boot ACK status having a value other than 0x0. This is applicable only when boot acknowledgement is expected in eMMC mode.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESP_ERR</name>
              <description>Response Error.
Host controller version 4.00 supports response error check function to avoid overhead of response error check by the host driver during DMA execution. If the SDMMC_XFER_MODE_R[RESP_ERR_CHK_ENABLE] bit is set to 0x1, the host controller checks R1 or R5 response. If an error is detected in a response, this bit is set to 0x1. This is applicable in SD or eMMC modes.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADMA_ERR</name>
              <description>ADMA Error.
This bit is set when the host controller detects error during ADMA-based data transfer. The error could be due to Error response received from System bus (Master interface)-ADMA3, ADMA2 Descriptors invalid</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AUTO_CMD_ERR</name>
              <description>Auto CMD Error.
This error status is used by Auto CMD12 and Auto CMD23 in SD or eMMC modes. This bit is set when detecting that any of the bits D00 to D05 in Auto CMD Error Status register has changed from 0x0 to 0x1. D07 is effective in case of Auto CMD12. The Auto CMD Error Status register is valid while this bit is set to 0x1 and may be cleared by clearing of this bit.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CUR_LMT_ERR</name>
              <description>Current Limit Error.
By setting the SD Bus Power bit in the SDMMC_PWR_CTRL_R register, the host controller is requested to supply power for the SD Bus. If the host controller supports the Current Limit function, it can be protected from an illegal card by stopping power supply to the card in which case this bit indicates a failure status. A reading of 0x1 for this bit means that the host controller is not supplying power to the SD card due to some failure. A reading of 0x0 for this bit means that the host controller is supplying power and no error has occurred. The host controller may require some sampling time to detect the current limit. If the SDMMC host controller does not support this function, this bit is always set to 0x0.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Power Fail. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATA_END_BIT_ERR</name>
              <description>Data End Bit Error.
This error occurs in SD or eMMC modes either when detecting 0x0 at the end bit position of read data that uses the DAT line or at the end bit position of the CRC status.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATA_CRC_ERR</name>
              <description>Data CRC Error.
This error occurs in SD or eMMC modes when detecting CRC error when transferring read data which uses the DAT line, when detecting the Write CRC status having a value of other than 0x0 or when write CRC status timeout.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATA_TOUT_ERR</name>
              <description>Data Timeout Error.
This bit is set in SD or eMMC modes when detecting one of the following timeout conditions:
- Busy timeout for R1b, R5b type
- Busy timeout after Write CRC status
- Write CRC Status timeout
- Read Data timeout</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Time out. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_IDX_ERR</name>
              <description>Command Index Error.
This bit is set if a Command Index error occurs in the command response in SD or eMMC modes.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_END_BIT_ERR</name>
              <description>Command End Bit Error.
This bit is set when detecting that the end bit of a command response is 0x0 in SD or eMMC modes.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>End bit error generated. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_CRC_ERR</name>
              <description>Command CRC Error.
Command CRC Error is generated in SD or eMMC modes for following two cases.
If a response is returned and the Command Timeout Error (SDMMC_ERROR_INT_STAT_R[CMD_TOUT_ERR]) is set to 0x0 (indicating no timeout), this bit is set to 0x1 when detecting a CRC error in the command response.
The host controller detects a CMD line conflict by monitoring the CMD line when a command is issued. If the host controller drives the CMD line to 0x1 level, but detects 0x0 level on the CMD line at the next SD clock edge, then the host controller terminates the command (stop driving CMD line) and set this bit to 0x1. The SDMMC_ERROR_INT_STAT_R[CMD_TOUT_ERR] bit is also set to 0x1 to distinguish a CMD line conflict.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CRC error generated. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_TOUT_ERR</name>
              <description>Command Timeout Error.
 in SD or eMMC modes, this bit is set only if no response is returned within 64 SD clock cycles from the end bit of the command. If the host controller detects a CMD line conflict, along with the SDMMC_ERROR_INT_STAT_R[CMD_CRC_ERR] bit, this bit is set to 0x1, without waiting for 64 SD or eMMC card clock cycles.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Time out. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_NORMAL_INT_STAT_EN_R</name>
          <description>Normal Interrupt Status Enable Register</description>
          <addressOffset>0x34</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>FX_EVENT_STAT_EN</name>
              <description>FX Event Status Enable.
This bit is added from Version 4.10.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INT_C_STAT_EN</name>
              <description>INT_C (Embedded) Status Enable.
If this bit is set to 0x0, the host controller clears the interrupt request to the System. The host driver may clear this bit before servicing the INT_C and may set this bit again after all interrupt requests to INT_C pin are cleared to prevent inadvertent interrupts.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INT_B_STAT_EN</name>
              <description>INT_B (Embedded) Status Enable.
If this bit is set to 0x0, the host controller clears the interrupt request to the System. The host driver may clear this bit before servicing the INT_B and may set this bit again after all interrupt requests to INT_B pin are cleared to prevent inadvertent interrupts.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INT_A_STAT_EN</name>
              <description>INT_A (Embedded) Status Enable.
If this bit is set to 0x0, the host controller clears the interrupt request to the System. The host driver may clear this bit before servicing the INT_A and may set this bit again after all interrupt requests to INT_A pin are cleared to prevent inadvertent interrupts.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_INTERRUPT_STAT_EN</name>
              <description>Card Interrupt Status Enable.
If this bit is set to 0x0, the host controller clears the interrupt request to the System. The Card Interrupt detection is stopped when this bit is cleared and restarted when this bit is set to 0x1. The host driver may clear the Card Interrupt Status Enable before servicing the Card Interrupt and may set this bit again after all interrupt requests from the card are cleared to prevent inadvertent interrupts.
By setting this bit to 0x0, interrupt input must be masked by implementation so that the interrupt input is not affected by external signal in any state (for example: floating).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_REMOVAL_STAT_EN</name>
              <description>Card Removal Status Enable.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_INSERTION_STAT_EN</name>
              <description>Card Insertion Status Enable.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUF_RD_READY_STAT_EN</name>
              <description>Buffer Read Ready Status Enable.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUF_WR_READY_STAT_EN</name>
              <description>Buffer Write Ready Status Enable.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DMA_INTERRUPT_STAT_EN</name>
              <description>DMA Interrupt Status Enable.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BGAP_EVENT_STAT_EN</name>
              <description>Block Gap Event Status Enable.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>XFER_COMPLETE_STAT_EN</name>
              <description>Transfer Complete Status Enable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_COMPLETE_STAT_EN</name>
              <description>Command Complete Status Enable.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_ERROR_INT_STAT_EN_R</name>
          <description>Error Interrupt Status Enable Register</description>
          <addressOffset>0x36</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>BOOT_ACK_ERR_STAT_EN</name>
              <description>Boot Acknowledgment Error (eMMC mode only).
Setting this bit to 0x1 enables setting of Boot Acknowledgment Error in the SDMMC_ERROR_INT_STAT_R register.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESP_ERR_STAT_EN</name>
              <description>Response Error Status Enable (SD mode only).</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADMA_ERR_STAT_EN</name>
              <description>ADMA Error Status Enable.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AUTO_CMD_ERR_STAT_EN</name>
              <description>Auto CMD Error Status Enable (SD or eMMC mode only).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CUR_LMT_ERR_STAT_EN</name>
              <description>Current Limit Error Status Enable.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATA_END_BIT_ERR_STAT_EN</name>
              <description>Data End Bit Error Status Enable (SD or eMMC mode only).</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATA_CRC_ERR_STAT_EN</name>
              <description>Data CRC Error Status Enable (SD or eMMC mode only).</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATA_TOUT_ERR_STAT_EN</name>
              <description>Data Timeout Error Status Enable (SD or eMMC mode only).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_IDX_ERR_STAT_EN</name>
              <description>Command Index Error Status Enable (SD or eMMC mode only).</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_END_BIT_ERR_STAT_EN</name>
              <description>Command End Bit Error Status Enable (SD or eMMC mode only).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_CRC_ERR_STAT_EN</name>
              <description>Command CRC Error Status Enable (SD or eMMC mode only).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_TOUT_ERR_STAT_EN</name>
              <description>Command Timeout Error Status Enable (SD or eMMC mode only).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_NORMAL_INT_SIGNAL_EN_R</name>
          <description>Normal Interrupt Signal Enable Register</description>
          <addressOffset>0x38</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0x7FFF</resetMask>
          <fields>
            <field>
              <name>FX_EVENT_SIGNAL_EN</name>
              <description>FX Event Signal Enable.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INT_C_SIGNAL_EN</name>
              <description>INT_C (Embedded) Signal Enable.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INT_B_SIGNAL_EN</name>
              <description>INT_B (Embedded) Signal Enable.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INT_A_SIGNAL_EN</name>
              <description>INT_A (Embedded) Signal Enable.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_INTERRUPT_SIGNAL_EN</name>
              <description>Card Interrupt Signal Enable.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_REMOVAL_SIGNAL_EN</name>
              <description>Card Removal Signal Enable.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_INSERTION_SIGNAL_EN</name>
              <description>Card Insertion Signal Enable.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUF_RD_READY_SIGNAL_EN</name>
              <description>Buffer Read Ready Signal Enable.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUF_WR_READY_SIGNAL_EN</name>
              <description>Buffer Write Ready Signal Enable.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DMA_INTERRUPT_SIGNAL_EN</name>
              <description>DMA Interrupt Signal Enable.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BGAP_EVENT_SIGNAL_EN</name>
              <description>Block Gap Event Signal Enable.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>XFER_COMPLETE_SIGNAL_EN</name>
              <description>Transfer Complete Signal Enable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_COMPLETE_SIGNAL_EN</name>
              <description>Command Complete Signal Enable.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_ERROR_INT_SIGNAL_EN_R</name>
          <description>Error Interrupt Signal Enable Register</description>
          <addressOffset>0x3A</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>BOOT_ACK_ERR_SIGNAL_EN</name>
              <description>Boot Acknowledgment Error (eMMC mode only).
Setting this bit to 0x1 enables generating interrupt signal when Boot Acknowledgement Error in the SDMMC_ERROR_INT_STAT_R register is set.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESP_ERR_SIGNAL_EN</name>
              <description>Response Error Signal Enable (SD mode only).</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADMA_ERR_SIGNAL_EN</name>
              <description>ADMA Error Signal Enable.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AUTO_CMD_ERR_SIGNAL_EN</name>
              <description>Auto CMD Error Signal Enable (SD or eMMC mode only).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CUR_LMT_ERR_SIGNAL_EN</name>
              <description>Current Limit Error Signal Enable.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATA_END_BIT_ERR_SIGNAL_EN</name>
              <description>Data End Bit Error Signal Enable (SD or eMMC mode only).</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATA_CRC_ERR_SIGNAL_EN</name>
              <description>Data CRC Error Signal Enable (SD or eMMC mode only).</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATA_TOUT_ERR_SIGNAL_EN</name>
              <description>Data Timeout Error Signal Enable (SD or eMMC mode only).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_IDX_ERR_SIGNAL_EN</name>
              <description>Command Index Error Signal Enable (SD or eMMC mode only).</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_END_BIT_ERR_SIGNAL_EN</name>
              <description>Command End Bit Error Signal Enable (SD or eMMC mode only).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_CRC_ERR_SIGNAL_EN</name>
              <description>Command CRC Error Signal Enable (SD or eMMC mode only).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_TOUT_ERR_SIGNAL_EN</name>
              <description>Command Timeout Error Signal Enable (SD or eMMC mode only).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_AUTO_CMD_STAT_R</name>
          <description>Auto CMD Status Register</description>
          <addressOffset>0x3C</addressOffset>
          <size>16</size>
          <access>read-only</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CMD_NOT_ISSUED_AUTO_CMD12</name>
              <description>Command Not Issued By Auto CMD12 Error.
This bit is set to 0x0 when Auto CMD Error is generated by Auto CMD23.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Not issued</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AUTO_CMD_RESP_ERR</name>
              <description>Auto CMD Response Error.
This bit is set when the SDMMC_XFER_MODE_R[RESP_ERR_CHK_ENABLE] bit is set to 0x1 and an error is detected in R1 response of either Auto CMD12 or CMD13. This status is ignored if any bit between D00 to D04 is set to 0x1.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AUTO_CMD_IDX_ERR</name>
              <description>Auto CMD Index Error.
This bit is set if the command index error occurs in response to a command.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AUTO_CMD_EBIT_ERR</name>
              <description>Auto CMD End Bit Error.
This bit is set when detecting that the end bit of command response is 0x0.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>End bit error generated</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AUTO_CMD_CRC_ERR</name>
              <description>Auto CMD CRC Error.
This bit is set when detecting a CRC error in the command response.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No Error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CRC Error Generated</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AUTO_CMD_TOUT_ERR</name>
              <description>Auto CMD Timeout Error.
This bit is set if no response is returned with 64 SD_CLK cycles from the end bit of the command.
If this bit is set to 0x1, error status bits (D04 to D01) are meaningless.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Time out</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AUTO_CMD12_NOT_EXEC</name>
              <description>Auto CMD12 Not Executed.
If multiple memory block data transfer is not started due to a command error, this bit is not set because it is not necessary to issue an Auto CMD12. Setting this bit to 0x1 means that the host controller cannot issue Auto CMD12 to stop multiple memory block data transfer, due to some error. If this bit is set to 0x1, error status bits (D04 to D01) is meaningless.
This bit is set to 0x0 when Auto CMD Error is generated by Auto CMD23.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Executed</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Not executed</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_HOST_CTRL2_R</name>
          <description>Host Control 2 Register</description>
          <addressOffset>0x3E</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>PRESET_VAL_ENABLE</name>
              <description>Preset Value Enable.
This bit enables automatic selection of SD_CLK frequency and Driver strength in Preset Value registers. When this bit is set, SD_CLK frequency generation (SDMMC_CLK_CTRL_R[CLK_GEN_SELECT], the SDMMC_CLK_CTRL_R[FREQ_SEL]), and the driver strength selection are performed by the host controller. These values are selected from set of Preset Value registers based on selected speed mode.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SD_CLK and driver strength are controlled by the host driver</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Automatic selection by preset value are enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ASYNC_INT_ENABLE</name>
              <description>Asynchronous Interrupt Enable.
This bit can be set if a card supports asynchronous interrupts and this bit is set to 0x1 in the Capabilities registers (SDMMC_CAPABILITIES1_R and SDMMC_CAPABILITIES2_R).</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADDRESSING</name>
              <description>64-bit Addressing.
This bit is effective when the HOST_VER4_ENABLE bit is set to 0x1.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>32 bits addressing</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>64 bits addressing</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HOST_VER4_ENABLE</name>
              <description>Host Version 4 Enable.
This bit selects either Version 3.00 compatible mode or Version 4 mode.
Functions of following fields are modified for Host Version 4 mode:
- SDMA Address: SDMA uses the SDMMC_ADMA_SA_LOW_R register (0x58 - 0x5F) instead of the SDMMC_SDMASA_R register (0x0 - 0x3).
- ADMA2/ADMA3 selection: ADMA3 is selected by the SDMMC_HOST_CTRL1_R[DMA_SEL] bit field.
- 64-bit ADMA Descriptor Size: 128-bit descriptor is used instead of 96-bit descriptor when 64-bit Addressing is set to 0x1.
- Selection of 32-bit/64-bit System Addressing: Either 32-bit or 64-bit system addressing is selected by 64-bit Addressing bit in this register.
- 32-bit Block Count: The SDMMC_SDMASA_R register (0x0 - 0x3) is modified to 32-bit Block Count Register
Note: It is recommended not to program ADMA3 Integrated Descriptor Address registers, while operating in Host version less than 4 mode (HOST_VER4_ENABLE = 0x0).</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Version 3.00 compatible mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Version 4 mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD23_ENABLE</name>
              <description>CMD23 Enable.
If the card supports CMD23, this bit is set to 0x1. This bit is used to select Auto CMD23 or Auto CMD12 for ADMA3 data transfer.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Auto CMD23 is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Auto CMD23 is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADMA2_LEN_MODE</name>
              <description>ADMA2 Length Mode.
This bit selects ADMA2 Length mode to be either 16-bit or 26-bit.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>16-bit Data Length mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>26-bit Data Length mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DRV_STRENGTH_SEL</name>
              <description>Driver Strength Select.
This bit is used to select the host controller output driver in 1.8 V signaling UHS-I or eMMC speed modes. The bit depends on setting of the PRESET_VAL_ENABLE bit.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Driver TYPEB is selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Driver TYPEA is selected</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Driver TYPEC is selected</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Driver TYPED is selected</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SIGNALING_EN</name>
              <description>1.8 V Signaling Enable.
This bit controls voltage regulator for I/O cell in UHS-I or eMMC speed modes. Setting this bit from 0x0 to 0x1 starts changing the signal voltage from 3.3 V to 1.8 V. The host controller clears this bit if switching to 1.8 signaling fails.
Note: This bit must be set for all UHS-I speed modes (SDR12/SDR25/SDR50).</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>3.3 V signalling</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>1.8 V signalling</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UHS_MODE_SEL</name>
              <description>UHS Mode or eMMC Speed Mode Select.
These bits are used to select UHS mode in the SD mode of operation. In eMMC mode, these bits are used to select eMMC speed mode.
UHS mode (SD mode only):</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SDR12</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SDR25</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>SDR50</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_CAPABILITIES1_R</name>
          <description>Capabilities 1 Register (0 to 31)</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x276E648A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SLOT_TYPE_R</name>
              <description>Slot Type.
These bits indicate usage of a slot by a specific Host System.</description>
              <bitRange>[31:30]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Removable card slot</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ASYNC_INT_SUPPORT</name>
              <description>Asynchronous Interrupt Support (SD mode only).</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Asynchronous interrupt supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYS_ADDR_64_V3</name>
              <description>64-bit System Address Support for V3.
This bit sets the host controller to support 64-bit System Addressing of V3 mode.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>64-bit System address for V3 not supported</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYS_ADDR_64_V4</name>
              <description>64-bit System Address Support for V4.
This bit sets the host controller to support 64-bit System Addressing of V4 mode.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>64-bit System address for V4 not supported</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VOLT_18</name>
              <description>Voltage Support for 1.8 V.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>1.8 V supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VOLT_30</name>
              <description>Voltage Support for SD 3.0 V or Embedded 1.2 V.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SD 3.0 V or Embedded 1.2 V supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VOLT_33</name>
              <description>Voltage Support for 3.3 V.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>3.3 V supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUS_RES_SUPPORT</name>
              <description>Suspense/Resume Support.
This bit indicates whether the host controller supports Suspend/Resume functionality.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not supported</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SDMA_SUPPORT</name>
              <description>SDMA Support.
This bit indicates whether the host controller is capable of using SDMA to transfer data between the system memory and the host controller directly.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SDMA supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HIGH_SPEED_SUPPORT</name>
              <description>High Speed Support.
This bit indicates whether the host controller and the Host System supports High Speed mode and they can supply the SD Clock frequency from 25 MHz to 50 MHz.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>High speed supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADMA2_SUPPORT</name>
              <description>ADMA2 Support.
This bit indicates whether the host controller is capable of using ADMA2.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ADMA2 supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EMBEDDED_8_BIT</name>
              <description>8-bit Support for Embedded Device.
This bit indicates whether the host controller is capable of using an 8-bit bus width mode.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>8-bit bus width supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MAX_BLK_LEN</name>
              <description>Maximum Block Length.
This bit indicates the maximum block size that the host driver can read and write to the buffer in the host controller. The buffer transfers this block size without wait cycles. The transfer block length is always 512 Bytes for the SD Memory irrespective of this bit.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>2048 Bytes</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BASE_CLK_FREQ</name>
              <description>Base Clock Frequency for SD Clock.
These bits indicate the base (maximum) clock frequency for the SD Clock.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x64</name>
                  <description>100 MHz</description>
                  <value>0x64</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TOUT_CLK_UNIT</name>
              <description>Timeout Clock Unit.
This bit shows the unit of base clock frequency used to detect Data Timeout Error.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MHz</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TOUT_CLK_FREQ</name>
              <description>Timeout Clock Frequency.
This bit shows the base clock frequency used to detect Data Timeout Error. The Timeout Clock unit defines the unit of timeout clock frequency.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>10 MHz</description>
                  <value>0xA</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_CAPABILITIES2_R</name>
          <description>Capabilities 2 Register (32 to 63)</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x08000071</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VDD2_18V_SUPPORT</name>
              <description>1.8 V VDD2 Support.
This bit indicates support of VDD2 for the Host System.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1.8 V VDD2 not supported</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADMA3_SUPPORT</name>
              <description>ADMA3 Support.
This bit indicates whether the host controller is capable of using ADMA3.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ADMA3 supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_MUL</name>
              <description>Clock Multiplier.
These bits indicate the clock multiplier of the programmable clock generator.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock multiplier not supported</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DRV_TYPED</name>
              <description>Driver Type D Support (UHS-I Only).
This bit indicates support of Driver Type D for 1.8 V Signaling.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Driver Type D supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DRV_TYPEC</name>
              <description>Driver Type C Support (UHS-I Only).
This bit indicates support of Driver Type C for 1.8 V Signaling.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Driver Type C supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DRV_TYPEA</name>
              <description>Driver Type A Support (UHS-I Only).
This bit indicates support of Driver Type A for 1.8 V Signaling.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Driver Type A supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SDR50_SUPPORT</name>
              <description>SDR50 Support (UHS-I Only).
This bit indicates that SDR50 is supported.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SDR50 supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_CURR_CAPABILITIES1_R</name>
          <description>Maximum Current Capabilities 1 Register (0 to 31)</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MAX_CUR_18V</name>
              <description>Maximum Current for 1.8 V.
This bit specifies the card Maximum Current for 1.8 V VDD1 power supply.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Get information through another method</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MAX_CUR_30V</name>
              <description>Maximum Current for 3.0 V.
This bit specifies the card Maximum Current for 3.0 V VDD1 power supply.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Get information through another method</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MAX_CUR_33V</name>
              <description>Maximum Current for 3.3 V.
This bit specifies the card Maximum Current for 3.3 V VDD1 power supply.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Get information through another method</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_FORCE_AUTO_CMD_STAT_R</name>
          <description>Force Event Register for Auto CMD Error Status</description>
          <addressOffset>0x50</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>FORCE_CMD_NOT_ISSUED_AUTO_CMD12</name>
              <description>Force Event for Command Not Issued By Auto CMD12 Error.</description>
              <bitRange>[7:7]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Command Not Issued By Auto CMD12 Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_AUTO_CMD_RESP_ERR</name>
              <description>Force Event for Auto CMD Response Error.</description>
              <bitRange>[5:5]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Auto CMD Response Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_AUTO_CMD_IDX_ERR</name>
              <description>Force Event for Auto CMD Index Error.</description>
              <bitRange>[4:4]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Auto CMD Index Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_AUTO_CMD_EBIT_ERR</name>
              <description>Force Event for Auto CMD End Bit Error.</description>
              <bitRange>[3:3]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Auto CMD End Bit Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_AUTO_CMD_CRC_ERR</name>
              <description>Force Event for Auto CMD CRC Error.</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Auto CMD CRC Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_AUTO_CMD_TOUT_ERR</name>
              <description>Force Event for Auto CMD Timeout Error.</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Auto CMD Timeout Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_AUTO_CMD12_NOT_EXEC</name>
              <description>Force Event for Auto CMD12 Not Executed.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Auto CMD12 Not Executed Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_FORCE_ERROR_INT_STAT_R</name>
          <description>Force Event Register for Error Interrupt Status</description>
          <addressOffset>0x52</addressOffset>
          <size>16</size>
          <access>write-only</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>FORCE_BOOT_ACK_ERR</name>
              <description>Force Event for Boot ACK Error.</description>
              <bitRange>[12:12]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Boot ACK Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_RESP_ERR</name>
              <description>Force Event for Response Error (SD mode only).</description>
              <bitRange>[11:11]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Response Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_ADMA_ERR</name>
              <description>Force Event for ADMA Error.</description>
              <bitRange>[9:9]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ADMA Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_AUTO_CMD_ERR</name>
              <description>Force Event for Auto CMD Error (SD and eMMC modes).</description>
              <bitRange>[8:8]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Auto CMD Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_CUR_LMT_ERR</name>
              <description>Force Event for Current Limit Error.</description>
              <bitRange>[7:7]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Current Limit Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_DATA_END_BIT_ERR</name>
              <description>Force Event for Data End Bit Error (SD and eMMC modes).</description>
              <bitRange>[6:6]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Data End Bit Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_DATA_CRC_ERR</name>
              <description>Force Event for Data CRC Error (SD and eMMC modes).</description>
              <bitRange>[5:5]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Data CRC Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_DATA_TOUT_ERR</name>
              <description>Force Event for Data Timeout Error (SD and eMMC modes).</description>
              <bitRange>[4:4]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Data Timeout Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_CMD_IDX_ERR</name>
              <description>Force Event for Command Index Error (SD or eMMC modes).</description>
              <bitRange>[3:3]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Command Index Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_CMD_END_BIT_ERR</name>
              <description>Force Event for Command End Bit Error (SD and eMMC modes).</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Command End Bit Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_CMD_CRC_ERR</name>
              <description>Force Event for Command CRC Error (SD and eMMC modes).</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Command CRC Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_CMD_TOUT_ERR</name>
              <description>Force Event for Command Timeout Error (SD and eMMC modes).</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Command Timeout Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_ADMA_ERR_STAT_R</name>
          <description>ADMA Error Status Register</description>
          <addressOffset>0x54</addressOffset>
          <size>8</size>
          <access>read-only</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ADMA_LEN_ERR</name>
              <description>ADMA Length Mismatch Error States.
This error occurs in the following events:
- While the SDMMC_XFER_MODE_R[BLOCK_COUNT_ENABLE] bit is being set, the total data length specified by the Descriptor table is different from that specified by the Block Count and Block Length.
- When the total data length cannot be divided by the block length.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADMA_ERR_STATES</name>
              <description>ADMA Error States.
These bits indicate the state of ADMA when an error occurs during ADMA data transfer.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Stop DMA (SYS_ADR register points to a location next to the error descriptor)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Fetch Descriptor (SYS_ADR register points to the error descriptor)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Never set this state</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Transfer Data (SYS_ADR register points to a location next to the error descriptor)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_ADMA_SA_LOW_R</name>
          <description>ADMA System Address Register (Low)</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADMA_SA_LOW</name>
              <description>ADMA System Address.
These bits indicate the lower 32 bits of the ADMA system address.
SDMA: If the SDMMC_HOST_CTRL2_R[HOST_VER4_ENABLE] bit is set to 0x1, this register stores the system address of the data location.
ADMA2: This register stores the byte address of the executing command of the descriptor table.
ADMA3: This register is set by ADMA3. ADMA2 increments the address of this register that points to the next line, every time a Descriptor line is fetched.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_PRESET_INIT_R</name>
          <description>Register with Preset Value for Initialization</description>
          <addressOffset>0x60</addressOffset>
          <size>16</size>
          <access>read-only</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DRV_SEL_VAL</name>
              <description>Driver Strength Select Value.
These bits indicate that the Driver strength is supported by 1.8 V signaling bus speed modes. These bits are meaningless for 3.3 V signaling.</description>
              <bitRange>[15:14]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Driver Type B is selected</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_GEN_SEL_VAL</name>
              <description>Clock Generator Select Value.
This bit is effective when the host controller supports a programmable clock generator.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Host controller version 2.0 compatible clock generator</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FREQ_SEL_VAL</name>
              <description>SD_CLK Frequency Select Value.
10-bit preset value to be set in the SDMMC_CLK_CTRL_R[FREQ_SEL] bit field described by a Host System.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_PRESET_DS_R</name>
          <description>Register with Preset Value for Default Speed</description>
          <addressOffset>0x62</addressOffset>
          <size>16</size>
          <access>read-only</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DRV_SEL_VAL</name>
              <description>Driver Strength Select Value.
These bits indicate the Driver strength value supported by 1.8 V signaling bus speed modes. This field is meaningless for the Default speed mode as it uses 3.3 V signaling.</description>
              <bitRange>[15:14]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Driver Type B is selected</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_GEN_SEL_VAL</name>
              <description>Clock Generator Select Value.
This bit is effective when the host controller supports programmable clock generator.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Host controller version 2.0 compatible clock generator</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FREQ_SEL_VAL</name>
              <description>SD_CLK Frequency Select Value.
10-bit preset value to be set in the SDMMC_CLK_CTRL_R[FREQ_SEL] bit field described by a Host System.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_PRESET_HS_R</name>
          <description>Register with Preset Value for High Speed</description>
          <addressOffset>0x64</addressOffset>
          <size>16</size>
          <access>read-only</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DRV_SEL_VAL</name>
              <description>Driver Strength Select Value.
These bits indicate the Driver strength value supported by 1.8 V signaling bus speed modes. This field is meaningless for High speed mode as it uses 3.3 V signaling.</description>
              <bitRange>[15:14]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Driver Type B is selected</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_GEN_SEL_VAL</name>
              <description>Clock Generator Select Value.
This bit is effective when the host controller supports programmable clock generator.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Host controller version 2.0 compatible clock generator</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FREQ_SEL_VAL</name>
              <description>SD_CLK Frequency Select Value.
10-bit preset value to be set in the SDMMC_CLK_CTRL_R[FREQ_SEL] bit field described by a Host System.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_PRESET_SDR12_R</name>
          <description>Register with Preset Value for SDR12</description>
          <addressOffset>0x66</addressOffset>
          <size>16</size>
          <access>read-only</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DRV_SEL_VAL</name>
              <description>Driver Strength Select Value.
These bits indicate the Driver strength value supported for the SDR12 bus speed mode. These bits are meaningless for 3.3 V signaling.</description>
              <bitRange>[15:14]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Driver Type B is selected</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_GEN_SEL_VAL</name>
              <description>Clock Generator Select Value.
This bit is effective when the host controller supports programmable clock generator.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Host controller version 2.0 compatible clock generator</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FREQ_SEL_VAL</name>
              <description>SD_CLK Frequency Select Value.
10-bit preset value to be set in the SDMMC_CLK_CTRL_R[FREQ_SEL] bit field described by a Host System.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_PRESET_SDR25_R</name>
          <description>Register with Preset Value for SDR25</description>
          <addressOffset>0x68</addressOffset>
          <size>16</size>
          <access>read-only</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DRV_SEL_VAL</name>
              <description>Driver Strength Select Value.
These bits indicate the Driver strength value supported for the SDR25 bus speed mode. These bits are meaningless for 3.3 V signaling.</description>
              <bitRange>[15:14]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Driver Type B is selected</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_GEN_SEL_VAL</name>
              <description>Clock Generator Select Value.
This bit is effective when the host controller supports programmable clock generator.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Host controller version 2.0 compatible clock generator</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FREQ_SEL_VAL</name>
              <description>SD_CLK Frequency Select Value.
10-bit preset value to be set in the SDMMC_CLK_CTRL_R[FREQ_SEL] bit field described by a Host System.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_PRESET_SDR50_R</name>
          <description>Register with Preset Value for SDR50</description>
          <addressOffset>0x6A</addressOffset>
          <size>16</size>
          <access>read-only</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DRV_SEL_VAL</name>
              <description>Driver Strength Select Value.
These bits indicate Driver strength value supported for SDR50 bus speed mode. These bits are meaningless for 3.3 V signaling.</description>
              <bitRange>[15:14]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Driver Type B is selected</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_GEN_SEL_VAL</name>
              <description>Clock Generator Select Value.
This bit is effective when the host controller supports programmable clock generator.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Host controller version 2.0 compatible clock generator</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FREQ_SEL_VAL</name>
              <description>SD_CLK Frequency Select Value.
10-bit preset value to be set in the SDMMC_CLK_CTRL_R[FREQ_SEL] bit field described by a Host System.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_ADMA_ID_LOW_R</name>
          <description>ADMA3 Integrated Descriptor Address Register (Low)</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADMA_ID_LOW</name>
              <description>ADMA Integrated Descriptor Address.
These bits indicate the lower 32-bit of the ADMA Integrated Descriptor Address. The start address of Integrated Descriptor is set to these register bits. The ADMA3 fetches one Integrated Descriptor Address and increments these bits to indicate the next Integrated Descriptor Address.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_P_VENDOR_SPECIFIC_AREA</name>
          <description>Pointer for Vendor Specific Area 1</description>
          <addressOffset>0xE8</addressOffset>
          <size>16</size>
          <access>read-only</access>
          <resetValue>0x0500</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>REG_OFFSET_ADDR</name>
              <description>Base offset Address for Vendor Specific registers.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_SLOT_INTR_STATUS_R</name>
          <description>Slot Interrupt Status Register</description>
          <addressOffset>0xFC</addressOffset>
          <size>16</size>
          <access>read-only</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>INTR_SLOT</name>
              <description>Interrupt Signal for each Slot.
These status bits indicate the logical OR of interrupt signal and wakeup signal for each slot. A maximum of 8 slots can be defined. If one interrupt signal is associated with multiple slots, the host driver can identify the interrupt that is generated by reading these bits. By a power on reset or by setting the SDMMC_SW_RST_R[SW_RST_ALL] bit, the interrupt signals are de-asserted and this status reads 0x0.
Bit 00: Slot 1
Bit 01: Slot 2
Bit 02: Slot 3
Bit 07: Slot 8</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_HOST_CNTRL_VERS_R</name>
          <description>Host Controller Version Register</description>
          <addressOffset>0xFE</addressOffset>
          <size>16</size>
          <access>read-only</access>
          <resetValue>0x0005</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>VENDOR_VERSION_NUM</name>
              <description>Vendor version number</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPEC_VERSION_NUM</name>
              <description>Host controller specification version number</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_MSHC_VER_ID_R</name>
          <description>MSHC Version ID Register</description>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>MSHC_VER_ID</name>
              <description>Current release number</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_MSHC_VER_TYPE_R</name>
          <description>MSHC Version Type Register</description>
          <addressOffset>0x504</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x67612A2A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MSHC_VER_TYPE</name>
              <description>Current release type</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_MSHC_CTRL_R</name>
          <description>SDMMC Host Controller Control Register</description>
          <addressOffset>0x508</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x01</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>NEDGE_SMPL_EN</name>
              <description>Samples CMD/DATA with respect to negative edge of CCLK_RX for Low-Speed SDR only support.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Samples CMD/DATA with respect to positive edge of CCLK_RX</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Samples CMD/DATA with respect to negative edge of CCLK_RX</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PEDGE_DRV_EN</name>
              <description>Launches CMD/DATA with respect to positive edge of CCLK_TX for Low-Speed SDR only support.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Launches CMD/DATA with respect to negative edge of CCLK_TX</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Launches CMD/DATA with respect to positive edge of CCLK_TX</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_CG_DIS</name>
              <description>Internal Clock Gating Disable Control.
This bit must be used to disable the SDMMC module internal clock gating when required (disabled clocks are not gated). The clocks to the core (except HCLK) must be stopped when programming this bit.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Internal clock gates are active and clock gating is controlled internally</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Internal clock gating is disabled, clocks are not gated internally</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_CONFLICT_CHECK</name>
              <description>Command Conflict Check.
This bit enables command conflict check.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable command conflict check</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Check for command conflict after 1 card clock cycle</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_MBIU_CTRL_R</name>
          <description>Master Bus Interface Unit Control Register</description>
          <addressOffset>0x510</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x0F</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>BURST_INCR16_EN</name>
              <description>INCR16 Burst.
Controls generation of INCR16 transfers on Master interface.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>AHB INCR16 burst type is not generated on Master interface</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>AHB INCR16 burst type can be generated on Master interface</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BURST_INCR8_EN</name>
              <description>INCR8 Burst.
Controls generation of INCR8 transfers on Master interface.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>AHB INCR8 burst type is not generated on Master interface</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>AHB INCR8 burst type can be generated on Master interface</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BURST_INCR4_EN</name>
              <description>INCR4 Burst.
Controls generation of INCR4 transfers on Master interface.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>AHB INCR4 burst type is not generated on Master interface</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>AHB INCR4 burst type can be generated on Master interface</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UNDEFL_INCR_EN</name>
              <description>Undefined INCR Burst.
Controls generation of undefined length INCR transfer on Master interface.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Undefined INCR type burst is the least preferred burst on AHB Master interface</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Undefined INCR type burst is the most preferred burst on AHB Master interface</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_EMMC_CTRL_R</name>
          <description>eMMC Control Register</description>
          <addressOffset>0x52C</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x000C</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>EMMC_RST_N_OE</name>
              <description>Output Enable Control for eMMC Device Reset Signal PAD Control.
This field drives SD_RST output of the SDMMC module.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SD_RST is 0x0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SD_RST is 0x1</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EMMC_RST_N</name>
              <description>eMMC Device Reset Signal Control.
This register field controls SD_RST output of the SDMMC module.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Reset to eMMC device asserted (active low)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Reset to eMMC device is de-asserted</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DISABLE_DATA_CRC_CHK</name>
              <description>Disable Data CRC Check.
This bit controls masking of CRC16 error for Card Write in eMMC mode. This is useful in bus testing (CMD19) for an eMMC device. In bus testing, an eMMC card does not send CRC status for a block, which may generate CRC error. This CRC error can be masked using this bit during bus testing.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DATA CRC check is enabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DATA CRC check is disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_IS_EMMC</name>
              <description>eMMC Card Present.
This bit indicates the type of card connected. An application program this bit based on the card connected to the SDMMC host controller.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Card connected to the SDMMC host controller is a non-eMMC card</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Card connected to the SDMMC host controller is an eMMC card</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_BOOT_CTRL_R</name>
          <description>eMMC Boot Control Register</description>
          <addressOffset>0x52E</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>BOOT_TOUT_CNT</name>
              <description>Boot ACK Timeout Counter Value.
This value determines the interval by which boot ACK timeout (50 ms) is detected when boot ACK is expected during boot operation.</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>TMCLK x 2^13</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>TMCLK x 2^14</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xE</name>
                  <description>TMCLK x 2^27</description>
                  <value>0xE</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BOOT_ACK_ENABLE</name>
              <description>Boot Acknowledge Enable.
When this bit set, the SDMMC module checks for boot acknowledge start pattern of 0-1-0 during boot operation. This bit is applicable for both mandatory and alternate boot mode.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Boot ACK disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Boot ACK enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VALIDATE_BOOT</name>
              <description>Validate Mandatory Boot Enable Bit.
This bit is used to validate the SDMMC_BOOT_CTRL_R[MAN_BOOT_EN] bit.</description>
              <bitRange>[7:7]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Ignore mandatory boot enable bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Validate mandatory boot enable bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MAN_BOOT_EN</name>
              <description>Mandatory Boot Enable.
This bit is used to initiate the mandatory boot operation. The application sets this bit along with the SDMMC_BOOT_CTRL_R[VALIDATE_BOOT] bit. Writing 0x0 is ignored. The SDMMC module clears this bit after the boot transfer is completed or terminated.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Mandatory boot disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Mandatory boot enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_EMBEDDED_CTRL_R</name>
          <description>Embedded Control Register</description>
          <addressOffset>0xF6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BACK_END_PWR_CTRL</name>
              <description>Back-End Power Control (SD Mode).
Each bit of this bit field controls back-end power supply for an embedded device.
Bit 24: Back-End Power for Device 1
Bit 25: Back-End Power for Device 2
Bit 26: Back-End Power for Device 3
Bit 27: Back-End Power for Device 4
Bit 28: Back-End Power for Device 5
Bit 29: Back-End Power for Device 6
Bit 30: Back-End Power for Device 7
Function of each bit is defined as follows:</description>
              <bitRange>[30:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Back-End Power is off</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Back-End Power is supplied</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INT_PIN_SEL</name>
              <description>Interrupt Pin Select.
These bits enable the interrupt pin inputs.</description>
              <bitRange>[22:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b000</name>
                  <description>Interrupts (INT_A, INT_B, INT_C) are disabled</description>
                  <value>0b000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b001</name>
                  <description>INT_A is enabled</description>
                  <value>0b001</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b010</name>
                  <description>INT_B is enabled</description>
                  <value>0b010</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b100</name>
                  <description>INT_C is enabled</description>
                  <value>0b100</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_PIN_SEL</name>
              <description>Clock Pin Select (SD Mode).
This bit is selected by one of clock pin outputs.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock pins are disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CLK[1] is selected</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>CLK[2] is selected</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>CLK[7] is selected</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUS_WIDTH_PRESET</name>
              <description>Bus Width Preset (SD Mode).
Each bit of this field specifies the bus width for each embedded device. The shared bus supports mixing of 4-bit and 8-bit bus width devices.
Bit 8: Bus Width Preset for Device 1
Bit 9: Bus Width Preset for Device 2
Bit 10: Bus Width Preset for Device 3
Bit 11: Bus Width Preset for Device 4
Bit 12: Bus Width Preset for Device 5
Bit 13: Bus Width Preset for Device 6
Bit 14: Bus Width Preset for Device 7
Function of each bit is defined as follows:</description>
              <bitRange>[14:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>4-bit bus width mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>8-bit bus width mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NUM_INT_PIN</name>
              <description>Number of Interrupt Input Pins.
This field indicates support of interrupt input pins for an embedded system.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NUM_CLK_PIN</name>
              <description>Number of Clock Pins (SD Mode).
This field indicates support of clock pins to select one of devices for shared bus system. Up to 7 clock pins can be supported.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Shared bus not supported</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>1 SD_CLK supported</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>2 SD_CLK supported</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>7 SD_CLK supported</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPI0</name>
      <groupName>SPI</groupName>
      <baseAddress>0x48103000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>244</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>SPI_CTRLR0</name>
          <description>Control Register 0</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80004007</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPI_IS_MST</name>
              <description>This bit selects if the SPI is working in Master or Slave mode.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SPI is Slave</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SPI is Master</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CFS</name>
              <description>Control Frame Size.
Selects the length of the control word for the Microwire frame format.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>01-bit Control Word</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>02-bit Control Word</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>03-bit Control Word</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>04-bit Control Word</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>05-bit Control Word</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>06-bit Control Word</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>07-bit Control Word</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>08-bit Control Word</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>09-bit Control Word</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>10-bit Control Word</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>11-bit Control Word</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>12-bit Control Word</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>13-bit Control Word</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xD</name>
                  <description>14-bit Control Word</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xE</name>
                  <description>15-bit Control Word</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description>16-bit Control Word</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSTE</name>
              <description>Slave Select Toggle Enable.
While operating in SPI mode with clock phase (SCPH) set to 0x0, this bit controls the behavior of the slave select line between data frames.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The slave select line will stay low and SPI_SCLK will run continuously for the duration of the transfer</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The slave select line will toggle between consecutive data frames, with the serial clock (SPI_SCLK) being held to its default value while the slave select line is high</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRL</name>
              <description>Shift Register Loop.
Used for testing purposes only. When internally active, connects the transmit shift register output to the receive shift register input. Can be used in both serial slave and serial Master mode.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Normal Mode Operation</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Test Mode Operation</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLV_OE</name>
              <description>Slave Output Enable.
Relevant only when the SPI is programmed as a serial slave device. When programmed as a serial master, this bit has no functionality. This bit enables or disables the setting of the output enable signal from the SPI serial slave. When the SLV_OE = 0x1, the output enable signal can never be active. When the output enable signal controls the tri-state buffer on the TXD output from the slave, a high impedance state is always present on the slave TXD output when the SLV_OE bit is set to 0x1.
This is useful when the master transmits in broadcast mode (master transmits data to all slave devices). Only one slave may respond with data on the master RXD line. This bit is enabled after reset and must be disabled by software (when broadcast mode is used), if the device has no need to respond with data.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slave output is enabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slave output is disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TMOD</name>
              <description>Transfer Mode.
Selects the mode of transfer for serial communication. This field does not affect the transfer duplicity. Only indicates whether the receive or transmit data are valid.
In Transmit Only mode, data received from the external device is not valid and is not stored in the receive FIFO memory; it is overwritten on the next transfer.
In Receive Only mode, transmitted data are not valid. After the first write to the transmit FIFO, the same word is retransmitted for the duration of the transfer.
In Transmit and Receive mode, both transmit and receive data are valid. The transfer continues until the transmit FIFO is empty. Data received from the external device are stored into the receive FIFO memory, where it can be accessed by the host processor.</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit and Receive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit Only mode</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Receive Only mode</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>EEPROM Read mode</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SCPOL</name>
              <description>Serial Clock Polarity.
Valid when the Frame Format (FRF) bit is set to Motorola SPI. Used to select the polarity of the inactive serial clock, which is held inactive when the SPI master is not actively transferring data on the serial bus.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Inactive state of serial clock is low</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Inactive state of serial clock is high</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SCPH</name>
              <description>Serial Clock Phase.
Valid when the FRF bit is set to Motorola SPI. The serial clock phase selects the relationship of the serial clock with the slave select signal.
When SCPH = 0, data are captured on the first edge of the serial clock. When SCPH = 1, the serial clock starts toggling one cycle after the slave select line is activated, and data are captured on the second edge of the serial clock.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Serial clock toggles in middle of first bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Serial clock toggles at start of first bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FRF</name>
              <description>Frame Format.
Selects which serial protocol transfers the data.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Motorola SPI frame format</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Texas Instruments SSP frame format</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>National Semiconductors Microwire frame format</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFS</name>
              <description>Data Frame Size.
Selects the data frame length. When the data frame size is programmed to be less than 32 bits, the receive data is automatically right-justified by the receive logic, with the upper bits of the receive FIFO zero-padded.
User must right-justify transmit data before writing into the transmit FIFO. The transmit logic ignores the upper unused bits when transmitting the data.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>04-bit serial data transfer</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>05-bit serial data transfer</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>06-bit serial data transfer</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>07-bit serial data transfer</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>08-bit serial data transfer</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>09-bit serial data transfer</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>10-bit serial data transfer</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>11-bit serial data transfer</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>12-bit serial data transfer</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>13-bit serial data transfer</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xD</name>
                  <description>14-bit serial data transfer</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xE</name>
                  <description>15-bit serial data transfer</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description>16-bit serial data transfer</description>
                  <value>0xF</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x10</name>
                  <description>17-bit serial data transfer</description>
                  <value>0x10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x11</name>
                  <description>18-bit serial data transfer</description>
                  <value>0x11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x12</name>
                  <description>19-bit serial data transfer</description>
                  <value>0x12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x13</name>
                  <description>20-bit serial data transfer</description>
                  <value>0x13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x14</name>
                  <description>21-bit serial data transfer</description>
                  <value>0x14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x15</name>
                  <description>22-bit serial data transfer</description>
                  <value>0x15</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x16</name>
                  <description>23-bit serial data transfer</description>
                  <value>0x16</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x17</name>
                  <description>24-bit serial data transfer</description>
                  <value>0x17</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x18</name>
                  <description>25-bit serial data transfer</description>
                  <value>0x18</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x19</name>
                  <description>26-bit serial data transfer</description>
                  <value>0x19</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1A</name>
                  <description>27-bit serial data transfer</description>
                  <value>0x1A</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1B</name>
                  <description>28-bit serial data transfer</description>
                  <value>0x1B</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1C</name>
                  <description>29-bit serial data transfer</description>
                  <value>0x1C</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1D</name>
                  <description>30-bit serial data transfer</description>
                  <value>0x1D</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1E</name>
                  <description>31-bit serial data transfer</description>
                  <value>0x1E</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1F</name>
                  <description>32-bit serial data transfer</description>
                  <value>0x1F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_CTRLR1</name>
          <description>Control Register 1</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NDF</name>
              <description>Number of Data Frames.
When the SPI_CTRLR0[TMOD] = 0x2 or SPI_CTRLR0[TMOD] = 0x3, this bit field sets the number of data frames to be continuously received by the SPI. The SPI continues to receive serial data until the number of data frames received is equal to this register value plus 1, which enables the user to receive up to 64KB of data in a continuous transfer. When the SPI is programmed as a serial slave, the transfer continues for as long as the slave is selected. Therefore, this bit field serves no purpose and is not present when the SPI is programmed as a serial slave.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_ENR</name>
          <description>SPI Enable Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPI_EN</name>
              <description>SPI Enable.
Enables and disables all SPI operations. When disabled, all serial transfers are halted immediately. Transmit and receive FIFO buffers are cleared when the device is disabled. It is impossible to program some of the SPI control registers when enabled. When disabled, the SPI sleep output is set (after delay) to inform the system that it is safe to remove the SPI_CLK, thus saving power consumption in the system.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disables SPI</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables SPI</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_MWCR</name>
          <description>Microwire Control Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MHS</name>
              <description>Microwire Handshaking.
Relevant only when the SPI is programmed as a serial master device. When programmed as a serial slave, this bit has no functionality. Used to enable and disable the busy/ready handshaking interface for the Microwire protocol. When enabled, the SPI checks for a READY status from the target slave, after the transfer of the last data/control bit, before clearing the BUSY status in the SPI_SR[BUSY] bit.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Handshaking interface is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Handshaking interface is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MDD</name>
              <description>Microwire Control.
Defines the direction of the data word when the Microwire serial protocol is used. When this bit is set to 0, the data word is received by the SPI module from the external serial device. When this bit is set to 1, the data word is transmitted from the SPI module to the external serial device.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SPI receives data</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SPI transmits data</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MWMOD</name>
              <description>Microwire Transfer Mode.
Defines whether the Microwire transfer is sequential or non-sequential. When sequential mode is used, only one control word is needed to transmit or receive a block of data words. When non-sequential mode is used, there must be a control word for each data word that is transmitted or received.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Non-Sequential Transfer</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Sequential Transfer</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_SER</name>
          <description>Slave Enable Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SER</name>
              <description>Slave Select Enable Flag.
Each bit in this bit field corresponds to a slave select line from the SPI master. When a bit in this bit field is set to 0x1, the corresponding slave select line from the master is activated when a serial transfer begins. It should be noted that setting or clearing bits in this bit field have no effect on the corresponding slave select outputs until a transfer is started. Before beginning a transfer, user should enable the bit in this field that corresponds to the slave device with which the master wants to communicate. When not operating in broadcast mode, only one bit in this field should be set.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not Selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Selected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_BAUDR</name>
          <description>Baud Rate Select Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF0001</resetMask>
          <fields>
            <field>
              <name>SCKDV</name>
              <description>SPI Clock Divider.
This field contains the MSB 15 bits of the 16-bit SPI_CLK divider value. The LSB for SPI_CLK divider is always set to 0 and is unaffected by a write operation, which ensures the divider is always set to an even value. If this field is set to all 0s, the serial output clock (SPI_SCLK) is disabled. The frequency of the SPI_SCLK is derived from the following equation:
 FSPI_SCLK = FSPI_CLK/SCKDV
Where SCKDV is any even value between 2 and 65534.
 For example, for FSPI_CLK = 3.6864 MHz and SCKDV = 1b'1:
BAUDR = 2 and FSPI_SCLK= 3.6864/2 = 1.8432 MHz.
For more information, see Section SPI Clock Ratios.</description>
              <bitRange>[15:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_TXFTLR</name>
          <description>Transmit FIFO Threshold Level Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXFTHR</name>
              <description>Transfer Start FIFO Level.
Used to control the level of entries in transmit FIFO above which transfer will start on serial line. This bit field is used to ensure that sufficient data is present in transmit FIFO before starting a write operation on serial line. These field is valid only for Master mode of operation.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TFT</name>
              <description>Transmit FIFO Threshold.
Controls the level of entries (or below) at which the transmit FIFO controller triggers an interrupt. The FIFO depth is 16. If the value in this bit field is set greater than or equal to the depth of the FIFO, this bit field is not written and retains its current value. When the number of transmit FIFO entries is less than or equal to this value, the transmit FIFO empty interrupt is triggered.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_RXFTLR</name>
          <description>Receive FIFO Threshold Level Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFT</name>
              <description>Receive FIFO Threshold.
Controls the level of entries (or above) at which the receive FIFO controller triggers an interrupt. The FIFO depth is 16. If the value in this bit field is set greater than the depth of the FIFO, this bit field is not written and retains its current value. When the number of receive FIFO entries is greater than or equal to this value + 1, the receive FIFO full interrupt is triggered.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_TXFLR</name>
          <description>Transmit FIFO Level Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXTFL</name>
              <description>Transmit FIFO Level.
Contains the number of valid data entries in the transmit FIFO.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_RXFLR</name>
          <description>Receive FIFO Level Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXTFL</name>
              <description>Receive FIFO Level.
Contains the number of valid data entries in the receive FIFO.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_SR</name>
          <description>Status Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000006</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DCOL</name>
              <description>Data Collision Error.
Relevant only when the SPI is programmed as a master device. This bit is set if slave select input is asserted by other master, when the SPI master is in the middle of the transfer. This informs the processor that the last data transfer was halted before completion. This bit is cleared when read.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No Error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit Data Collision Error</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXE</name>
              <description>Transmission Error.
Set if the transmit FIFO is empty when a transfer is started. This bit can be set only when the SPI is programmed as a slave device.
Data from the previous transmission is present on the TXD line. This bit is cleared when read.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No Error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmission Error</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFF</name>
              <description>Receive FIFO Full.
When the receive FIFO is completely full, this bit is set. When the receive FIFO contains one or more empty location, this bit is cleared.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO is not full</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO is full</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFNE</name>
              <description>Receive FIFO Not Empty.
Set when the receive FIFO contains one or more entries and is cleared when the receive FIFO is empty. This bit can be polled by software to completely empty the receive FIFO.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO is empty</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO is not empty</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TFE</name>
              <description>Transmit FIFO Empty.
When the transmit FIFO is completely empty, this bit is set. When the transmit FIFO contains one or more valid entries, this bit is cleared. This bit field does not request an interrupt.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO is not empty</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO is empty</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TFNF</name>
              <description>Transmit FIFO Not Full.
Set when the transmit FIFO contains one or more empty locations, and is cleared when the FIFO is full.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO is full</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO is not full</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUSY</name>
              <description>SPI Busy Flag.
When set, indicates that a serial transfer is in progress; when cleared indicates that the SPI is idle or disabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SPI is idle or disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SPI is actively transferring data</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_IMR</name>
          <description>Interrupt Mask Register</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000003F</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MSTIM</name>
              <description>Multi-Master Contention Interrupt Mask.
This bit is not present if the SPI is programmed as a serial master device.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Multi-Master Contention interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Multi-Master Contention interrupt is not masked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFIM</name>
              <description>Receive FIFO Full Interrupt Mask.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Full interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Full interrupt is not masked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXOIM</name>
              <description>Receive FIFO Overflow Interrupt Mask.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Overflow interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Overflow interrupt is not masked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXUIM</name>
              <description>Receive FIFO Underflow Interrupt Mask.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Underflow interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Underflow interrupt is not masked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXOIM</name>
              <description>Transmit FIFO Overflow Interrupt Mask.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Overflow interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Overflow interrupt is not masked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXEIM</name>
              <description>Transmit FIFO Empty Interrupt Mask.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Empty interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Empty interrupt is not masked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_ISR</name>
          <description>Interrupt Status Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MSTIS</name>
              <description>Multi-Master Contention Interrupt Status.
This bit is not present if the SPI is programmed as a serial slave device.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Multi-Master Contention interrupt is not active after masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Multi-Master Contention interrupt is active after masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFIS</name>
              <description>Receive FIFO Full Interrupt Status.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Full interrupt is not active after masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Full interrupt is active after masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXOIS</name>
              <description>Receive FIFO Overflow Interrupt Status.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Overflow interrupt is not active after masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Overflow interrupt is active after masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXUIS</name>
              <description>Receive FIFO Underflow Interrupt Status.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Underflow interrupt is not active after masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Underflow interrupt is active after masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXOIS</name>
              <description>Transmit FIFO Overflow Interrupt Status.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Overflow interrupt is not active after masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Overflow interrupt is active after masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXEIS</name>
              <description>Transmit FIFO Empty Interrupt Status.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Empty interrupt is not active after masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Empty interrupt is active after masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_RISR</name>
          <description>Raw Interrupt Status Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MSTIR</name>
              <description>Multi-Master Contention Raw Interrupt Status.
 This bit field is not present if the SPI is programmed as a serial slave device.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Multi-Master Contention interrupt is not active prior masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Multi-Master Contention interrupt is active prior to masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFIR</name>
              <description>Receive FIFO Full Raw Interrupt Status.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Full interrupt is not active prior masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Full interrupt is active prior to masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXOIR</name>
              <description>Receive FIFO Overflow Raw Interrupt Status.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Overflow interrupt is not active prior masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Overflow interrupt is active prior to masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXUIR</name>
              <description>Receive FIFO Underflow Raw Interrupt Status.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Underflow interrupt is not active prior masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Underflow interrupt is active prior to masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXOIR</name>
              <description>Transmit FIFO Overflow Raw Interrupt Status.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Overflow interrupt is not active prior masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Overflow interrupt is active prior to masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXEIR</name>
              <description>Transmit FIFO Empty Raw Interrupt Status.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Empty interrupt is not active prior masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Empty interrupt is active prior to masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_TXEICR</name>
          <description>Transmit FIFO Overflow Interrupt Clear Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXOICR</name>
              <description>Clear Transmit FIFO Overflow Interrupt.
This bit reflects the status of the interrupt. A read from this bit clears the Transmit FIFO Overflow interrupt; writing has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_RXOICR</name>
          <description>Receive FIFO Overflow Interrupt Clear Register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXOICR</name>
              <description>Clear Receive FIFO Overflow Interrupt.
This bit reflects the status of the interrupt. A read from this bit clears the Receive FIFO Overflow interrupt; writing has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_RXUICR</name>
          <description>Receive FIFO Underflow Interrupt Clear Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXUICR</name>
              <description>Clear Receive FIFO Underflow Interrupt.
This bit reflects the status of the interrupt. A read from this bit clears the Receive FIFO Underflow interrupt; writing has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_MSTICR</name>
          <description>Multi-Master Interrupt Clear Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MSTICR</name>
              <description>Clear Multi-Master Contention Interrupt.
This bit reflects the status of the interrupt. A read from this bit clears the Multi-Master Contention interrupt; writing has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_ICR</name>
          <description>Interrupt Clear Register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ICR</name>
              <description>Clear Interrupts.
This bit is set if any of the interrupts below are active. A read clears the Transmit FIFO Overflow, Receive FIFO Underflow, Receive FIFO Overflow, and Multi-Master Contention interrupts. Writing to this bit has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_DMACR</name>
          <description>DMA Control Register</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDMAE</name>
              <description>Transmit DMA Enable. This bit enables/disables the transmit FIFO DMA channel.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit DMA disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit DMA enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RDMAE</name>
              <description>Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive DMA disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive DMA enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_DMATDLR</name>
          <description>DMA Transmit Data Level Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMATDL</name>
              <description>Transmit Data Level.
This bit field controls the level at which a DMA request is made by the transmit logic. It is equal to the watermark level; that is, the transmit DMA request signal is generated when the number of valid data entries in the transmit FIFO is equal to or below this bit field value, and the SPI_DMACR[TDMAE] = 0x1.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_DMARDLR</name>
          <description>DMA Receive Data Level Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMARDL</name>
              <description>Receive Data Level. This bit field controls the level at which a DMA request is made by the receive logic. The watermark level is equal to DMARDL + 1; that is, receive DMA request is generated when the number of valid data entries in the receive FIFO is equal to or above this bit field value + 1, and SPI_DMACR[RDMAE] = 0x1.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_IDR</name>
          <description>Identification Register</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xC7C5C3C1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IDCODE</name>
              <description>Identification code</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_VERSION_ID</name>
          <description>Version ID Register</description>
          <addressOffset>0x5C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x3130322A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPI_COMP_VERSION</name>
              <description>Component version</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>36</dim>
          <dimIncrement>4</dimIncrement>
          <name>SPI_DR[%s]</name>
          <description>SPI Data Register (n)</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DR</name>
              <description>Data Register (n).
When writing to this register, the user must right-justify the data. Read data are automatically right-justified.
Read = Receive FIFO buffer
Write = Transmit FIFO buffer</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_RX_SAMPLE_DELAY</name>
          <description>Rx Sample Delay Register</description>
          <addressOffset>0xF0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SE</name>
              <description>Receive Data Sampling Edge.
 SPI_CLK positive edge is used for sampling.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RSD</name>
              <description>Receive Data Sample Delay.
 This bit field is used to delay the sample of the RXD input port. Each value represents a single SPI_CLK delay on the sample of RXD.
Note: If this bit field is programmed with a value that exceeds the depth of the internal shift registers (internal shift register depth = 4) zero delay will be applied to the RXD sample.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="SPI0">
      <name>SPI1</name>
      <baseAddress>0x48104000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SPI0">
      <name>SPI2</name>
      <baseAddress>0x48105000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SPI0">
      <name>SPI3</name>
      <baseAddress>0x48106000</baseAddress>
    </peripheral>
    <peripheral>
      <name>CRC0</name>
      <groupName>CRC</groupName>
      <baseAddress>0x48107000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>256</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CRC_CONTROL</name>
          <description>CRC Calculation Setup Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REFLECT_CRC</name>
              <description>Reflection of the CRC result as it is read out. An 8-bit CRC value is reflected on [7-0], bit7 to bit0, bit6 to bit1, etc. 16-bit and 32-bit CRC are reflected similarly. </description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Reflection is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Reflection is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INVERT_CRC</name>
              <description>Inverting of each bit of the calculated CRC as it is read out.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The CRC is not inverted.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Each bit is inverted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USE_CUSTOM_POLY</name>
              <description>Use of a custom polynomial for CRC calculations. 
Note: Custom polynomials can only be used for 32-bit CRC algorithms.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Custom polynomial is not used. The algorithm selected in CRC_CONTROL[ALGORITHM_SEL] bit field is used for the CRC calculation.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable the use of a custom polynomial. For more information of the supported polynomials and their format, see Section CRC Overview and Section CRC Polynomials.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BIT_SWAP</name>
              <description>Bit swapping during CRC calculation.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Do not swap bits.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Swap the bits within each byte.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BYTE_SWAP</name>
              <description>Byte swapping during CRC calculation.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Do not swap bytes.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Swap the bytes within each word (16-bit and 32-bit calculations only).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ALGORITHM_SEL</name>
              <description>Algorithm selection.</description>
              <bitRange>[6:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>CRC-8-CCITT</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>CRC-16</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>CRC-16-CCITT</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>CRC-32</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>CRC-32C</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ALGO_SIZE</name>
              <description>Algorithm size selection.
Must program CRC_CONTROL[ALGO_SIZE] = 0x2 when using custom polynomials.</description>
              <bitRange>[2:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>8-bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>16-bit</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>32-bit</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INIT</name>
              <description>Writing INIT will load seed and polynomial. Reading will always return INIT = 0. 
Bit must always be written to 0x1 before starting CRC calculations.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_SEED</name>
          <description>Seed Value Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SEED</name>
              <description>Seed value.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_POLY_CUSTOM</name>
          <description>Custom Polynomial Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRC_POLY_CUSTOM</name>
              <description>Bits 31-0 are used for custom 32-bit CRC calculations.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_OUT</name>
          <description>Accumulated CRC Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRC_OUT</name>
              <description>Bits 31-0 are used for reading out 32-bit CRC calculations. 
Bits 15-0 are used for reading out 16-bit CRCs.
Lowest eight bits 7-0 are used for reading out 8-bit CRCs.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>64</dim>
          <dimIncrement>1</dimIncrement>
          <name>CRC_DATA_IN_8_[%s]</name>
          <description>8-bit Values Register n</description>
          <addressOffset>0x20</addressOffset>
          <size>8</size>
          <access>write-only</access>
          <resetValue>0x00</resetValue>
          <resetMask>0x00</resetMask>
          <fields>
            <field>
              <name>CRC_DATA_IN_8</name>
              <description>Data written in this register is for 8-bit and 16-bit calculations, but only 8-bits can be written per beat.</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>40</dim>
          <dimIncrement>4</dimIncrement>
          <name>CRC_DATA_IN_32_[%s]</name>
          <description>32-bit Values Register n</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>CRC_DATA_IN_32</name>
              <description>Data written in this register is for 32-bit calculations.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="CRC0">
      <name>CRC1</name>
      <baseAddress>0x48108000</baseAddress>
    </peripheral>
    <peripheral>
      <name>USB</name>
      <baseAddress>0x48200000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>51716</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CAPLENGTH</name>
          <description>Capability Registers Length</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x01100020</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HCIVERSION</name>
              <description>Host controller interface version number.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CAPLENGTH</name>
              <description>Capability registers length.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HCSPARAMS1</name>
          <description>Structural Parameters 1 Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x01000140</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MAXPORTS</name>
              <description>Number of ports.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAXINTRS</name>
              <description>Number of interrupters.</description>
              <bitRange>[18:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAXSLOTS</name>
              <description>Number of device slots.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HCSPARAMS2</name>
          <description>Structural Parameters 2 Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0C0000F1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MAXSCRATCHPADBUFS</name>
              <description>Maximum scratchpad buffers low.
Possible values are from 0x1 to 0x4.</description>
              <bitRange>[31:27]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPR</name>
              <description>Scratchpad restore.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAXSCRATCHPADBUFS_HI</name>
              <description>Maximum scratchpad buffers high.</description>
              <bitRange>[25:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ERSTMAX</name>
              <description>Event ring segment table maximum.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IST</name>
              <description>Isochronous scheduling threshold.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HCSPARAMS3</name>
          <description>Structural Parameters 3 Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x07FF000A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>U2_DEVICE_EXIT_LAT</name>
              <description>U2 device exit latency.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>U1_DEVICE_EXIT_LAT</name>
              <description>U1 device exit latency.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HCCPARAMS1</name>
          <description>Capability Parameters 1 Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0220FE6C</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>XECP</name>
              <description>xHCI extended capabilities pointer.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAXPSASIZE</name>
              <description>Maximum primary stream array size.</description>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CFC</name>
              <description>Contiguous frame ID capability.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Stopped EDLTA capability.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPC</name>
              <description>Short packet capability.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PAE</name>
              <description>Parse all event data.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NSS</name>
              <description>No secondary SID support.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LTC</name>
              <description>Latency tolerance messaging capability.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LHRC</name>
              <description>Light host controller reset capability.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PIND</name>
              <description>Port indicators.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PPC</name>
              <description>Port power control.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CSZ</name>
              <description>Context size.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BNC</name>
              <description>Bandwidth negotiation capability.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>AC64</name>
              <description>64-bit addressing capability.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DBOFF</name>
          <description>Doorbell Offset</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000480</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DOORBELL_ARRAY_OFFSET</name>
              <description>Doorbell array offset.</description>
              <bitRange>[31:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTSOFF</name>
          <description>Run-time Register Space Offset</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000440</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RUNTIME_REG_SPACE_OFFSET</name>
              <description>Runtime register space offset.</description>
              <bitRange>[31:5]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HCCPARAMS2</name>
          <description>Host Controller Capability Parameters 2</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0000002F</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CIC</name>
              <description>Configuration information capability.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LEC</name>
              <description>Large ESIT payload capability.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CTC</name>
              <description>Compliance transition capability.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FSC</name>
              <description>Force save context capability.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMC</name>
              <description>Configure endpoint command maximum exit latency too large capability.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>U3C</name>
              <description>U3 entry capability.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GSBUSCFG0</name>
          <description>Global SoC Bus Configuration Register 0</description>
          <addressOffset>0xC100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATRDREQINFO</name>
              <description>Data read request info.
AHB-prot/AXI-cache/OCP-ReqInfo for data read.</description>
              <bitRange>[31:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DESRDREQINFO</name>
              <description>Descriptor read request info.
AHB-prot/AXI-cache/OCP-ReqInfo for descriptor read.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATWRREQINFO</name>
              <description>Data write request info.
AHB-prot/AXI-cache/OCP-ReqInfo for data write.</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DESWRREQINFO</name>
              <description>Descriptor write request info.
AHB-prot/AXI-cache/OCP-ReqInfo for descriptor write.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATBIGEND</name>
              <description>Data access is big endian.
This bit controls the endian mode for data accesses.
Note: For an AXI master, this bit must be set to 0x0.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Little-endian (default)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Big-endian</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DESBIGEND</name>
              <description>Descriptor access is big endian.
This bit controls the endian mode for descriptor accesses.
Data is considered as embedded data in the descriptors in the following cases:
- Device mode: The buffer pointer of a Setup TRB points to the Setup TRB itself. In device mode, if the system uses different endian modes for descriptor and data, software must not use embedded data.
- Host mode: The Immediate Data (IDT) bit in a Transfer TRB is set to 0x1. In host mode, if the system uses different endian modes for data and descriptors, the controller treats embedded data as descriptor (not as data) in terms of endian mode handling. If this is not the expectation of the system, the software must manipulate the embedded data accordingly.
Note: For an AXI master, this bit must be set to 0x0.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Little-endian (default)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Big-endian</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INCR256BRSTENA</name>
              <description>INCR256 burst type enable.
If software set this bit to 0x1, the AXI master uses INCR to do the 256-beat burst.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INCR128BRSTENA</name>
              <description>INCR128 burst type enable.
If software set this bit to 0x1, the AXI master uses INCR to do the 128-beat burst.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INCR64BRSTENA</name>
              <description>INCR64 burst type enable.
If software set this bit to 0x1, the AXI master uses INCR to do the 64-beat burst.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INCR32BRSTENA</name>
              <description>INCR32 burst type enable.
If software set this bit to 0x1, the AXI master uses INCR to do the 32-beat burst.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INCR16BRSTENA</name>
              <description>INCR16 burst type enable.
If software set this bit to 0x1, the AXI master uses INCR to do the 16-beat burst.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INCR8BRSTENA</name>
              <description>INCR8 burst type enable.
If software set this bit to 0x0, the AXI master uses INCR to do the 8-beat burst.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INCR4BRSTENA</name>
              <description>INCR4 burst type enable.
When this bit is enabled (set to 0x1), the controller is allowed to do bursts of beat length 1, 2, and 4.
It is highly recommended that this bit is enabled to prevent descriptor reads and writes from being broken up into separate transfers.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INCRBRSTENA</name>
              <description>Undefined length INCR burst type enable.
This bit determines the set of burst lengths the master interface uses. It works in conjunction with the GSBUSCFG0[7-1] bits enables (INCR256/128/64/32/16/8/4).
ARLEN/AWLEN do not use INCR except in case of non-aligned burst transfers. In the case of address-aligned transfers, they use only the following burst lengths:
- 1
- 2, 4 (if GSBUSCFG0[INCR4BRSTENA] = 0x1)
- 8 (if GSBUSCFG0[INCR8BRSTENA] = 0x1)
- 16 (if GSBUSCFG0[INCR16BRSTENA] = 0x1)
- 32 (if GSBUSCFG0[INCR32BRSTENA] = 0x1)
- 64 (if GSBUSCFG0[INCR64BRSTENA] = 0x1)
- 128 (if GSBUSCFG0[INCR128BRSTENA] = 0x1)
- 256 (if GSBUSCFG0[INCR256BRSTENA] = 0x1)
Note: In case of non-address-aligned transfers, INCR may get generated at the beginning and end of the transfers to align the address boundaries, even though INCR is disabled.
AXI: ARLEN/AWLEN uses any length less than or equal to the largest-enabled burst length of INCR32/64/128/256.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>INCRX burst mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>INCR (undefined length) burst mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GSBUSCFG1</name>
          <description>Global SoC Bus Configuration Register 1</description>
          <addressOffset>0xC104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000300</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EN1KPAGE</name>
              <description>1KB page boundary.
By default (this bit is disabled) the AXI breaks transfers at the 4KB page boundary. When this bit is enabled, the AXI master (DMA data) breaks transfers at the 1KB page boundary.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PIPETRANSLIMIT</name>
              <description>AXI pipelined transfers burst request limit.
This bit field controls the number of outstanding pipelined transfer requests the AXI master pushes to the AXI slave.
When the AXI master reaches this limit, it does not make any more requests on the AXI ARADDR and AWADDR buses until the associated data phases complete.
This bit field is encoded as follows:</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1 request</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>2 requests</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>3 requests</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>4 requests</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description>16 requests</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GCTL</name>
          <description>Global Core Control Register</description>
          <addressOffset>0xC110</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x18612004</resetValue>
          <resetMask>0x7FFFFFFF</resetMask>
          <fields>
            <field>
              <name>BYPSSETADDR</name>
              <description>Bypass set address in Device mode.
This bit must be set to 0x0.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRMSCLDWN</name>
              <description>Frame scales down.
This bit field scales down device view of a SOF/USOF/ITP duration.
For High Speed (HS) mode:
- Value of 3 implements interval to be 15.625 us
- Value of 2 implements interval to be 31.25 us
- Value of 1 implements interval to be 62.5 us
- Value of 0 implements interval to be 125 us</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRTCAPDIR</name>
              <description>Port capability direction.
Note: For static Host-only/Device-only applications, use DRD Host or DRD Device mode. The combination of this bit filed set to 0x3 with SRP and HNP/RSP disabled is not recommended for these applications.
The sequence for switching modes in DRD Device mode is as follows:
- For switching from Device to Host:
1. Reset the controller using the CORESOFTRESET bit.
2. Set the PRTCAPDIR bit field to 0x1 (Host mode).
3. Reset the host using USBCMD.HCRESET bit.
4. Follow the steps in Section Initializing Host Registers.
- For switching from Host to Device:
1. Reset the controller using the CORESOFTRESET bit.
2. Set the GCTL[PRTCAPDIR] bit field to 0x2 (Device mode).
3. Reset the device by setting the DCTL[CSFTRST] bit.
4. Follow the steps in Section Initializing Registers.
Programming this bit field with random data causes the controller to keep toggling between the Host mode and the Device mode. Bit Bash register testing is not recommended.</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>For host configurations</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>For device configurations</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CORESOFTRESET</name>
              <description>Core soft reset.
Clears the interrupts and all the CSRs except the following registers:
- GCTL
- GUCTL
- GSTS
- GSNPSID
- GUID
- GUSB2PHYCFG0
- DCFG
- DCTL
- DEVTEN
- DSTS
Note: This bit is for debug purposes only. Use USBCMD.HCRESET bit in xHCI Mode and the DCTL[SOFTRESET] bit in Device mode for soft reset.
Programming this bit field with random data will reset the internal logic of the host controller. Due to this side effect Bit Bash register testing is not recommended.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No soft reset</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Soft reset to controller</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SOFITPSYNC</name>
              <description>Reserved.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RAMCLKSEL</name>
              <description>RAM clock (RAM_CLK) select.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>AHB bus clock (BUS_CLK)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>In Host mode, the controller switches RAM_CLK between MAC2_CLK and BUS_CLK based on the status of the USB ports.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>In Device mode, selects MAC2_CLK as RAM_CLK. In Host mode, controller switches RAM_CLK between MAC2_CLK and BUS_CLK based on the status of the USB ports.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SCALEDOWN</name>
              <description>Scale-Down mode.
Keep at 0x0.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISSCRAMBLE</name>
              <description>Disable scrambling.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GBLHIBERNATIONEN</name>
              <description>Hibernation enable status at the global level. 
If hibernation is not enabled through this bit, the PMU immediately accepts the D0 -&gt; D3 and D3 -&gt; D0 power state change requests, but does not save or restore any controller state.
In addition, the PMUs never drive the PHY interfaces and let the controller continue to drive the PHY interfaces.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DSBLCLKGTNG</name>
              <description>Disable clock gating.
This bit is set to 0x1 and the controller is in Low-Power mode, internal clock gating is disabled.
This bit can be set to 0x1 after power-on reset.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GSTS</name>
          <description>Global Status Register</description>
          <addressOffset>0xC118</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x7E800000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CBELT</name>
              <description>Current BELT value.
In Host mode, this bit field indicates the minimum value of all received device BELT values and the BELT value that is set by the Set Latency Tolerance Value command.</description>
              <bitRange>[31:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SSIC_IP</name>
              <description>This bit is not used.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OTG_IP</name>
              <description>This bit is not used.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BC_IP</name>
              <description>This bit is not used.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ADP_IP</name>
              <description>This bit is not used.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HOST_IP</name>
              <description>Host interrupt pending.
This field indicates that there is a pending interrupt pertaining to xHC in the Host event queue.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DEVICE_IP</name>
              <description>Device interrupt pending.
This field indicates that there is a pending interrupt pertaining to peripheral (device) operation in the Device event queue.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CSRTIMEOUT</name>
              <description>CSR timeout.
When this bit is set to 0x1, it indicates that the software performed a write or read to a controller register that could not be completed within predefined bus clock cycles (default: 0x1FFFF).
Write 0x1 to clear.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUSERRADDRVLD</name>
              <description>Bus error address valid.
Indicates that the Global SoC Bus Error Address register (GBUSERRADDRLO or GBUSERRADDRHI) is valid and reports the first bus address that encounters a bus error. 
Write 0x1 to clear.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CURMOD</name>
              <description>Indicates the current mode of operation.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Device mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Host mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GUCTL1</name>
          <description>Global User Control Register 1</description>
          <addressOffset>0xC11C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0004198A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DEV_DECOUPLE_L1L2_EVT</name>
              <description>Device decoupled L1/L2 event.
This bit is applicable for Device mode only. If this feature is enabled, L1 suspend and wake events have individual controls to enable/mask them.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Default behavior, no change in device events L1/L2 events are not decoupled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Feature enabled, L1 and L2 events are separated. Separate event enable bits for L1 suspend and wake events.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FILTER_SE0_FSLS_EOP</name>
              <description>Filter SE0 detection in FS/LS or EOP.
This bit is applicable for FS/LS operation. If this feature is enabled, then SE0 on the LineState is validated for two consecutive UTMI clock edges for EOP detection. This feature is applicable only in FS in Device mode and FS/LS mode of operation in Host mode.
- Device mode: FS-If this bit is set, then for device LPM handshake, the controller will ignore single SE0 glitch on the LineState during transmit. Only two or more SE0 is considered as a valid EOP on FS.
- Host mode: FS/LS-If FILTER_SE0_FSLS_EOP is set, then the controller will ignore single SE0 glitch on the LineState during transmit. Only two or more SE0 is considered as a valid EOP on FS/LS port.
Enable this feature if the LineState has SE0 glitches during transmission. This bit is quasi-static, that is, it must not be changed during device operation.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Default behavior, no change in LineState check for SE0 detection in FS/LS.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Feature enabled, FS/LS SE0 is filtered for two clocks for detecting EOP.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TX_IPGAP_LINECHECK_DIS</name>
              <description>Disable TX IPGAP LineState check.
This bit is applicable for HS operation of MAC. If this feature is enabled, then the MAC operating in HS ignores the UTMI/ULPI LineState during the transmit of a token (during token-to-token and token-to-data IPGAP). When enabled, the controller implements a fixed 40-bit TXENDDELAY after the packet is given on UTMI and ignores the LineState during this time:
- Device mode: If this bit is set, then for device LPM handshake, the controller will ignore the LineState after TX and wait for fixed clocks (40 bit times equivalent) after transmitting ACK on UTMI.
- Host mode: If this bit is set, then the IPGAP between (token-to-token/token-to-data) is added by 40 bit times of TXENDDELAY, and LineState is ignored during this 40 bit times delay.
Enable this bit if the LineState will not reflect the expected line state (J) during transmission. This bit is quasi-static, that is, it must not be changed during device operation.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Default behavior, no change in LineState check.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Feature enabled, 2.0 MAC disables LineState check during HS transmit.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEV_TRB_OUT_SPR_IND</name>
              <description>OUT in TRB status short packet indication.
This bit is applicable for Device mode only. If the device application (software/hardware) wants to know if a short packet was received for an OUT in the TRB status itself, then this feature can be enabled, so that a bit is set in the TRB writeback in the BUF_SIZE DWORD. The HCSPARAMS2[SPR] bit of the {trbstatus, RSVD, SPR, PCM1, bufsize} DWORD will be set during an OUT transfer TRB write back if this is the last TRB used for that transfer descriptor. This bit is quasi-static, that is, it must not be changed during device operation.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Default behavior, no change in TRB status DWORD</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Feature enabled, OUT TRB status indicates Short Packet</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEV_L1_EXIT_BY_HW</name>
              <description>Device in L1 hardware exit.
When control transfers are in progress, the LPM is rejected (NYET response). Only after control transfers are completed (either with ACK/STALL), LPM is accepted.
This bit is applicable for Device mode only. This field enables device controller sending remote wakeup for L1 if the device becomes ready for sending/accepting data when in L1 state. If the host expects the device to send remote wakeup signaling to resume after going into L1 in flow controlled state, then this bit can be set to send the remote wake signal automatically when the device controller becomes ready. This hardware remote wake feature is applicable only to bulk and interrupt transfers, and not for isochronous/control.
For isochronous transfers, the host needs to do the wake-up and start the transfer. Device controller will not do remote-wakeup when isochronous endpoints get ready. The device software needs to keep the GUSB2PHYCFG0[ENBLSLPM] bit reset in order to keep the PHY clock to be running for keeping track of SOF intervals.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Default behavior, disables device L1 hardware exit logic.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Feature is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IP_GAP_ADD_ON</name>
              <description>Inter packet gap add on.
This bit field is used to add on to the default inter packet gap setting in the USB 2.0 MAC. This should be programmed to a non-zero value only in case where it is need to increase the default inter packet delay calculations in the USB 2.0 MAC</description>
              <bitRange>[23:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEV_LSP_TAIL_LOCK_DIS</name>
              <description>Disable device LSP lock logic for tail TRB.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Default behavior, enables device LSP lock logic for tail TRB update.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Fix is disabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NAK_PER_ENH_FS</name>
              <description>Performance enhancement for FS in NAK.
If a periodic endpoint is present, and if a bulk endpoint which is also active is being NAKed by the device, then this could result in a decrease in performance of other Full-Speed bulk endpoint which is ACKed by the device. Setting this bit to 0x1, enables the HC to schedule more transactions to the async endpoints (bulk/control) and hence improves the performance of the bulk endpoint. This control bit should be enabled only if the existing performance with the default setting is not sufficient for Full-Speed application. Setting this bit will only control, and is only required for Full-Speed transfers.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Enhancement not applied.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables performance enhancement for FS async endpoints in the presence of NAKs.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NAK_PER_ENH_HS</name>
              <description>Performance enhancement for HS in NAK.
If a periodic endpoint is present, and if a bulk endpoint which is also active is being NAKed by the device, then this could result in decrease in performance of other HS bulk endpoint which is ACked by the device. Setting this bit to 0x1, enables the host controller to schedule more transactions to the async endpoints (bulk/control) and hence it improves the performance of the bulk endpoint. This control bit should be enabled only if the existing performance with the default setting is not sufficient for HS application. Setting this bit only controls, and is only required for HS transfers.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Enhancement not applied.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables performance enhancement for HS async endpoints in the presence of NAKs.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PARKMODE_DISABLE_HS</name>
              <description>Disable park mode of HS bus instances.
This bit is used only in Host mode.
When this bit is set to 0x1, all HS bus instances park mode are disabled.
To improve performance in park mode, the xHCI scheduler queues in three requests of 4 packets each for HS asynchronous endpoints in a micro-frame. But if a device is slow and if it NAKs more than 3 times, then it is rescheduled only in the next micro-frame. This could decrease the performance of a slow device even further.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARKMODE_DISABLE_FSLS</name>
              <description>Disable park mode of FS/LS bus instances.
This bit is used only in Host mode, and is for debug purpose only.
When this bit is set to 0x1 all FS/LS bus instances in park mode disabled.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISUSB2REFCLKGTNG</name>
              <description>Disable REF_CLK gating for 2.0 PHY
If REF_CLK gating is disabled, then the REF_CLK input cannot be turned off to the USB 2.0 PHY and controller. This is independent of the GCTL[DSBLCLKGTNG] bit setting.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>REF_CLK gating enabled for USB 2.0 PHY</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>REF_CLK gating disabled for USB 2.0 PHY</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESUME_OPMODE_HS_HOST</name>
              <description>Opmode in HS resume in Host mode
This bit is used only in Host mode, and is for USB 2.0 opmode behavior in HS Resume.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When this bit is set to 0x0, the UTMI/ULPI opmode changes to normal 2 us after HS terminations change after EOR. This is the default behavior.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When this bit is set to 0x1, the UTMI opmode changes to normal along with HS terminations after EOR.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEV_HS_NYET_BULK_SPR</name>
              <description>HS bulk OUT short packet gets NYET in Device mode
This bit is applicable for Device mode only.
If this bit is set, the device controller sends NYET response instead of ACK response for a successfully received bulk OUT short packet. If NYET is sent after receiving short packet, then the host would PING before sending the next OUT; this improves the performance as well as clears up the buffer/cache on the host side. Internal to the device controller, short packet (HCSPARAMS2[SPR] = 0x1) processing takes some time, and during this time, the USB is flow controlled. With NYET response instead of ACK on short packet, the host does not send another OUT-DATA without pinging in HS mode.
This bit is quasi-static, that is, it must not be changed during device operation.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Default behavior, no change in device response.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Feature enabled, HS bulk OUT short packet gets NYET response.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>L1_SUSP_THRLD_EN_FOR_HOST</name>
              <description>L1 suspend threshold enable in Host mode.
This bit is used only in Host mode.
The host controller asserts the UTMI_L1_SUSPEND_n and UTMI_SLEEP_n output signals as follows:
The controller asserts the UTMI_L1_SUSPEND_n signal to put the PHY into deep low-power mode in L1 when both of the following are true:
a) The HIRD/BESL value used is greater than or equal to the value in the L1_SUSP_THRLD_FOR_HOST bit.
b) The L1_SUSP_THRLD_EN_FOR_HOST bit is set to 0x1.
The controller asserts UTMI_SLEEP_n on L1 when one of the following is true: 
a) The HIRD/BESL value used is less than the value in the L1_SUSP_THRLD_FOR_HOST bit.
b) This bit is set to 0x0.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>L1_SUSP_THRLD_FOR_HOST</name>
              <description>L1 suspend threshold in Host mode.
This bit field is effective only when the L1_SUSP_THRLD_EN_FOR_HOST bit is set to 0x1. For more details, refer to the description of the L1_SUSP_THRLD_EN_FOR_HOST bit.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HC_ERRATA_ENABLE</name>
              <description>Host Exit Latency Delta (ELD) enable.
When this bit is set to 0x1, it enables the ELD support defined in the xHCI 1.0 Errata.
This bit is used only in Host mode and should be set to 0x1.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HC_PARCHK_DISABLE</name>
              <description>Host parameter check disable.
When this bit is set to 0x0 (by default), the xHC checks that the input slot/EP context fields comply to the xHCI Specification. Upon detection of a parameter error during command execution, the xHC generates an event TRB with completion code indicating PARAMETER_ERROR.
When the bit is set to 0x1, the xHC does not perform parameter checks and does not generate PARAMETER_ERROR completion code.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVRLD_L1_SUSP_COM</name>
              <description>Overvload UTMI_L1_SUSPEND_COM.
If this bit is set, the UTMI_L1_SUSPEND_COM_n is overloaded with the UTMI_SLEEP_n signal. This bit is usually set if the PHY stops the port clock during L1 sleep condition.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOA_FILTER_EN</name>
              <description>LOA filter enable.
If this bit is set, the USB 2.0 port babble is checked at least three consecutive times before the port is disabled. This prevents false triggering of the babble condition when using low quality cables.
Note: This bit is valid only in Host mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GSNPSID</name>
          <description>Global Controller ID Register</description>
          <addressOffset>0xC120</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x5533330B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GSNPSID</name>
              <description>The GSNPSID[31-16] bit field indicates the Core Identification Number. 0x5533 is ASCII for U3.
The GSNPSID[15-0] bit field indicates the release number. Current Release is 3.30b.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GUID</name>
          <description>Global User ID Register</description>
          <addressOffset>0xC128</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x12345678</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>USERID</name>
              <description>Application-programmable ID field.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GUCTL</name>
          <description>Global User Control Register</description>
          <addressOffset>0xC12C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x02000010</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REF_CLK_PERIOD</name>
              <description>REF_CLK period.
This bit field indicates in terms of nano seconds the period of REF_CLK. The default value of this bit field is set to 0x8 (8 ns/125 MHz).
This bit field needs to be updated during power-on initialization, if the GCTL[SOFITPSYNC] or GFLADJ[GFLADJ_REFCLK_LPM_SEL] bit is set to 0x1. The programmable maximum value is 62 ns, and the minimum value is 8 ns.
The user should use a reference clock with a period that is an integer multiple, so that ITP can meet the jitter margin of 32 ns. The allowable REF_CLK frequencies whose period is not integer multiples are 16/17/19.2/24/39.7 MHz.
This bit field must not be set to 0x0 at any time. If it is not planed to use this feature, this bit field should be set to 0x8 (the default value).</description>
              <bitRange>[31:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOEXTRDL</name>
              <description>No Extra Delay Between SOF and the First Packet.
Some HS devices misbehave when the host sends a packet immediately after a SOF. However, adding an extra delay between a SOF and the first packet can reduce the USB data rate and performance.
This bit is used to control whether the host must wait for 2 us before it sends the first packet after a SOF, or not. This bit can be set to 0x1 to improve the performance if those problematic devices are not a concern in the user host environment.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Host waits for 2 us after a SOF before it sends the first USB packet.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Host does not wait after a SOF before it sends the first USB packet.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPRSCTRLTRANSEN</name>
              <description>Sparse control transaction enable.
Some devices are slow in responding to control transfers. Scheduling multiple transactions in one microframe/frame can cause these devices to misbehave.
If this bit is set to 0x1, the HC schedules transactions for a control transfer in different microframes/frames.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESBWHSEPS</name>
              <description>Reserving 85% bandwidth for HS periodic EPs.
By default, HC reserves 80% of the bandwidth for periodic EPs. If this bit is set, the bandwidth is relaxed to 85% to accommodate two High-Speed, High-Bandwidth ISOC EPs.
USB 2.0 requires 80% bandwidth allocated for ISOC traffic. If two High-Bandwidth ISOC devices (HD webcams) are connected, and if each requires 1024 bytes x 3 packets per Micro-Frame, then the bandwidth required is around 82%. If this bit is set, then it is possible to connect two webcams of 1024 bytes x 3 payload per Micro-Frame each. Otherwise, it could be needed to reduce the resolution of the webcams.
Note: This bit is used in Host mode operation only. Ignore this bit in Device mode.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USBHSTINAUTORETRYEN</name>
              <description>Host IN auto retry.
When set, this bit enables the Auto Retry feature. For IN transfers (non-isochronous) that encounter data packets with CRC errors or internal overrun scenarios, the Auto Retry feature causes the HC to reply to the device with a non-terminating retry ACK (that is, an ACK transaction packet with Retry = 1 and NumP != 0).
If the Auto Retry feature is disabled (default), the controller responds with a terminating retry ACK (that is, an ACK transaction packet with Retry = 1 and NumP = 0).
Note: When enabling Auto Retry feature, if the system latency is large enough to cause the internal PSQ full (PSQ can be full as the result of messages not being processed because of pending fetches before flushing the TxQ due to NRDY/ERDY conditions), then the HC can generate a transaction error.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Auto Retry is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Auto Retry is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EXTCAPSUPPTEN</name>
              <description>External extended capability support enable.
When set, this bit enables extended capabilities to be implemented outside the controller.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSRTEXTRFSBODI</name>
              <description>Insert extra delay between FS Bulk OUT transactions.
Some FS devices are slow to receive Bulk OUT data and can get stuck when there are consecutive Bulk OUT transactions with short inter-transaction delays. This bit is used to control whether the host inserts extra delay between consecutive Bulk OUT transactions to a FS Endpoint.
Note: Setting this bit to 0x1 reduces the Bulk OUT transfer performance for most of the FS devices.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Host does not insert extra delay between consecutive Bulk OUT transactions to a FS Endpoint.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Host inserts about 12 us extra delay between consecutive Bulk OUT transactions to a FS Endpoint to work around the device issue.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTCT</name>
              <description>Device timeout coarse tuning.
This field is a Host mode parameter which determines how long the host waits for a response from device before considering a timeout.
The controller first checks the DTCT value. If it is 0x0, then the timeout value is defined by the DTFT. If it is non-zero, then it uses the following timeout values:
Note: When the system latency is larger than the programmed DTCT/DTFT value, if the HC is not able to accept certain transactions on the bus (because of system bus delays), the controller may not release header credits which in turn can cause the host to report a transaction error. Therefore, program this value to be larger than your system delay.</description>
              <bitRange>[10:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>0 us-use DTFT value instead</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>500 us</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>1.5 ms</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>6.5 ms</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTFT</name>
              <description>Device timeout fine tuning.
This bit field is a Host mode parameter which determines how long the host waits for a response from device before considering a timeout.
For the DTFT field to take effect, the DTCT bit filed must be set to 0x0.
The DTCT value is the number of 60 MHz clocks x 256 to count before considering a device timeout.
The minimum value of DTFT is 0x2.
Note: When the system latency is larger than the programmed DTCT/DTFT value, if the HC is not able to accept certain transactions on the bus (because of system bus delays), the controller may not release header credits which in turn can cause the host to report a transaction error. Therefore, program this value to be larger than your system delay.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GBUSERRADDRLO</name>
          <description>Global SoC Bus Error Address Register-Low</description>
          <addressOffset>0xC130</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUSERRADDR</name>
              <description>Bus address-low. 
This register contains the lower 32 bits of the first bus address that encountered a SoC bus error. It is valid when the GSTS[BUSEEEADDRVLD] bit is set to 0x1. It can only be cleared by resetting the controller.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GBUSERRADDRHI</name>
          <description>Global SoC Bus Error Address Register-High</description>
          <addressOffset>0xC134</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUSERRADDR</name>
              <description>Bus address-high.
This register contains the higher 32 bits of the first bus address that encountered a SoC bus error. It is valid when the GSTS[BUSERRADDRVLD] bit is set to 0x1. It can only be cleared by resetting the controller.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GHWPARAMS0</name>
          <description>Global Hardware Parameters Register 0</description>
          <addressOffset>0xC140</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x2020400A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GHWPARAMS0_31_24</name>
              <description>Master/Slave Address Bus Width (num bits).</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS0_23_16</name>
              <description>Slave Bus (Register Access Bus) Data Bus Width (num bits).</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS0_15_8</name>
              <description>Master Bus (DMA Bus) Data Bus Width (num bits).</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS0_7_6</name>
              <description>Slave Bus (Register Access Bus) Interface Type (0x0 = AHB).</description>
              <bitRange>[7:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS0_5_3</name>
              <description>Master Bus (DMA Bus) Interface Type (0x1 = AXI).</description>
              <bitRange>[5:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS0_2_0</name>
              <description>Mode of Operation (0x2 = Device and Host (DRD)).</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GHWPARAMS1</name>
          <description>Global Hardware Parameters Register 1</description>
          <addressOffset>0xC144</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x01A0C93B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GHWPARAMS1_31</name>
              <description>xHCI debug capability.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS1_30</name>
              <description>RM_OPT_FEATURES</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS1_29</name>
              <description>Reserved.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS1_28</name>
              <description>RAM_BUS_CLKS_SYNC</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS1_27</name>
              <description>MAC_RAM_CLKS_SYNC</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS1_26</name>
              <description>MAC_PHY_CLKS_SYNC</description>
              <bitRange>[26:26]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS1_25_24</name>
              <description>Power Optimization Mode (0x1 = Clock Gating Only)</description>
              <bitRange>[25:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS1_23</name>
              <description>Synchronous Static RAM Type (0x1 = Single-Port RAM (SPRAM))</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS1_22_21</name>
              <description>Number of RAMs</description>
              <bitRange>[22:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS1_20_15</name>
              <description>Number of Device Mode Event Buffers</description>
              <bitRange>[20:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS1_14_12</name>
              <description>ASPACEWIDTH</description>
              <bitRange>[14:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS1_11_9</name>
              <description>REQINFOWIDTH</description>
              <bitRange>[11:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS1_8_6</name>
              <description>DATAINFOWIDTH</description>
              <bitRange>[8:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS1_5_3</name>
              <description>BURSTWIDTH - 1</description>
              <bitRange>[5:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS1_2_0</name>
              <description>IDWIDTH - 1</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GHWPARAMS2</name>
          <description>Global Hardware Parameters Register 2</description>
          <addressOffset>0xC148</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x12345678</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GHWPARAMS2_31_0</name>
              <description>User ID</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GHWPARAMS3</name>
          <description>Global Hardware Parameters Register 3</description>
          <addressOffset>0xC14C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x042D0084</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GHWPARAMS3_31</name>
              <description>Reserved.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS3_30_23</name>
              <description>CACHE_TOTAL_XFER_RESOURCES</description>
              <bitRange>[30:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS3_22_18</name>
              <description>Number of Device Mode Active IN Endpoints</description>
              <bitRange>[22:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS3_17_12</name>
              <description>Number of Device Mode Endpoints</description>
              <bitRange>[17:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS3_11</name>
              <description>ULPI_CARKIT</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS3_10</name>
              <description>UTMI PHY Vendor Control Interface</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS3_9_8</name>
              <description>Reserved.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS3_7_6</name>
              <description>HSPHY_DWIDTH</description>
              <bitRange>[7:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS3_5_4</name>
              <description>FSPHY_INTERFACE</description>
              <bitRange>[5:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS3_3_2</name>
              <description>HSPHY_INTERFACE (0x1 = UTMI+)</description>
              <bitRange>[3:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS3_1_0</name>
              <description>SSPHY_INTERFACE</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GHWPARAMS4</name>
          <description>Global Hardware Parameters Register 4</description>
          <addressOffset>0xC150</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x47822004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GHWPARAMS4_31_28</name>
              <description>BMU_LSP_DEPTH</description>
              <bitRange>[31:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS4_27_24</name>
              <description>BMU_PTL_DEPTH-1</description>
              <bitRange>[27:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS4_23</name>
              <description>EN_ISOC_SUPT</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS4_22</name>
              <description>Reserved.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS4_21</name>
              <description>Device External Buffer Control</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS4_20_17</name>
              <description>NUM_SS_USB_INSTANCES</description>
              <bitRange>[20:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS4_16_13</name>
              <description>HIBER_SCRATCHBUFS</description>
              <bitRange>[16:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS4_12</name>
              <description>Reserved.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS4_11</name>
              <description>Reserved.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS4_10_9</name>
              <description>Reserved.</description>
              <bitRange>[10:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS4_8_7</name>
              <description>Reserved.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS4_6</name>
              <description>Reserved.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS4_5_0</name>
              <description>Number of cached TRBs per Transfer</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GHWPARAMS5</name>
          <description>Global Hardware Parameters Register 5</description>
          <addressOffset>0xC154</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x04202088</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GHWPARAMS5_31_28</name>
              <description>Reserved.</description>
              <bitRange>[31:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS5_27_22</name>
              <description>DFQ_FIFO_DEPTH</description>
              <bitRange>[27:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS5_21_16</name>
              <description>DWQ_FIFO_DEPTH</description>
              <bitRange>[21:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS5_15_10</name>
              <description>TXQ_FIFO_DEPTH</description>
              <bitRange>[15:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS5_9_4</name>
              <description>RXQ_FIFO_DEPTH</description>
              <bitRange>[9:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS5_3_0</name>
              <description>BMU_BUSGM_DEPTH</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GHWPARAMS6</name>
          <description>Global Hardware Parameters Register 6</description>
          <addressOffset>0xC158</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x07490020</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GHWPARAMS6_31_16</name>
              <description>Total RAM0 Depth</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSFLTRSSUPPORT</name>
              <description>Filter for VBUS- and ID-related control inputs from the PHY</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BCSUPPORT</name>
              <description>Battery Charging Capability</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OTG_SS_SUPPORT</name>
              <description>Reserved.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ADPSUPPORT</name>
              <description>ADP support</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HNPSUPPORT</name>
              <description>Reserved.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SRPSUPPORT</name>
              <description>Reserved.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS6_9_8</name>
              <description>Reserved.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS6_7</name>
              <description>Reserved.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS6_6</name>
              <description>Reserved.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS6_5_0</name>
              <description>PSQ_FIFO_DEPTH</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GHWPARAMS7</name>
          <description>Global Hardware Parameters Register 7</description>
          <addressOffset>0xC15C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GHWPARAMS7_31_16</name>
              <description>RAM2_DEPTH</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS7_15_0</name>
              <description>RAM1_DEPTH</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPRTBIMAP_HSLO</name>
          <description>Global High-Speed Port to Bus Instance Mapping (Low)</description>
          <addressOffset>0xC180</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BINUM8</name>
              <description>HS USB instance number for port 8.
Application-programmable ID field.</description>
              <bitRange>[31:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM7</name>
              <description>HS USB instance number for port 7.
Application-programmable ID field.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM6</name>
              <description>HS USB instance number for port 6.
Application-programmable ID field.</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM5</name>
              <description>HS USB instance number for port 5.
Application-programmable ID field.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM4</name>
              <description>HS USB instance number for port 4.
Application-programmable ID field.</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM3</name>
              <description>HS USB instance number for port 3.
Application-programmable ID field.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM2</name>
              <description>HS USB instance number for port 2.
Application-programmable ID field.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM1</name>
              <description>HS USB instance number for port 1.
Application-programmable ID field.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPRTBIMAP_HSHI</name>
          <description>Global High-Speed Port to Bus Instance Mapping (High)</description>
          <addressOffset>0xC184</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BINUM15</name>
              <description>HS USB instance number for port 15.
Application-programmable ID field.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM14</name>
              <description>HS USB instance number for port 14. 
Application-programmable ID field.</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM13</name>
              <description>HS USB instance number for port 13.
Application-programmable ID field.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM12</name>
              <description>HS USB instance number for port 12.
SApplication-programmable ID field.</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM11</name>
              <description>HS USB instance number for port 11.
Application-programmable ID field.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM10</name>
              <description>HS USB instance number for port 10.
Application-programmable ID field.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM9</name>
              <description>HS USB instance number for port 9.
Application-programmable ID field.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPRTBIMAP_FSLO</name>
          <description>Global Full-Speed Port to Bus Instance Mapping (Low)</description>
          <addressOffset>0xC188</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BINUM8</name>
              <description>FS USB instance number for port 8.
Application-programmable ID field.</description>
              <bitRange>[31:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM7</name>
              <description>FS USB instance number for port 7.
Application-programmable ID field.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM6</name>
              <description>FS USB instance number for port 6.
Application-programmable ID field.</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM5</name>
              <description>FS USB instance number for port 5.
Application-programmable ID field.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM4</name>
              <description>FS USB instance number for port 4.
Application-programmable ID field.</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM3</name>
              <description>FS USB instance number for port 3.
Application-programmable ID field.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM2</name>
              <description>FS USB instance number for port 2.
Application-programmable ID field.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM1</name>
              <description>FS USB instance number for port 1.
Application-programmable ID field.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPRTBIMAP_FSHI</name>
          <description>Global Full-Speed Port to Bus Instance Mapping (High)</description>
          <addressOffset>0xC18C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BINUM15</name>
              <description>FS USB instance number for port 15.
Application-programmable ID field</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM14</name>
              <description>FS USB instance number for port 14.
Application-programmable ID field</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM13</name>
              <description>FS USB instance number for port 13.
Application-programmable ID field</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM12</name>
              <description>FS USB instance number for port 12.
Application-programmable ID field</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM11</name>
              <description>FS USB instance number for port 11.
Application-programmable ID field</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM10</name>
              <description>FS USB instance number for port 10.
Application-programmable ID field</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM9</name>
              <description>FS USB instance number for port 9.
Application-programmable ID field.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GUCTL2</name>
          <description>Global User Control Register 2</description>
          <addressOffset>0xC19C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0198040D</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EN_HP_PM_TIMER</name>
              <description>This register field is used to set new HP and PM timers.
To enable PM timer, set the GUCTL2[19] bit as 0x1.
To enable HP timer, set the GUCTL2[20] bit as 0x1. Default value of HP timer is 4 us when HP PM timer is not enabled; when new HP timer is enabled default value is 12 us.</description>
              <bitRange>[25:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RST_ACTBITLATER</name>
              <description>Enable clearing of the command active bit for the ENDXFER command after the command execution is completed.
This bit is valid in Device mode only.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLEEPCACHEEVICT</name>
              <description>Enable evicting endpoint cache after flow control for bulk endpoints.
A performance enhancement was done to keep the non-stream capable bulk IN endpoint in cache after flow control. Setting this bit will disable this enhancement. This should be set only for debug purpose.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLECFC</name>
              <description>Disable xHCI Errata feature contiguous frame ID capability.
This field controls the xHCI Errata feature Contiguous FrameID capability. When set, the HCCPARAMS1[CFC] bit will be set to 0x0 indicating that CFC is not supported. Disable this feature only if the application cannot tolerate Misssed Service Error events for ISOC transfers, and the system latencies are large to cause Missed Service errors even if the software is following the Isochronous Thresholding rules.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GUSB2PHYCFG0</name>
          <description>Global USB2 PHY Configuration Register</description>
          <addressOffset>0xC200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40102400</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHYSOFTRST</name>
              <description>UTMI PHY soft reset.
Causes the USB2PHY_RESET signal to be asserted to reset a UTMI PHY.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>U2_FREECLK_EXISTS</name>
              <description>U2 Free Clock Exists.
This bit specifies whether USB 2.0 PHY provides a free-running PHY clock, which is active when the clock control input is active.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>USB 2.0 free clock does not exist</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>USB 2.0 free clock exists</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ULPI_LPM_WITH_OPMODE_CHK</name>
              <description>Reserved. Keep at 0x0.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HSIC_CON_WIDTH_ADJ</name>
              <description>Reserved.</description>
              <bitRange>[28:27]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INV_SEL_HSIC</name>
              <description>Reserved.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVRD_FSLS_DISC_TIME</name>
              <description>Overriding the FS/LS disconnect time to 32 us.
If this value is 0x0, the FS/LS disconnect time is set to 2.5 us as per the USB specification.
If this value is non-zero, the disconnect detection time is set to 32 us.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LSTRD</name>
              <description>LS turnaround time.
This bit field indicates the value of the Rx-to-Tx packet gap for LS devices. The encoding is as follows:
Note: This field is applicable only in Host mode.
For normal operation (to work with most LS devices), set the default value of this bit field to 0x0 (2 bit times).
The programmable LS device inter-packet gap and turnaround delays are provided to support some legacy LS devices that might require different delays than the default/fixed ones.
Include PHY delays when programming the LSIPD/LSTRD values. For example, if PHY's TXENDDELAY in LS mode is 30 UTMI CLKs, then subtract this delay (~1 LS bit time) from the device delay requirement.</description>
              <bitRange>[24:22]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>2 bit times</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>2.5 bit times</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>3 bit times</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>3.5 bit times</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>4 bit times</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>4.5 bit times</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>5 bit times</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>5.5 bit times</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LSIPD</name>
              <description>LS inter-packet time.
This field indicates the value of Tx-to-Tx packet gap for LS devices. The encoding is as follows:
Note: This field is applicable only in Host mode.
For normal operation (to work with most LS devices), set the default value of this field to 0x2 (3 bit times).
The programmable LS device inter-packet gap and turnaround delays are provided to support some legacy LS devices that might require different delays than the default/fixed ones.
Include PHY delays when programming the LSIPD/LSTRD values.</description>
              <bitRange>[21:19]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>2 bit times</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>2.5 bit times</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>3 bit times</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>3.5 bit times</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>4 bit times</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>4.5 bit times</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>5 bit times</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>5.5 bit times</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USBTRDTIM</name>
              <description>USB 2.0 turnaround time.
This bit field sets the turnaround time in PHY clocks.
Specifies the response time for a MAC request to the Packet FIFO Controller (PFC) to fetch data from the DFIFO (SPRAM).
The following are the required values for the minimum SoC bus frequency of 60 MHz. USB turnaround time is a critical certification criteria when using long cables and five hub levels.
The required values for this field:
Note: This field is valid only in Device mode.</description>
              <bitRange>[13:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>When the MAC interface is 16-bit UTMI+.</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>When the MAC interface is 8-bit UTMI+/ULPI.</description>
                  <value>0x9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>XCVRDLY</name>
              <description>Transceiver Delay.
Enables a delay between the assertion of the UTMI Transceiver Select signal (for HS) and the assertion of the TxValid signal during a HS Chirp.
When this bit is set to 0x1, a delay (of approximately 2.5 us) is introduced from the time when the Transceiver Select is set to 0x0 (HS) to the time the TxValid is driven to 0 for sending the chirp-K. 
This bit is valid only in device mode.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENBLSLPM</name>
              <description>Enable UTMI_SLEEP_n and UTMI_L1_SUSPEND_n.
The application uses this bit to control UTMI_SLEEP_n and UTMI_L1_SUSPEND_n assertion to the PHY in the L1 state.
Note: This bit must be set to 0x1.
Note: In Device mode, before issuing any device endpoint command, disable this bit and enable it after the command completes. Without disabling this bit, if a command is issued when the device is in L1 state and if MAC2_CLK (UTMI_CLK) is gated off, the command will not get completed.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>UTMI_SLEEP_n and UTMI_L1_SUSPEND_n assertion from the controller is not transferred to the PHY.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>UTMI_SLEEP_n and UTMI_L1_SUSPEND_n assertion from the controller is transferred to the PHY.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PHYSEL</name>
              <description>USB 2.0 High-Speed PHY or USB 1.1 Full-Speed serial transceiver select.
Note: USB 1.1 full-serial transceiver is not supported. This bit always reads as 0x0.</description>
              <bitRange>[7:7]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>SUSPENDUSB20</name>
              <description>Suspend USB2.0 HS/FS/LS PHY.
When this bit is set, USB2.0 PHY enters Suspend mode if Suspend conditions are valid.
 Application needs to set it to 0x1 after the controller initialization completes.
Note: In Host mode, on reset, this bit is set to 0x1. Software can override this bit after reset.
In Device mode, before issuing any device endpoint command, disable this bit and enable it after the command completes. If the user issues a command without disabling this bit when the device is in L2 state and if MAC2_CLK (UTMI_CLK/ULPI_CLK) is gated off, the command will not get completed.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FSINTF</name>
              <description>Full-Speed serial interface select.
Note: USB 1.1 full-speed serial interface is not supported. This bit always reads as 0x0.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ULPI_UTMI_SEL</name>
              <description>ULPI or UTMI+ selection.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>UTMI+ interface</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ULPI interface</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PHYIF</name>
              <description>PHY interface.
If UTMI+ is selected, the application uses this bit to configure the controller to support a UTMI+ PHY with an 8- or 16-bit interface.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>8 bits</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>16 bits</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TOUTCAL</name>
              <description>HS/FS timeout calibration.
The number of PHY clocks, as indicated by the application in this bit field, is multiplied by a bit-time factor; this factor is added to the High-Speed/Full-Speed interpacket timeout duration in the controller to account for additional delays introduced by the PHY. This may be required, since the delay introduced by the PHY in generating the LineState condition may vary among PHYs.
The USB standard timeout value for high-speed operation is 736 to 816 (inclusive) bit times. The USB standard timeout value for Full-Speed operation is 16 to 18 (inclusive) bit times. The application must program this field based on the speed of connection. The number of bit times added per PHY clock are:
High-Speed operation:
- One 30-MHz PHY clock = 16 bit times
- One 60-MHz PHY clock = 8 bit times
Full-Speed operation:
- One 30-MHz PHY clock = 0.4 bit times
- One 60-MHz PHY clock = 0.2 bit times
- One 48-MHz PHY clock = 0.25 bit times</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>11</dim>
          <dimIncrement>4</dimIncrement>
          <name>GTXFIFOSIZ[%s]</name>
          <description>Global Transmit FIFO Size Register n</description>
          <addressOffset>0xC300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0271000A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXFSTADDR_N</name>
              <description>Transmit FIFOn RAM start address.
This bit field contains the memory start address for TxFIFOn in MDWIDTH-bit words.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TXFDEP_N</name>
              <description>TxFIFO Depth.
This field contains the depth of TxFIFOn in MDWIDTH-bit words.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>11</dim>
          <dimIncrement>4</dimIncrement>
          <name>GRXFIFOSIZ[%s]</name>
          <description>Global Receive FIFO Size Register n</description>
          <addressOffset>0xC380</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x016C0105</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXFSTADDR_N</name>
              <description>RxFIFOn RAM start address.
This bit field contains the memory start address for RxFIFO n in MDWIDTH-bit words.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RXFDEP_N</name>
              <description>RxFIFO depth.
This bit field contains the depth of RxFIFO n in MDWIDTH-bit words.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GEVNTADRLO0</name>
          <description>Global Event Buffer Address (Low)</description>
          <addressOffset>0xC400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EVNTADRLO</name>
              <description>Event buffer address.
This bit field holds the lower 32 bits of start address of the external memory for the Event Buffer. During operation, hardware does not update this address.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GEVNTADRHI0</name>
          <description>Global Event Buffer Address (High)</description>
          <addressOffset>0xC404</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EVNTADRHI</name>
              <description>Event buffer address.
This bit field holds the higher 32 bits of start address of the external memory for the Event Buffer. During operation, hardware does not update this address.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GEVNTSIZ0</name>
          <description>Global Event Buffer Size Register</description>
          <addressOffset>0xC408</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EVNTINTRPTMASK</name>
              <description>Event interrupt mask.
When this bit is set to 0x1, this prevents the interrupt from being generated. However, even when the mask is set, the events are queued.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENTSIZ</name>
              <description>Event buffer size in bytes.
This bit field holds the size of the Event Buffer in bytes; must be a multiple of four. This is programmed by software once during initialization. The minimum size of the event buffer is 32 bytes.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GEVNTCOUNT0</name>
          <description>Global Event Buffer Count Register</description>
          <addressOffset>0xC40C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EVNT_HANDLER_BUSY</name>
              <description>Event handler busy.
Device software event handler busy indication. The controller sets this bit when the interrupt line is asserted due to pending events. Software clears this bit (with 0x1) when it has finished processing the events (along with updating the EVNTCOUNT bit field in this register). The controller does not raise the interrupt line for a new event unless this bit is cleared.
Note: When interrupt moderation is disabled (that is, the DEV_IMOD0[DEVICE_IMODI] = 0x0), this bit is ignored.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVNTCOUNT</name>
              <description>Event count.
When read, returns the number of valid events in the Event Buffer (in bytes).
When written, hardware decrements the count by the value written.
When interrupt moderation is enabled (that is, the DEV_IMOD0[DEVICE_IMODI] != 0x0), the interrupt line gets de-asserted when the first write happens on this register to decrement the count. When interrupt moderation is disabled (that is, the DEV_IMOD0[DEVICE_IMODI] = 0x0), the interrupt line continues to get asserted until the event count becomes zero (no-moderation behavior).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GHWPARAMS8</name>
          <description>Global Hardware Parameters Register 8</description>
          <addressOffset>0xC600</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0000043C</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GHWPARAMS8_32_0</name>
              <description>Default RAM0 cache depth.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GTXFIFOPRIDEV</name>
          <description>Global Device TX FIFO DMA Priority Register</description>
          <addressOffset>0xC610</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GTXFIFOPRIDEV</name>
              <description>Device TxFIFO priority.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GTXFIFOPRIHST</name>
          <description>Global Host TX FIFO DMA Priority Register</description>
          <addressOffset>0xC618</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GTXFIFOPRIHST</name>
              <description>Host TxFIFO priority.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRXFIFOPRIHST</name>
          <description>Global Host RX FIFO DMA Priority Register</description>
          <addressOffset>0xC61C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GRXFIFOPRIHST</name>
              <description>Host RxFIFO priority.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GFLADJ</name>
          <description>Global Frame Length Adjustment Register</description>
          <addressOffset>0xC630</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GFLADJ_REFCLK_240MHZDECR_PLS1</name>
              <description>This bit indicates that the decrement value that the controller applies for each REF_CLK must be GFLADJ_REFCLK_240MHZ_DECR and GFLADJ_REFCLK_240MHZ_DECR + 1 alternatively on each REF_CLK.
Set this bit to a 0x1 only if the GFLADJ_REFCLK_LPM_SEL bit is set to 0x0 and the fractional component of 240/REF_CLK_FREQUENCY is greater than or equal to 0.5.
Examples:
If the REF_CLK is 19.2 MHz then:
- GUCTL[REF_CLK_PERIOD] = 52
- GFLADJ[GFLADJ_REFCLK_240MHZ_DECR] = (240/19.2) = 12.5
- GFLADJ[GFLADJ_REFCLK_240MHZDECR_PLS1] = 1
- GUCTL[REF_CLK_PERIOD] = 41
- GFLADJ[GFLADJ_REFCLK_240MHZ_DECR] = (240/24) = 10
- GFLADJ[GFLADJ_REFCLK_240MHZDECR_PLS1] = 0</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GFLADJ_REFCLK_240MHZ_DECR</name>
              <description>This bit field indicates the decrement value that the controller applies for each REF_CLK in order to derive a frame timer in terms of a 240-MHz clock.
This field must be programmed to a non-zero value only if GFLADJ_REFCLK_LPM_SEL is set to 0x1.
The value is derived as follows:
GFLADJ_REFCLK_240MHZ_DECR = 240/REF_CLK_FREQUENCY
Examples:
If the REF_CLK is 24 MHz then:
- GUCTL[REF_CLK_PERIOD] = 41
- GFLADJ[GFLADJ_REFCLK_240MHZ_DECR] = 240/24 = 10
- GUCTL[REF_CLK_PERIOD] = 20
- GFLADJ[GFLADJ_REFCLK_240MHZ_DECR] = 240/48 = 5
- GUCTL[REF_CLK_PERIOD] = 58
- GFLADJ[GFLADJ_REFCLK_240MHZ_DECR] = 240/17 = 14</description>
              <bitRange>[30:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GFLADJ_REFCLK_LPM_SEL</name>
              <description>This bit enables the functionality of running SOF/ITP counters on the REF_CLK.
In Device mode, setting this bit to 0x1 enables SOF tracking using REF_CLK.
Note that the REF_CLK frequencies supported in this mode are 16/17/19.2/20/24/39.7/40 MHz.
Note: If this bit is set to 0x1, the GUSB2PHYCFG0[U2_FREECLK_EXISTS] bit must be set to 0x0.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GFLADJ_REFCLK_FLADJ</name>
              <description>This bit field indicates the frame length adjustment to be applied when SOF/ITP counter is running on the REF_CLK.
The GFLADJ_REFCLK_FLADJ value is used to adjust the ITP interval when the GCTL[SOFITPSYNC] bit is set to 0x1; SOF and ITP interval when the GFLADJ_REFCLK_LPM_SEL bit is set to 0x1.
This field must be programmed to a non-zero value only if GFLADJ_REFCLK_LPM_SEL bit is set to 0x1.
The value is derived as follows:
FLADJ_REF_CLK_FLADJ = ((125000/REF_CLK_PERIOD_INTEGER) - (125000/REF_CLK_PERIOD)) x REF_CLK_PERIOD, where:
1) The REF_CLK_PERIOD_INTEGER is the integer value of the REF_CLK period got by truncating the decimal (fractional) value that is programmed in the GUCTL[REF_CLK_PERIOD] bit field.
2) The REF_CLK_PERIOD is the REF_CLK period including the fractional value.
- GUCTL[REF_CLK_PERIOD] = 41
- GFLADJ[GLADJ_REFCLK_FLADJ] = ((125000/41) - (125000/41.6666)) x 41.6666 = 2032 (ignoring the fractional value)
- GUCTL[REF_CLK_PERIOD] = 20
- GFLADJ[GLADJ_REFCLK_FLADJ] = ((125000/20) - (125000/20.8333)) x 20.8333 = 5208 (ignoring the fractional value)</description>
              <bitRange>[21:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GFLADJ_30MHZ_SDBND_SEL</name>
              <description>This field selects whether to use the FLADJ_30MHZ_REG input signal or the GFLADJ[GFLADJ_30MHZ] to adjust the frame length for the SOF/ITP. When this bit is set to:</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The controller uses the FLADJ_30MHZ_REG input signal value.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The controller uses the register field GFLADJ[GFLADJ_30MHZ] value.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GFLADJ_30MHZ</name>
              <description>This bit field indicates the value that is used for frame length adjustment instead of considering from the sideband input signal FLADJ_30MHZ_REG.
For details on how to set this value, refer to section , 'Frame Length Adjustment Register (FLADJ),' of the xHCI Specification.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GUSB2RHBCTL0</name>
          <description>Global USB 2.0 Root Hub Control Register</description>
          <addressOffset>0xC640</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OVRD_L1TIMEOUT</name>
              <description>Overriding the driver programmed L1TIMEOUT value.
If this bit is set to 0x0, the L1 Timeout value is taken from the xHCI PORTHLPMC register. If this value is non-zero, then this will override the L1 Timeout value programmed in the xHCI PORTHLPMC register. In that case the actual L1 Timeout would be 2^(OVRD_L1TIMEOUT-1) x 8 us (1 = 8 us, 2 = 16 us, 3 = 32 us and so forth).</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCFG</name>
          <description>Device Configuration Register</description>
          <addressOffset>0xC700</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00080800</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IGNSTRMPP</name>
              <description>Ignore Stream PP.
This bit only affects stream-capable bulk endpoints.
When this bit is set to 0x0 and the controller receives a Data Packet with the Packet Pending (PP) bit set to 0x0 for OUT endpoints, or it receives an ACK with the NUMP bit field set to 0x0 and PP set to 0x0 for IN endpoints, the controller attempts to search for another stream (CStream) to initiate to the host. However, there are two situations where this behavior is not optimal:
When the host is setting PP = 0 even though it has not finished the stream, or when the endpoint on the device is configured with one transfer resource and therefore does not have any other streams to initiate to the host.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LPMCAP</name>
              <description>LPM Capable.
The application uses this bit to control the LPM capabilities of the controller. If the controller operates as a non-LPM-capable device, it cannot respond to LPM transactions.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>LPM capability is not enabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>LPM capability is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NUMP</name>
              <description>Number of Receive Buffers.
This bit field indicates the number of receive buffers to be reported in the ACK TP.
For an OUT endpoint, this bit field controls the number of receive buffers reported in the NUMP bit field of the ACK TP transmitted by the controller.
Note: This bit is used in host mode when Debug Capability is enabled.</description>
              <bitRange>[21:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INTRNUM</name>
              <description>Interrupt number
Indicates interrupt/EventQ number on which non-endpoint-specific device-related interrupts (see Section Event Buffer Content for Device-Specific Events (DEVT)) are generated.</description>
              <bitRange>[16:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVADDR</name>
              <description>Device Address.
The application must perform the following:
- Program this field after every SetAddress request.
- Reset this field to zero after USB reset.</description>
              <bitRange>[9:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVSPD</name>
              <description>Device Speed.
Indicates the speed at which the application requires the controller to connect, or the maximum speed the application can support.
However, the actual bus speed is determined only after the chirp sequence is completed, and is based on the speed of the USB host to which the controller is connected.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>High-speed (USB 2.0 PHY clock is 30 MHz or 60 MHz)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Full-speed (USB 2.0 PHY clock is 30 MHz or 60 MHz)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>SuperSpeed (USB 3.0 PHY clock is 125 MHz or 250 MHz)</description>
                  <value>0x4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DCTL</name>
          <description>Device Control Register</description>
          <addressOffset>0xC704</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00F00000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RUN_STOP</name>
              <description>Run/Stop.
The software writes 0x1 to this bit to start the device controller operation.
To stop the device controller operation, the software must remove any active transfers and write 0x0 to this bit. When the controller is stopped, it sets the DSTS[DEVCTRLHLT] bit when the controller is idle and the lower layer finishes the disconnect process.
This bit must be used in following cases as specified:
- After power-on reset and CSR initialization, the software must write 0x1 to this bit to start the device controller. The controller does not signal connect to the host until this bit is set.
- The software uses this bit to control the device controller to perform a soft disconnect. When the software writes 0x0 to this bit, the host does not see that the device is connected. The device controller stays in the disconnected state until the software writes 0x1 to this bit. The minimum duration of keeping this bit cleared is specified in the Note below. If the software attempts a connect after the soft disconnect or detects a disconnect event, it must set the ULSTCHNGREQ bit field to 0x5 before reasserting the RUN_STOP bit.
- When the USB or Link is in a lower power state and the Two Power Rails configuration is selected, software writes 0x0 to this bit to indicate that it is going to turn off the Core Power Rail. After the software turns on the Core Power Rail again and re-initializes the device controller, it must set this bit to start the device controller. For more details, see Section Low Power Operation of Controller.
Note: The following is the minimum duration for which the soft disconnect (SftDiscon) bit must be set for the USB host to detect a device disconnect.
10 ms: 
1) For high-speed, when the device state is Suspended, Idle, or not Idle/Suspended (performing transactions).
2) For full-speed/low-speed, when the device state is Suspended, Idle, or not Idle/Supended (performing transactions).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CSFTRST</name>
              <description>Core Soft Reset.
Resets the all clock domains as follows:
This bit clears the interrupts and all the CSRs except the GSTS, GSNPSID, GUID, GUSB2PHYCFG0, DCFG, DCTL, DEVTEN, and DSTS registers.
All module state machines (except the SoC Bus Slave Unit) are reset to the IDLE state, and all the TxFIFOs and the RxFIFO are flushed.
Any transactions on the SoC bus Master are terminated as soon as possible, after gracefully completing the last data phase of a SoC bus transfer. Any transactions on the USB are terminated immediately.
Note: Programming this field with random data causes side effect. Bit Bash register testing is not recommended.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>HIRDTHRES</name>
              <description>HIRD Threshold (HIRD_Thres).
The controller asserts output signals utmi_l1_suspend_n and utmi_sleep_n on the basis of this signal.
The controller asserts utmi_l1_suspend_n to put the PHY into Deep Low-Power mode in L1 when both of the following are true:
- HIRD value is greater than or equal to the value of bits 3-1 in the DCTL[HIRDTHRES] bit field and the value of bit 4 in the DCTL[HIRDTHRES] is set to 0x1.
The controller asserts utmi_sleep_n on L1 when one of the following is true: 
- If the HIRD value is less than the value of bits 3-1 in the DCTL[HIRDTHRES] bit field or the value of bit 4 in the DCTL[HIRDTHRES] is set to 0x0.</description>
              <bitRange>[28:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LPM_NYET_THRES</name>
              <description>LPM NYET Threshold.
When LPM Errata is enabled:
Handshake response to LPM token specified by device application. Response depends on the DCFG[LPMCAP] bit.
1) DCFG[LPMCAP] bit is 0x0: the controller always responds with Timeout (that is, no response).
2) DCFG[LPMCAP] bit is 0x1: the controller responds with an ACK on successful LPM transaction, which requires that all of the following are satisfied:
- There are no PID or CRC5 errors in both the EXT token and the LPM token (if not true, inactivity results in a timeout ERROR).
- No data is pending in the TxFIFO and RxFIFO is empty (else NYET).
- The BESL value in the LPM token is less than or equal to the LPM_NYET_THRES bit field.</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>KEEPCONNECT</name>
              <description>Keep Connect.
Note: If Hibernation is disabled, that is, GCTL[GBLHIBERNATIONEN] = 0x0, this bit is tied to zero.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>L1HIBERNATIONEN</name>
              <description>L1 Hibernation Enable.
Note: If Hibernation is disabled, that is, GCTL[GBLHIBERNATIONEN] = 0x0, this bit is tied to zero.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CRS</name>
              <description>Controller Restore State (CRS).
This command is similar to the USBCMD[CRS] bit in Host mode and initiates the restore process. When software sets this bit to 0x1, the controller immediately sets the DSTS[RSS] bit to 0x1. When the controller has finished the restore process, it sets the DSTS[RSS] bit to 0x0.
Note: When read, this field always returns 0x0.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CSS</name>
              <description>Controller Save State (CSS).
This command is similar to the USBCMD[CSS] bit in host mode and initiates the save process. When software sets this bit to 0x3, the controller immediately sets the DSTS[SSS] bit to 0x1. When the controller has finished the save process, it sets the DSTS[SSS] bit to 0x0.
Note: When read, this field always returns 0x0.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ULSTCHNGREQ</name>
              <description>USB/Link state change request.
Software writes this bit field to issue a USB/Link state change request. A change in this bit field indicates a new request to the controller.
If software wants to issue the same request back-to-back, it must write a 0x0 to this bit field between the two requests. The result of the state change request is reflected in the USB/Link State in the DSTS register. These bits are self-cleared on the MAC Layer exiting suspended state.
If software is updating other fields of the DCTL register and not intending to force any link state change, then it must write a 0x0 to this field.
If the user writes 0x2 to the USB/Link State Change field and 0x1 to RUN/STOP, the link goes to compliance mode.
Once you are in compliance, you may alternately write zero and '10' to this field to advance the compliance pattern.
ValueRequested USB state transition
8 Remote wakeup request
Others: Reserved</description>
              <bitRange>[8:5]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>TSTCTL</name>
              <description>Test Control.
Others: Reserved</description>
              <bitRange>[4:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Test mode disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Test_J mode</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Test_K mode</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Test_SE0_NAK mode</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Test_Packet mode</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>Test_Force_Enable</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DEVTEN</name>
          <description>Device Event Enable Register</description>
          <addressOffset>0xC708</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ECCERREN</name>
              <description>ECC Error Enable.
If this bit is set to 0x1, the controller reports an ECC error to the software when an uncorrectable ECC occurs internally.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>L1WKUPEVTEN</name>
              <description>L1 Resume Detected Event Enable.
Note: If the GUCTL1[DEV_DECOUPLE_L1L2_EVT] bit is enabled, then this bit is for L1 Resume Detected Event Enable.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VENDEVTSTRCVDEN</name>
              <description>Vendor Device Test LMP Received Event</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERRTICERREVTEN</name>
              <description>Erratic Error Event Enable.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>L1SUSPEN</name>
              <description>L1 Suspend Event Enable
Note: Only if the GUCTL1[DEV_DECOUPLE_L1L2_EVT] bit is enabled, this bit is for L1 Suspend Event Enable.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SOFTEVTEN</name>
              <description>Start of (micro)frame.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>U3L2L1SUSPEN</name>
              <description>L2 or L2L1 Suspend Event Enable.
Note:
1) If the GUCTL1[DEV_DECOUPLE_L1L2_EVT] bit is enabled, then this bit is for L2 Suspend Event Enable.
2) If the GUCTL1[DEV_DECOUPLE_L1L2_EVT] bit is not enabled, then this bit is for L2L1 Suspend Event Enable.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIBERNATIONREQEVTEN</name>
              <description>This bit enables/disables the generation of the Hibernation Request Event.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WKUPEVTEN</name>
              <description>L2 or L2L1 Resume Detected Event Enable.
Note:
1) If the GUCTL1[DEV_DECOUPLE_L1L2_EVT] bit is enabled, then this bit is for L2 Resume Detected Event Enable.
2) If the GUCTL1[DEV_DECOUPLE_L1L2_EVT] bit is not enabled, then this bit is for L2L1 Resume Detected Event Enable.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ULSTCNGEN</name>
              <description>USB/Link State Change Event Enable.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CONNECTDONEEVTEN</name>
              <description>Connection Done Enable.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USBRSTEVTEN</name>
              <description>USB Reset Enable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISSCONNEVTEN</name>
              <description>Disconnect Detected Event Enable.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSTS</name>
          <description>Device Status Register</description>
          <addressOffset>0xC70C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00D20001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DCNRD</name>
              <description>Device Controller Not Ready (not used).</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SRE</name>
              <description>Save Restore Error. Currently not supported.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>RSS</name>
              <description>RSS Restore State Status.
This bit is similar to the USBSTS[RSS] bit in Host mode.
When the controller finishes the restore process, it completes the command by setting the RSS bit to 0x0.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SSS</name>
              <description>SSS Save State Status.
This bit is similar to the USBSTS[SSS] in host mode.
When the controller has finished the save process, it completes the command by setting the SSS bit to 0x0.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>COREIDLE</name>
              <description>Core Idle.
The bit indicates that the controller finished transferring all RxFIFO data to system memory, writing out all completed descriptors, and all Event Counts are zero.
Note: While testing for Reset values, mask out the read value. This bit represents the changing state of the controller and does not hold a static value.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DEVCTRLHLT</name>
              <description>Device Controller Halted.
This bit is set to 0x0 when the DCTL[RUN_STOP] bit is set to 0x1.
The controller sets this bit to 0x1 when, after software sets the DCTL[RUN_STOP] bit to 0x0, the controller is idle and the lower layer finishes the disconnect process.
When this bit is set to 0x1, the controller does not generate Device events.
Note: The controller does not set this bit to 0x1 if the GEVNTCOUNT0 register has some valid value. Software needs to acknowledge the events that are generated (by writing to the GEVNTCOUNT0 register) while it is waiting for this bit to be set to 0x1.
When Interrupt Moderation is enabled, there could be delay in raising the interrupt line when the event count is non-zero. Software should read the GEVNTCOUNT0 register directly and acknowledge them.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>USBLNKST</name>
              <description>USB/Link State.
When Hibernation is enabled, the GCTL[GBLHIBERNATIONEN] = 0x1, the USBLNKST bit field is valid only when the DCTL[RUN_STOP] bit is set to 0x1 and the DCNRD = 0x0.
The Early Suspend link state is an early indication of device suspend in HS/FS. The link state changes to Early Suspend after detecting bus idle for 3 ms.
In HS operation, this is an indication that the USB bus (that is, LineState) has been in idle (SE0) for 3 ms. However, it does not confirm whether the next process is Suspend or Reset. The device checks the bus again after pull up enable delay and if the line state indicates Suspend (full speed J), then the device waits for an additional time (~3 ms) to indicate the actual Suspend state.
In FS operation, this is an indication that the USB bus (that is, LineState) has been in idle (J) for 3 ms. The device waits for an additional time (~3 ms of Idle) to indicate the actual Suspend state.</description>
              <bitRange>[21:18]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>On state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Sleep (L1) state</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Suspend (L2) state</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Disconnected state (Default state)</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>Early Suspend state (valid only when Hibernation is disabled, the GCTL[GBLHIBERNATIONEN] = 0x0)</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xE</name>
                  <description>Reset (valid only when Hibernation is enabled, the GCTL[GBLHIBERNATIONEN] = 0x1)</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description>Resume (valid only when Hibernation is enabled, the GCTL[GBLHIBERNATIONEN] = 0x1)</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFIFOEMPTY</name>
              <description>RxFIFO Empty.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SOFFN</name>
              <description>Frame/Microframe Number of the Received SOF.
Bits 16-14 are not used. Software can ignore these 3 bits.
Bits 13-3 indicate the frame number.
Note: After power-on reset, the controller generates the microframe number internally for every 125 us if the USB host has not issued SOF/ITP yet. During P3 state, the duration of SOFFN is based on the SUSPEND_CLK frequency.</description>
              <bitRange>[16:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CONNECTSPD</name>
              <description>Connected Speed.
Indicates the speed at which the USB controller has come up after speed detection through a chirp sequence.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>High-speed (PHY clock is running at 30 or 60 MHz)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Full-speed (PHY clock is running at 30 or 60 MHz)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>SuperSpeed (PHY clock is running at 125 or 250 MHz)</description>
                  <value>0x4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DGCMDPAR</name>
          <description>Device Generic Command Parameter Register</description>
          <addressOffset>0xC710</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PARAMETER</name>
              <description>PARAMETER</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DGCMD</name>
          <description>Device Generic Command Register</description>
          <addressOffset>0xC714</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMDSTATUS</name>
              <description>Command Status.</description>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Indicates command success</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Indicates that the device controller encountered an error while processing the command.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMDACT</name>
              <description>Command Active.
The software sets this bit to 0x1 to enable the device controller to execute the generic command.
The device controller sets this bit to 0x0 after executing the command.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>CMDIOC</name>
              <description>Command Interrupt on Complete.
When this bit is set, the device controller issues a Generic Command Completion event after executing the command.
Note that this interrupt is mapped to the DCFG[INTRNUM] bit field.
Note: This field must not set to 0x0 if the DCTL[RUN_STOP] bit is set to 0x0.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMDTYP</name>
              <description>Generic Command Type.
Specifies the type of generic command the software driver is requesting the controller to perform.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Set Periodic Parameters</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Set Scratchpad Buffer Array Address Lo</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>Set Scratchpad Buffer Array Address Hi</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>Transmit Device Notification</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>Selected FIFO Flush</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>All FIFO Flush</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>Set Endpoint NRDY</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x10</name>
                  <description>Run SoC Bus LoopBack Test</description>
                  <value>0x10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x11</name>
                  <description>Restart After Disconnect</description>
                  <value>0x11</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DALEPENA</name>
          <description>Device Active USB Endpoint Enable Register</description>
          <addressOffset>0xC720</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>USBACTEP</name>
              <description>USB Active Endpoints.
This field indicates if a USB endpoint is active in the current configuration and interface. It applies to USB IN endpoints 0.15 and OUT endpoints 0.15, with one bit for each of the 32 possible endpoints. Even numbers are for USB OUT endpoints, and odd numbers are for USB IN endpoints, as follows:
- Bit[0]: USB EP0-OUT
- Bit[1]: USB EP0-IN
- Bit[2]: USB EP1-OUT
- Bit[3]: USB EP1-IN
The entity programming this register must set bits 0x0 and 0x1 because they enable control endpoints that map to physical endpoints (resources) after USBReset. Hardware clears these bits for all endpoints (other than EP0-OUT and EP0-IN) after detecting a USB reset event. After receiving SetConfiguration and SetInterface requests, the application must program endpoint registers accordingly and set these bits.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>16</dim>
          <dimIncrement>16</dimIncrement>
          <name>USB_ENDPNT_CMD[%s]</name>
          <addressOffset>0xC800</addressOffset>
          <register>
            <name>DEPCMDPAR2</name>
            <description>Device Physical Endpoint-n Command Parameter 2 Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PARAMETER</name>
                <description>PARAMETER</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEPCMDPAR1</name>
            <description>Device Physical Endpoint-n Command Parameter 1 Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PARAMETER</name>
                <description>PARAMETER</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEPCMDPAR0</name>
            <description>Device Physical Endpoint-n Command Parameter 0 Register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PARAMETER</name>
                <description>PARAMETER</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEPCMD</name>
            <description>Device Physical Endpoint-n Command Register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>COMMANDPARAM</name>
                <description>Command Parameters or Event Parameters.
When this register is written:
1) For Start Transfer command:
- Bits [31-16]: StreamID. The USB StreamID assigned to this transfer
2) For Start Transfer command applied to an isochronous endpoint:
- Bits [31-16]: StartMicroFramNum: Indicates the (micro)frame number to which the first TRB applies.
3) For Update Transfer, End Transfer, and Start New Configuration commands:
- Bits [22-16]: Transfer Resource Index (XferRscIdx). The hardware-assigned transfer resource index for the transfer, which was returned in response to the Start Transfer command. The application software-assigned transfer resource index for a Start New Configuration command.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMDSTATUS</name>
                <description>Command Completion Status.
Additional information about the completion of this command is available in this bit field. The information is in the same format as bits 15-12 of the Endpoint Command Complete event, see Section Event Buffer Content for Device Endpoint-Specific Events (DEPEVT).</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HIPRI_FORCERM</name>
                <description>HighPriority/ForceRM
HighPriority: Only valid for Start Transfer command
ForceRM: Only valid for End Transfer command
ClearPendIN: Only valid for Clear Stall command . Software sets this bit to clear any pending IN transaction (on that endpoint) stuck at the lower layers when a Clear Stall command is issued.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMDACT</name>
                <description>Command Active.
Software sets this bit to 0x1 to enable the device endpoint controller to execute the generic command.
The device controller sets this bit to 0x0 when the CMDSTATUS bit field is valid and the endpoint is ready to accept another command. This does not imply that all the effects of the previously-issued command have taken place.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMDIOC</name>
                <description>Command Interrupt on Complete.
When this bit is set, the device controller issues a generic Endpoint Command Complete event after executing the command.
Note that this interrupt is mapped to the INTRNUM bit field.
When the DEPCFG command is executed, the command interrupt on completion goes to the interrupt pointed by the INTRNUM bit field in the current command.
Note: This field must not be set to 0x1 if the DCTL[RUN_STOP] bit is 0x0.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMDTYP</name>
                <description>Command Type.
Specifies the type of command the software driver is requesting the controller to perform.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Set Endpoint Configuration: 64- or 96-bit Parameter</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Set Endpoint Transfer Resource Configuration: 32-bit Parameter</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Get Endpoint State: No Parameter Needed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x4</name>
                    <description>Set Stall: No Parameter Needed</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x5</name>
                    <description>Clear Stall (see Set Stall): No Parameter Needed</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x6</name>
                    <description>Start Transfer: 64-bit Parameter</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x7</name>
                    <description>Update Transfer: No Parameter Needed</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x8</name>
                    <description>End Transfer: No Parameter Needed</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x9</name>
                    <description>Start New Configuration: No Parameter Needed</description>
                    <value>0x9</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>DEV_IMOD0</name>
          <description>Device Interrupt Moderation Register</description>
          <addressOffset>0xCA00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DEVICE_IMODC</name>
              <description>Interrupt Moderation Down Counter.
Loaded with the DEVICE_IMODI value, whenever the hardware interrupt(n) line is de-asserted from the asserted state, counts down to 0, and stops.
The interrupt is signaled whenever this counter is 0, the GEVNTCOUNT0[EVNT_HANDLER_BUSY] bit is 0x0, and there are pending events (that is, event count is non-zero).
This counter may be directly written by software at any time to alter the interrupt rate.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVICE_IMODI</name>
              <description>Moderation Interval.
This bit field holds the minimum inter-interrupt interval between events. The interval is specified in terms of 250-ns increments.
A value of 0 disables the interrupt throttling logic and interrupts are generated immediately if event count becomes non-zero.
In scaledown simulation mode, 4 RAM clocks are used to time 250 ns.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="LPGPIO">
      <name>GPIO0</name>
      <baseAddress>0x49000000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LPGPIO">
      <name>GPIO1</name>
      <baseAddress>0x49001000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LPGPIO">
      <name>GPIO2</name>
      <baseAddress>0x49002000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LPGPIO">
      <name>GPIO3</name>
      <baseAddress>0x49003000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LPGPIO">
      <name>GPIO4</name>
      <baseAddress>0x49004000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LPGPIO">
      <name>GPIO5</name>
      <baseAddress>0x49005000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LPGPIO">
      <name>GPIO6</name>
      <baseAddress>0x49006000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LPGPIO">
      <name>GPIO7</name>
      <baseAddress>0x49007000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LPGPIO">
      <name>GPIO8</name>
      <baseAddress>0x49008000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LPGPIO">
      <name>GPIO9</name>
      <baseAddress>0x49009000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LPGPIO">
      <name>GPIO10</name>
      <baseAddress>0x4900A000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LPGPIO">
      <name>GPIO11</name>
      <baseAddress>0x4900B000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LPGPIO">
      <name>GPIO12</name>
      <baseAddress>0x4900C000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LPGPIO">
      <name>GPIO13</name>
      <baseAddress>0x4900D000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LPGPIO">
      <name>GPIO14</name>
      <baseAddress>0x4900E000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LPI2C1">
      <name>I2C0</name>
      <baseAddress>0x49010000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LPI2C1">
      <name>I2C1</name>
      <baseAddress>0x49011000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LPI2C1">
      <name>I2C2</name>
      <baseAddress>0x49012000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LPI2C1">
      <name>I2C3</name>
      <baseAddress>0x49013000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LPI2S">
      <name>I2S0</name>
      <baseAddress>0x49014000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LPI2S">
      <name>I2S1</name>
      <baseAddress>0x49015000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LPI2S">
      <name>I2S2</name>
      <baseAddress>0x49016000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LPI2S">
      <name>I2S3</name>
      <baseAddress>0x49017000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LPUART">
      <name>UART0</name>
      <baseAddress>0x49018000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LPUART">
      <name>UART1</name>
      <baseAddress>0x49019000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LPUART">
      <name>UART2</name>
      <baseAddress>0x4901A000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LPUART">
      <name>UART3</name>
      <baseAddress>0x4901B000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LPUART">
      <name>UART4</name>
      <baseAddress>0x4901C000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LPUART">
      <name>UART5</name>
      <baseAddress>0x4901D000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LPUART">
      <name>UART6</name>
      <baseAddress>0x4901E000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LPUART">
      <name>UART7</name>
      <baseAddress>0x4901F000</baseAddress>
    </peripheral>
    <peripheral>
      <name>ADC120</name>
      <groupName>ADC12</groupName>
      <baseAddress>0x49020000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>116</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ADC_START_SRC</name>
          <description>ADC Start-of-Conversion Source Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ENA</name>
              <description>When this bit is set to 1, the ADC_CONTROL register is enabled to start the processing.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>START</name>
              <description>When this bit is set to 1, the ADC starts/continues its operation. This is used to enable functions by software, without using the event inputs.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>START_SRC</name>
              <description>This bit field enables the corresponding event input to the ADC to start (and continue, if active) the ADC. Once the number samples programmed in ADC_AVG_NUM is reached, if one of the enabled event inputs is active, the ADC functionality continues. If not, it stops.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_COMP_THRESH_A</name>
          <description>ADC Comparator Threshold A Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMP_THRESHOLD_A</name>
              <description>Comparison threshold A value. Used for interrupt generation.
The programmed value should be equal to the desired threshold multiplied by the number of samples set in ADC_AVG_NUM.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_COMP_THRESH_B</name>
          <description>ADC Comparator Threshold B Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMP_THRESHOLD_B</name>
              <description>Comparison threshold B value. Used for interrupt generation.
The programmed value should be equal to the desired threshold multiplied by the number of samples set in ADC_AVG_NUM.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_CLK_DIVISOR</name>
          <description>ADC Clock Divider Value Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLK_DIVISOR</name>
              <description>Clock divider applied to input clock:
Others: Reserved</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Divide by 2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Divide by 3</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x10</name>
                  <description>Divide by 16</description>
                  <value>0x10</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_INTERRUPT</name>
          <description>ADC Interrupt Status and Clear Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>AVG_CALC_THRESH_1</name>
              <description>Status and clear for CMPB interrupt.
Read 1: A threshold passed depending on ADC_CONTROL[INT_CTRL] register field. 
Write 1 to clear.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>AVG_CALC_THRESH_0</name>
              <description>Status and clear for CMPA interrupt.
Read 1: A threshold passed depending on ADC_CONTROL[INT_CTRL] register field. 
Write 1 to clear.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>ALL_SAMPLES_TAKEN</name>
              <description>Status and clear for DONE1 interrupt.
Read 1: All samples taken. Data collection has now stopped with the final loading of a ADC_SAMPLE_REG_n register, due to either turning off ADC_START_SRC[START] for continuous operation, or ADC_CONTROL[START] one-time run has finished, or windowing event is no longer active.
Write 1 to clear.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>AVG_SAMPLE_RDY</name>
              <description>Status and clear for DONE0 interrupt.
Read 1: Analog logic has delivered the number of samples set in the ADC_AVG_NUM register, indicating that the current ADC_SAMPLE_REG_n has been loaded.
Write 1 to clear.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_INTERRUPT_MASK</name>
          <description>ADC Interrupt Mask Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000000F</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>AVG_CALC_THRESH_1</name>
              <description>Mask for CMPB interrupt.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AVG_CALC_THRESH_0</name>
              <description>Mask for CMPA interrupt.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALL_SAMPLES_TAKEN</name>
              <description>Mask for DONE1 interrupt.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AVG_SAMPLE_RDY</name>
              <description>Mask for DONE0 interrupt.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_SAMPLE_WIDTH</name>
          <description>ADC Sampling Signal Duration Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SAMPLE_HOLD</name>
              <description>Used in ADC24. If 1, the Sample signal is continuously active while gathering data.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_WIDTH</name>
              <description>Duration of the Sample signal to ADC analog frond-end in PCLK clocks. Valid values are 2 to 32.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_AVG_NUM</name>
          <description>ADC Number of Samples for Averaging Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AVG_NUM</name>
              <description>Program up to 256 number of samples to collect. The result is loaded into the sample registers (ADC_SAMPLE_REG_n). The programmed value must be a power of 2. The minimum supported value is: 2 for ADC12, 1 for ADC24.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_SHIFT_CONTROL</name>
          <description>ADC Data Shift Select Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SHIFT_DIR</name>
              <description>Shift averaged value before loading into the sample registers (ADC_SAMPLE_REG_n):</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Shift averaged value left</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Shift averaged value right</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SHIFT_CONTROL</name>
              <description>Shift these bits before loading value into the sample registers (ADC_SAMPLE_REG_n). To calculate the sample average, program this bit field with the number of bits to shift right based upon the number of samples taken:
1 sample: no shift
2 samples: shift right 1 bit
4 samples: shift right 2 bits
256 samples: shift right 8 bits
If any additional shift left or right is desired it should be added to or subtracted from the averaging shift above, and the resulting value programmed into this register.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_CONTROL</name>
          <description>ADC Single-shot Conversion Start and Comparator Threshold Mode Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INT_CTRL</name>
              <description>This field specifies the threshold windows for CMPA and CMPB interrupt generation. </description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>CMPA = Above threshold A value; CMPB = Above threshold B value.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CMPA = Below threshold A value; CMPB = Below threshold B value.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>CMPA = Between threshold A and B values; CMPB = Outside threshold A and B values.</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SAMPLE_INT_CLEAR</name>
              <description>If set, enables mode where reading any ADC_SAMPLE_REG_n will clear all active interrupts.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>If 1, indicates ADC is processing data.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>START</name>
              <description>Write 1: Starts the ADC process. This is one-time start control. If the number of programmed samples is reached, processing stops, unless another event causes it to continue. For START bit to be operational the ADC_START_SRC[ENA] must be 1.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_SEQUENCER_CTRL</name>
          <description>ADC Sequencer Control Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0001FFFF</resetMask>
          <fields>
            <field>
              <name>MODE</name>
              <description>Sequencer mode:</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Sequencer loops over all 9 analog inputs, while skipping masked inputs (set in the MASKED bit field). For ADC24, it loops over the lower 4 inputs.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Sequencer is fixed at SEQUENCER_INIT field value.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEQUENCER_INIT</name>
              <description>Initial value (analog input index) of sequencer to use when started. This must be set to an unmasked input.</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASKED</name>
              <description>Masked analog inputs are skipped when advancing the sequencer. Each bit corresponds to an analog input. Set a bit to 1 to mask the corresponding input. For ADC24, only the lower 4 inputs are used; the upper 5 inputs are automatically masked.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_REG1</name>
          <description>ADC Analog Control Register for ADC12 Modules</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AMUX_CONT</name>
              <description>Analog test mux control (external to ADC12). 
Bit 31 is a master enable (set to 1 to enable AMUX).
Upper 4 bits determine mux section [30:27].
Lower 3 bits select mux input [26:24]. 
 Default = 0x0</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC12_VCM_RDIV_EN</name>
              <description>Enable ADC12 resistive divider:</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The resistive divider is off, common mode is not well defined</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description> The resistive divider is on, common mode is VDD/2</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC12_COMPARATOR_BIAS</name>
              <description>ADC12 comparator biasing:</description>
              <bitRange>[4:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>0.5 MS/s (Power optmization with lower sample rate)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>1 MS/s</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>2.5 MS/s </description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>5 MS/s</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC12_COMPARATOR_EN</name>
              <description>Enable ADC12 comparator:</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description> Comparator is off</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Comparator is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC12_DIFFERENTIAL_EN</name>
              <description>Enable ADC12 differential mode: </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>IN0, IN1, IN2, IN3, IN4, and IN5 are single-ended inputs</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>IN0/IN1, IN2/IN3, and IN4/IN5 make 3 differential inputs</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC12_TEST_EN</name>
              <description>Enable ADC12 test signal to go to the test MUX:</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_SEL</name>
          <description>ADC Sample Register Selected (read-only value of n)</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SAMPLE_REG_NUM</name>
              <description>Indicates the current ADC_SAMPLE_REG_n number to be loaded with an ADC result.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_PERIPH</name>
          <description>ADC Peripheral Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00408001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADC24_BIAS</name>
              <description>ADC24 bias control.
This field is functional only for ADC24.</description>
              <bitRange>[22:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC24_OUTPUT_RATE</name>
              <description>ADC24 output rate select:
Other values should not be used.
This field is functional only for ADC24.</description>
              <bitRange>[15:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b000</name>
                  <description>1 kS/s</description>
                  <value>0b000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b001</name>
                  <description>2 kS/s</description>
                  <value>0b001</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b010</name>
                  <description>4 kS/s</description>
                  <value>0b010</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b011</name>
                  <description>8 kS/s</description>
                  <value>0b011</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b100</name>
                  <description>16 kS/s</description>
                  <value>0b100</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC12_PGA_GAIN</name>
              <description>ADC12 PGA gain value select:
Other values should not be used.
This field is functional only for an ADC12 module.</description>
              <bitRange>[3:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b000</name>
                  <description>4 dB</description>
                  <value>0b000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b001</name>
                  <description>8 dB</description>
                  <value>0b001</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b100</name>
                  <description>12 dB</description>
                  <value>0b100</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b101</name>
                  <description>16 dB</description>
                  <value>0b101</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b110</name>
                  <description>20 dB</description>
                  <value>0b110</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC12_PGA_EN</name>
              <description>ADC12 PGA enable
Note: ADC must be put into differential mode when PGA is enabled.
This bit is functional only for an ADC12 module.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <dim>9</dim>
          <dimIncrement>4</dimIncrement>
          <name>ADC_SAMPLE_REG_[%s]</name>
          <description>ADC Sampled Value From Input n Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>Result of ADC operation on input n.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="ADC120">
      <name>ADC121</name>
      <baseAddress>0x49021000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="ADC120">
      <name>ADC122</name>
      <baseAddress>0x49022000</baseAddress>
    </peripheral>
    <peripheral>
      <name>CMP0</name>
      <groupName>CMP</groupName>
      <baseAddress>0x49023000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>40</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CMP_COMP_REG1</name>
          <description>CMP Control Register 1</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMP_HS_EN</name>
              <description>Enables High-Speed CMP:</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description> Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description> Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COMP_HS_HYST</name>
              <description>Sets CMP hysteresis level. 6-mV steps.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>0 mV</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>45 mV</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COMP_HS_IN_M_SEL</name>
              <description>Selects input to negative terminal of CMP:</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description> VREF_IN0 pin</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>VREF_IN1 pin</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Internal Vref</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>DAC6</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COMP_HS_IN_P_SEL</name>
              <description>Selects input to positive terminal of CMP:</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description> CMPx_IN0 pin</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CMPx_IN1 pin</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>CMPx_IN2 pin</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>CMPx_IN3 pin</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP_COMP_REG2</name>
          <description>CMP Control Register 2</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DAC6_VREF_SCALE</name>
              <description>Allows you to scale the input reference to the DAC6.
Step Size = 1/16</description>
              <bitRange>[30:27]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1x </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description> 2x</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DAC6_CONT</name>
              <description>This is the output of DAC6 programmable reference voltage. DAC6 Output = (DAC6_VREF_SCALE x DAC6_CONT) / 64</description>
              <bitRange>[26:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DAC6_EN</name>
              <description>DAC6 Enable. DAC6 takes an input reference and generates a 6-bit programmable output voltage reference.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DAC12_VREF_CONT</name>
              <description>Voltage reference values for DAC12</description>
              <bitRange>[19:17]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b000</name>
                  <description>0.500 V</description>
                  <value>0b000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b001</name>
                  <description>0.667 V</description>
                  <value>0b001</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b010</name>
                  <description>0.667 V</description>
                  <value>0b010</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b011</name>
                  <description>0.750 V</description>
                  <value>0b011</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b100</name>
                  <description>0.750 V (Default)</description>
                  <value>0b100</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b101</name>
                  <description>0.800 V</description>
                  <value>0b101</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b110</name>
                  <description>0.800 V</description>
                  <value>0b110</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b111</name>
                  <description>0.833 V</description>
                  <value>0b111</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC_VREF_BUF_RDIV_EN</name>
              <description>ADC Vref divider enable</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Vref = 1.8 V</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Vref = 1.5 V</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC_VREF_BUF_EN</name>
              <description>ADC Vref buffer enable. Turn off if external VREF is connected.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>ADC Vref is off</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ADC Vref is on</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC_VREF_CONT</name>
              <description>Control for ADC Vref (desired 1.8 V): 1.8 V +- 100 mV, where:
 Step size = 7 mV</description>
              <bitRange>[14:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b00000</name>
                  <description>-100 mV</description>
                  <value>0b00000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b11111</name>
                  <description>100 mV</description>
                  <value>0b11111</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b10000</name>
                  <description>1.8 V = Default (0x10)</description>
                  <value>0b10000</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ANA_PERIPH_LDO_CONT</name>
              <description>Analog peripheral LDO (LDO-5) output voltage (VDD_ANA):
 Step: 20 mV</description>
              <bitRange>[9:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b0000</name>
                  <description>1.6 V</description>
                  <value>0b0000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1111</name>
                  <description>1.9 V</description>
                  <value>0b1111</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1010</name>
                  <description>1.8 V = Default (0xA)</description>
                  <value>0b1010</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ANA_PERIPH_BG_CONT</name>
              <description>Calibration for analog peripherals precision bandgap (desired 1.2 V):
 Step: 6 mV</description>
              <bitRange>[4:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b0000</name>
                  <description> 1.140 V</description>
                  <value>0b0000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1111</name>
                  <description> 1.233 V</description>
                  <value>0b1111</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1010</name>
                  <description>1.200 V = Default (0xA)</description>
                  <value>0b1010</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP_POLARITY_CTRL</name>
          <description>CMP Polarity Control Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POLARITY_CTRL</name>
              <description>If = 0x1, invert the value of CMP_OUT (comparison result) before processing.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP_WINDOW_CTRL</name>
          <description>CMP Window Control Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EVENTS_IN</name>
              <description>Selects which of the 4 inputs will control the processing window.
</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WINDOW_CTRL</name>
              <description>Window function control bit.
Note: Bits WINDOW_CTRL and WINDOW_EN must be both set to use windowing function.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Continously process comparator inputs.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Use the EVENTS_IN bit field setting. Selected input will control when to look at comparator inputs.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WINDOW_EN</name>
              <description>Window function enable bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Continously process comparator inputs.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Use the EVENTS_IN bit field setting. Selected input will control when to look at comparator inputs.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP_FILTER_CTRL</name>
          <description>CMP Filter Control Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NUM_TAPS</name>
              <description>Number of filter taps, 2-8 taps.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Filtering function enable bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP_PRESCALER_CTRL</name>
          <description>CMP Prescaler Control Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRESCALER_CTRL</name>
              <description>Number of clocks between updating taps with new comparator input.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP_STATUS</name>
          <description>CMP Status Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMP_VALUE</name>
              <description>Current value of the input comparator value from the PMU after synchronization.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP_INTERRUPT_STATUS</name>
          <description>CMP Interrupt Status and Clear Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FILTER_EVENT</name>
              <description>FILTER_EVENT interrupt status and clear.
When read as 1: Filter event occurred for the programmed number of taps. 
Write 1 to clear.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP_INTERRUPT_MASK</name>
          <description>CMP Interrupt Mask Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FILTER_EVENT</name>
              <description>Mask for the FILTER_EVENT interrupt.
Note: By default, interrupt mask is set. Mask must be cleared to allow interrupt to be driven out.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clear mask</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Set mask</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="CMP0">
      <name>CMP1</name>
      <baseAddress>0x49024000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="CMP0">
      <name>CMP2</name>
      <baseAddress>0x49025000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="CMP0">
      <name>CMP3</name>
      <baseAddress>0x49026000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="ADC120">
      <name>ADC24</name>
      <baseAddress>0x49027000</baseAddress>
    </peripheral>
    <peripheral>
      <name>DAC120</name>
      <groupName>DAC12</groupName>
      <baseAddress>0x49028000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>DAC_REG1</name>
          <description>REG1 DAC Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x08001FFD</resetValue>
          <resetMask>0xF8783FFF</resetMask>
          <fields>
            <field>
              <name>DAC_RESET_B</name>
              <description>DAC reset:</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Reset asserted</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description> Reset released</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DAC_IBIAS</name>
              <description>Trims buffer output current (HP mode):
From 0000 = 0 uA to 1111 = 1.5 mA
 Default is 1111 for DAC120 and 0000 for DAC121
 Step size ~100 uA</description>
              <bitRange>[26:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DAC_TWOSCOMP_EN</name>
              <description>Converts two's complement to unsigned binary data: </description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description> Input data is unsigned</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description> Input data is two's complement signed (conversion to unsigned enable)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DAC_HP_MODE_EN</name>
              <description>DAC high-performance mode enable.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Low-power (LP) mode (default for DAC121)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>High-performance (HP) mode (default for DAC120)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DAC_CAP_CONT</name>
              <description>Trims HP mode capacitance compensation: 
From xx00 = 2 pF to xx11 = 8 pF
 Step size = 2 pF
Default is xx11 = 8 pF for DAC120 and xx00 for DAC121
Bits [17-16] = Don't care</description>
              <bitRange>[17:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DAC_BYP_VAL</name>
              <description>DAC input data in bypass mode</description>
              <bitRange>[13:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DAC_INPUT_BYP_MUX_EN</name>
              <description>Selects DAC input data source:</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DAC_IN register</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DAC_REG1[DAC_BYP_VAL] bitfield (bypass mode)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DAC_EN</name>
              <description>DAC enable:</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DAC is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DAC is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_IN</name>
          <description>DAC Input Value Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>Value used by DAC analog portion for conversion.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="DAC120">
      <name>DAC121</name>
      <baseAddress>0x49029000</baseAddress>
    </peripheral>
    <peripheral>
      <name>DAC6</name>
      <baseAddress>0x4902A000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>DAC6_REG</name>
          <description>DAC6 Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DAC6_VREF_SCALE</name>
              <description>Allows you to scale the input reference to the DAC6.
Step Size = 1/16</description>
              <bitRange>[30:27]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1x </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description> 2x</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DAC6_CONT</name>
              <description>This is the output of DAC6 programmable reference voltage. DAC6 Output = (DAC6_VREF_SCALE x DAC6_CONT) / 64</description>
              <bitRange>[26:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DAC6_EN</name>
              <description>DAC6 Enable. DAC6 takes an input reference and generates a 6-bit programmable output voltage reference.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>ADC_VREF</name>
      <baseAddress>0x4902B000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ADC_VREF_REG</name>
          <description>ADC_VREF Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADC_VREF_BUF_RDIV_EN</name>
              <description>ADC Vref divider enable</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Vref = 1.8 V</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Vref = 1.5 V</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC_VREF_BUF_EN</name>
              <description>ADC Vref buffer enable. Turn off if external VREF is connected.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>ADC Vref is off</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ADC Vref is on</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC_VREF_CONT</name>
              <description>Control for ADC Vref (desired 1.8 V): 1.8 V +- 100 mV, where:
 Step size = 7 mV</description>
              <bitRange>[14:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b00000</name>
                  <description>-100 mV</description>
                  <value>0b00000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b11111</name>
                  <description>100 mV</description>
                  <value>0b11111</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b10000</name>
                  <description>1.8 V = Default (0x10)</description>
                  <value>0b10000</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="LPPDM">
      <name>PDM</name>
      <baseAddress>0x4902D000</baseAddress>
    </peripheral>
    <peripheral>
      <name>HWSEM0</name>
      <groupName>HWSEM</groupName>
      <baseAddress>0x4902E000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>12</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>HWSEM_REQ_REG</name>
          <description>Request register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>REQ_ACQ</name>
              <description>Request a HWSEM module by writing the processor ID into this field.
Check the status of the HWSEM request by reading this field.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HWSEM_REL_REG</name>
          <description>Release register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>REL_CHK</name>
              <description>Release the HWSEM by writing the processor ID into this field.
Check the current HWSEM count by reading this field.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HWSEM_RST_REG</name>
          <description>Reset register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RST</name>
              <description>Reset the semaphore count and current master ID.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="HWSEM0">
      <name>HWSEM1</name>
      <baseAddress>0x4902E010</baseAddress>
    </peripheral>
    <peripheral derivedFrom="HWSEM0">
      <name>HWSEM2</name>
      <baseAddress>0x4902E020</baseAddress>
    </peripheral>
    <peripheral derivedFrom="HWSEM0">
      <name>HWSEM3</name>
      <baseAddress>0x4902E030</baseAddress>
    </peripheral>
    <peripheral derivedFrom="HWSEM0">
      <name>HWSEM4</name>
      <baseAddress>0x4902E040</baseAddress>
    </peripheral>
    <peripheral derivedFrom="HWSEM0">
      <name>HWSEM5</name>
      <baseAddress>0x4902E050</baseAddress>
    </peripheral>
    <peripheral derivedFrom="HWSEM0">
      <name>HWSEM6</name>
      <baseAddress>0x4902E060</baseAddress>
    </peripheral>
    <peripheral derivedFrom="HWSEM0">
      <name>HWSEM7</name>
      <baseAddress>0x4902E070</baseAddress>
    </peripheral>
    <peripheral derivedFrom="HWSEM0">
      <name>HWSEM8</name>
      <baseAddress>0x4902E080</baseAddress>
    </peripheral>
    <peripheral derivedFrom="HWSEM0">
      <name>HWSEM9</name>
      <baseAddress>0x4902E090</baseAddress>
    </peripheral>
    <peripheral derivedFrom="HWSEM0">
      <name>HWSEM10</name>
      <baseAddress>0x4902E0A0</baseAddress>
    </peripheral>
    <peripheral derivedFrom="HWSEM0">
      <name>HWSEM11</name>
      <baseAddress>0x4902E0B0</baseAddress>
    </peripheral>
    <peripheral derivedFrom="HWSEM0">
      <name>HWSEM12</name>
      <baseAddress>0x4902E0C0</baseAddress>
    </peripheral>
    <peripheral derivedFrom="HWSEM0">
      <name>HWSEM13</name>
      <baseAddress>0x4902E0D0</baseAddress>
    </peripheral>
    <peripheral derivedFrom="HWSEM0">
      <name>HWSEM14</name>
      <baseAddress>0x4902E0E0</baseAddress>
    </peripheral>
    <peripheral derivedFrom="HWSEM0">
      <name>HWSEM15</name>
      <baseAddress>0x4902E0F0</baseAddress>
    </peripheral>
    <peripheral>
      <name>CLKCTL_PER_SLV</name>
      <baseAddress>0x4902F000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>188</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>EXPMST0_CTRL</name>
          <description>Clock Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0xC0000310</resetMask>
          <fields>
            <field>
              <name>IPCLK_FORCE</name>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock force disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Force peripherals functional clocks on, bypass clock gating</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PCLK_FORCE</name>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock force disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Force APB interface clocks (PCLKs) on, bypass clock gating</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PDM_SEL</name>
              <description>PDM functional clock source select</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select 76.8 MHz crystal-oscillator clock (76M8_CLK)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select external audio clock input (AUDIO_CLK)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PDM_CKEN</name>
              <description>Clocks enable for PDM</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clocks</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clocks</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKRAM_CKEN</name>
              <description>Clock enable for Utility SRAM</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_CTRL</name>
          <description>UART Control Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMA_SEL</name>
              <description>UART DMA select for UART[7-4].
One bit for each module. Bit 27 --&gt; UART7, bit 24 --&gt; UART4.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select DMA0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select DMA1</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RS485</name>
              <description>UART[7-4] RS485 Status.
One bit for each module. Bit 23 --&gt; UART7, bit 20 --&gt; UART4.
Bits[19-16] are reserved.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>UART not in RS485 mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>UART is in RS485 mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>UART[7-0]_SCLK Select.
One bit for each module. Bit 15 --&gt; UART7, bit 8 --&gt; UART0.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>38.4 MHz</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SYST_PCLK clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CKEN</name>
              <description>UART[7-0] Enable.
One bit for each module. Bit 7 --&gt; UART7, bit 0 --&gt; UART0</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable UART[7-0] module</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable UART[7-0] module</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_CTRL</name>
          <description>CANFD Control Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x001110FF</resetMask>
          <fields>
            <field>
              <name>FD_ENA</name>
              <description>CANFD FD-mode enable</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable FD-mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable FD-mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>CANFD functional clock source select</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select 38.4 MHz oscillator clock (HFOSC_CLK)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select 160 MHz PLL clock (160M_CLK)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CKEN</name>
              <description>CANFD clocks enable</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CKDIV</name>
              <description>CANFD functional clock divisor
n: Clock divided by n</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Illegal values</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Illegal values</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Clock divided by 2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Clock divided by 3</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>4</dimIncrement>
          <name>I2S_CTRL[%s]</name>
          <description>I2Sn Control Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000100</resetValue>
          <resetMask>0x001313FF</resetMask>
          <fields>
            <field>
              <name>SCLK_AON</name>
              <description>I2S clock output to external device always on</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>I2S clock output (I2S_SCLK) in gated mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>I2S clock output (I2S_SCLK) in always on mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIV_BYPASS</name>
              <description>I2S clock divider bypass</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Do not bypass clock divider</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Bypass clock divider</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>I2S functional clock source select</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select 76.8 MHz crystal-oscillator clock (76M8_CLK)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select external audio clock input (AUDIO_CLK)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CKEN</name>
              <description>I2S clocks enable</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clocks</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clocks</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CKDIV</name>
              <description>I2S functional clock divisor
n: Clock divided by n</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Illegal values</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Illegal values</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Clock divided by 2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Clock divided by 3</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_CTRL</name>
          <description>I3C Control Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0103F101</resetMask>
          <fields>
            <field>
              <name>DMA_SEL</name>
              <description>DMA select</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select DMA0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select DMA2</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ACT_MODE</name>
              <description>I3C slave activity mode for GETSTATUS CCC</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PEND_INT</name>
              <description>I3C pending interrupt information for GETSTATUS CCC</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_MODE</name>
              <description>I2C or I3C mode select</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CKEN</name>
              <description>I3C clocks enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SSI_CTRL</name>
          <description>SPI Control Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000F0F</resetMask>
          <fields>
            <field>
              <name>SS_IN_VAL</name>
              <description>SS_IN Value
 One bit for each SPI module:
- Bit 11: SPI3
- Bit 8: SPI0
 When SS_IN_SEL = 0x1, the programmed SS_IN_VAL is fed to SPI module.
 Note: If the corresponding SPI module is configured as a master, the associated bit in this field should be set to 0x1.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_IN_SEL</name>
              <description>SS_IN Mode Select
 One bit for each SPI module:
- Bit 3: SPI3
- Bit 0: SPI0
Note: If the corresponding SPI module is configured as a master, the associated bit in this field should be set to 0x1. 
If the corresponding SPI module is configured as a slave, and the master device is driving a slave select signal, the associated bit in this field should be set to 0x0. If the master device is not driving a slave select signal, the associated bit in this field should be set to 0x1, and the associated bit in SS_IN_VAL field should be set to 0x0.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SS_IN from I/O pin</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SS_IN from SS_IN_VAL</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_CTRL</name>
          <description>ADC Control Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001111</resetMask>
          <fields>
            <field>
              <name>ADC24_CKEN</name>
              <description>ADC24 clock enable</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable ADC24 clock </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable ADC24 clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC2_CKEN</name>
              <description>ADC122 clock enable</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable ADC122 clock </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable ADC122 clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC1_CKEN</name>
              <description>ADC121 clock enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable ADC121 clock </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable ADC121 clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC0_CKEN</name>
              <description>ADC120 clock enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable ADC120 clock </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable ADC120 clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_CTRL</name>
          <description>DAC Control Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000011</resetMask>
          <fields>
            <field>
              <name>DAC1_CKEN</name>
              <description>DAC121 clock enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable DAC121 clock </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable DAC121 clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DAC0_CKEN</name>
              <description>DAC120 clock enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable DAC120 clock </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable DAC120 clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP_CTRL</name>
          <description>CMP Control Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001111</resetMask>
          <fields>
            <field>
              <name>CMP3_CKEN</name>
              <description>CMP3 clock enable</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable CMP3 clock </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable CMP3 clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMP2_CKEN</name>
              <description>CMP2 clock enable</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable CMP2 clock </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable CMP2 clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMP1_CKEN</name>
              <description>CMP1 clock enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable CMP1 clock </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable CMP1 clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMP0_CKEN</name>
              <description>CMP0 clock enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable CMP0 clock </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable CMP0 clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_CTRL</name>
          <description>OSPI Control Register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>CKEN</name>
              <description>OSPI clock enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>FREQ_MON_CTRL0</name>
          <description>Frequency Monitor 0 Control Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CTRL</name>
              <description>Input count value of the HFXO clock to be measured or calibrated.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FREQ_MON_STAT0</name>
          <description>Frequency Monitor 0 Status Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STAT</name>
              <description>Output count value of the 400 MHz PLL calibrating clock.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FREQ_MON_CTRL1</name>
          <description>Frequency Monitor 1 Control Register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CTRL</name>
              <description>Input count value of the 160 MHz clock to be measured or calibrated.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FREQ_MON_STAT1</name>
          <description>Frequency Monitor 1 Status Register</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STAT</name>
              <description>Output count value of the 400 MHz PLL calibrating clock.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C0_CTRL</name>
          <description>I2C0 Control Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>CKEN</name>
              <description>I2C0 clock enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C1_CTRL</name>
          <description>I2C1 Control Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>CKEN</name>
              <description>I2C1 clock enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C2_CTRL</name>
          <description>I2C2 Control Register</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>CKEN</name>
              <description>I2C2 clock enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C3_CTRL</name>
          <description>I2C3 Control Register</description>
          <addressOffset>0x5C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>CKEN</name>
              <description>I2C3 clock enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <dim>15</dim>
          <dimIncrement>4</dimIncrement>
          <name>GPIO_CTRL[%s]</name>
          <description>GPIOn Control Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000100</resetValue>
          <resetMask>0x000113FF</resetMask>
          <fields>
            <field>
              <name>CKEN</name>
              <description>GPIOn IP clock control</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>GPIOn clock is enabled for two clock cycles when accessed by the host processor</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>GPIOn clock is always active (enabled indefinitely)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DB_CKEN</name>
              <description>Enable GPIOn debounce clock</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable GPIOn debounce clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable GPIOn debounce clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DB_CKDIV</name>
              <description>GPIOn debounce clock divisor
All other values: Clock divided by 1024</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clock divided by 2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Clock divided by 4</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Clock divided by 8</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>Clock divided by 16</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x10</name>
                  <description>Clock divided by 32</description>
                  <value>0x10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x20</name>
                  <description>Clock divided by 64</description>
                  <value>0x20</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x40</name>
                  <description>Clock divided by 128</description>
                  <value>0x40</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x80</name>
                  <description>Clock divided by 256</description>
                  <value>0x80</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x100</name>
                  <description>Clock divided by 512</description>
                  <value>0x100</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x200</name>
                  <description>Clock divided by 1024</description>
                  <value>0x200</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="LPCPI">
      <name>CPI</name>
      <baseAddress>0x49030000</baseAddress>
    </peripheral>
    <peripheral>
      <name>CDC</name>
      <baseAddress>0x49031000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>596</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CDC_HW_VER</name>
          <description>HW Version Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00040000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>MAJVER</name>
              <description>Major version.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MINVER</name>
              <description>Minor version.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REV</name>
              <description>Revision (bug fixes, and others).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_LCNT</name>
          <description>Layer Count Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>LNUM</name>
              <description>Number of layers.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_SYNC_SIZE_CFG</name>
          <description>Sync Size Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HSW</name>
              <description>Horizontal sync width - 1 (in units of pixel clock period).</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VSW</name>
              <description>Vertical sync height - 1 (in units of horizontal scan line).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_BP_CFG</name>
          <description>Back Porch Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AHBP</name>
              <description>Accumulated width including sync and back porch -1 (in units of pixel clock period).</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AVBP</name>
              <description>Accumulated height including sync and back porch -1 (in units of horizontal scan line).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_ACTW_CFG</name>
          <description>Active Width Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AAW</name>
              <description>Accumulated width including sync, back porch and active width -1 (in units of pixel clock period).</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AAH</name>
              <description>Accumulated height including sync, back porch and active height -1 (in units of horizontal scan line).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_TOTALW_CFG</name>
          <description>Total Width Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOTALW</name>
              <description>Total width, including sync, back porch, active width and front porch -1 (in units of pixel clock period).</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TOTALH</name>
              <description>Total height, including sync, back porch, active height and front porch -1 (in units of horizontal scan line).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_GLB_CTRL</name>
          <description>Global Control Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00002220</resetValue>
          <resetMask>0xF70F7777</resetMask>
          <fields>
            <field>
              <name>HSPOL</name>
              <description>HSync polarity. 
 Signal polarity:</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Active low </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Active high</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VSPOL</name>
              <description>VSync polarity. 
 Signal polarity:</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Active low </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Active high</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BLPOL</name>
              <description>Blank polarity.
 Signal polarity: </description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Active low </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Active high</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PCLKPOL</name>
              <description>Output pixel clock polarity.
 Signal polarity: </description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Feed-through of PIXEL_CLK input</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Inverted PIXEL_CLK input</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DITHER_EN</name>
              <description>Dithering on. 
Dithering can be enabled/disabled.
A 4x4 Bayer pattern is added to each color component.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DITHER_R</name>
              <description>Dither bits red (0-4).
Dither bits width for red color component.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DITHER_G</name>
              <description>Dither bits green (0-4).
Dither bits width for green color component.</description>
              <bitRange>[10:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DITHER_B</name>
              <description>Dither bits blue (0-4).
Dither bits width for blue color component.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GAMMA_EN</name>
              <description>Gamma correction enable.
When it is disabled, the RGB data bypasses the gamma correction CLUT.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CDC_EN</name>
              <description>Global enable. Mirrored to pin CDC_DE.
The display controller can be globally enabled/disabled. If the display controller is disabled, the timing generator is reset to X = total_width - 1, Y = total_height - 1, and held. Thus only blanking data is output continuously while the display controller is disabled and no new bus accesses are started. Outstanding read data is discarded and the FIFOs are flushed. The value is mirrored to pin CDC_DE.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_CFG1</name>
          <description>Global Configuration 1 Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x6BE45888</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BMEN</name>
              <description>Blind mode enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CFG_RD</name>
              <description>Configuration reading mode enabled.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STREN</name>
              <description>Status registers enabled.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DWP</name>
              <description>Dither width programmable.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPP</name>
              <description>Sync polarity programmable.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TP</name>
              <description>Timing programmable.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LINE_IRQ</name>
              <description>Line IRQ position programmable.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BBEN</name>
              <description>Background blending enabled.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BCP</name>
              <description>Background color programmable.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SHREN</name>
              <description>Shadow registers enabled.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GCT</name>
              <description>Gamma correction technique.</description>
              <bitRange>[19:17]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>None</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Gamma RAM</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Node interpolation</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DT</name>
              <description>Dithering technique.</description>
              <bitRange>[15:14]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Ordered, 4x4 Bayer matrix</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRBEN</name>
              <description>Precise blending enabled.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WRCH</name>
              <description>Width of red channel output.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WGCH</name>
              <description>Width of green channel output.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WBCH</name>
              <description>Width of blue channel output.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_CFG2</name>
          <description>Global Configuration 2 Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000030</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BOEN</name>
              <description>Blending order enabled.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CRCM</name>
              <description>CRC mode available.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SFMEN</name>
              <description>Single frame ability enabled.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SIRQEN</name>
              <description>Secondary interrupt support enabled.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ROTEN</name>
              <description>Rotation support enabled.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>AXIIDEN</name>
              <description>AXI Interface ID support enabled.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>YUVEN</name>
              <description>YCbCr output color conversion ability enabled.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EDCA</name>
              <description>External display control ability enabled.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSW</name>
              <description>Bus width (log2 of number of bytes).</description>
              <bitRange>[6:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DPAEN</name>
              <description>Secondary RGB output port enabled.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DVAEN</name>
              <description>Dual-view ability enabled.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STSAEN</name>
              <description>Slave timing synchronization ability enabled.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EDCEN</name>
              <description>Background layer ability enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_SRCTRL</name>
          <description>Shadow Reload Control Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>VBR</name>
              <description>Vertical blanking reload (self-clearing after reload, cannot be reset once set).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IMR</name>
              <description>Immediate reload (self-clearing at once).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_GAMMA_CORR</name>
          <description>Gamma Correction Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>R_CLUT</name>
              <description>Select red CLUT to be written.</description>
              <bitRange>[18:18]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>G_CLUT</name>
              <description>Select green CLUT to be written.</description>
              <bitRange>[17:17]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>B_CLUT</name>
              <description>Select blue CLUT to be written.</description>
              <bitRange>[16:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>RGB_VALUE</name>
              <description>Mapped color (RGB). 
Color value to be written to the selected CLUTs.</description>
              <bitRange>[15:8]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLUT_ADDR</name>
              <description>Addressed color. 
Address of CLUT entry to be written.</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_BACKGND_COLOR</name>
          <description>Background Color Register</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>BGC</name>
              <description>Background color (RGB).
Bits [23-16] define red value.
Bits [15-8] define green value.
Bits [7-0] define blue value.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_IRQ_MASK0</name>
          <description>IRQ Enable 1 Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REG_RELOAD_IRQ</name>
              <description>Register reload IRQ enable.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUS_ERROR0_IRQ</name>
              <description>Bus error IRQ enable.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO_UNDERRUN_IRQ</name>
              <description>FIFO underrun warning IRQ enable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCANLINE0_IRQ</name>
              <description>Line IRQ enable.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_IRQ_STATUS0</name>
          <description>IRQ Status 1 Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REG_RELOAD_IRQ</name>
              <description>Register reload IRQ status.
The Register reload interrupt is generated, if a vertical blanking reload was programmed and the first line after the active area is reached.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BUS_ERROR0_IRQ</name>
              <description>Bus error IRQ status.
The Bus error interrupt is generated if an error occurs on the AXI bus.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFO_UNDERRUN_IRQ</name>
              <description>FIFO underrun warning IRQ status.
The FIFO underrun warning interrupt is generated if one of the layer FIFOs is empty and pixel data is read from the FIFO. This can occur if the color frame buffer length is not defined properly or the master bus performance is too low, such that the pixel data cannot be read in time.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SCANLINE0_IRQ</name>
              <description>Line IRQ status.
The Line interrupt is generated when a programmed line number is reached.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_IRQ_CLEAR0</name>
          <description>IRQ Clear Register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>REG_RELOAD_IRQ</name>
              <description>Clear register reload IRQ.</description>
              <bitRange>[3:3]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BUS_ERROR0_IRQ</name>
              <description>Clear bus error IRQ.</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>FIFO_UNDERRUN_IRQ</name>
              <description>Clear FIFO underrun warning IRQ.</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>SCANLINE0_IRQ</name>
              <description>Clear line IRQ.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_LINE_IRQ_POS</name>
          <description>Line Number IRQ Control Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>LIPOS</name>
              <description>Line IRQ position.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_POS_STAT</name>
          <description>Position Status Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>CXPOS</name>
              <description>This field returns the current X position.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CYPOS</name>
              <description>This field returns the current Y position.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_SYNC_BLANK_STAT</name>
          <description>Sync/Blank Status Register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000003</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>HSYNCS</name>
              <description>HSync (horizontal synchronization) status.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Active low</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Active high</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VSYNCS</name>
              <description>VSync (vertical synchronization) status (active high).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Active low</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Active high</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HBLANKS</name>
              <description>HBlank (horizontal data enable) status (active high).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Active low</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Active high</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VBLANKS</name>
              <description>VBlank (vertical data enable) status (active high).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Active low</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Active high</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_SLINE_IRQ_POS</name>
          <description>Secure Line IRQ Position Control Register</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>SLIPOS</name>
              <description>Secure Line IRQ position.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>2</dim>
          <dimIncrement>256</dimIncrement>
          <name>CDC_LAYER_CFG[%s]</name>
          <addressOffset>0x100</addressOffset>
          <register>
            <name>CDC_L_CFG1</name>
            <description>Layer (n) Configuration 1 Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0xFF50A075</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PIX_FORMAT</name>
                <description>Supported pixel formats (bit mask, custom)</description>
                <bitRange>[31:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BLEND_FACTOR1</name>
                <description>Supported blending factors for f1:
Bit [23]: Reserved
Bit [22]: Pixel alpha x constant alpha
Bit [21]: Reserved
Bit [20]: Constant alpha
Bit [19-16]: Reserved</description>
                <bitRange>[23:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BLEND_FACTOR2</name>
                <description>Supported blending factors for f2:
Bit [15]: 1.0 - (pixel alpha x constant alpha)
Bit [14]: Reserved
Bit [13]: 1.0 - constant alpha
Bit [12-8]: Reserved</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CKEY_REPL_EN</name>
                <description>Color key replace ability enabled</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CLUT_EN</name>
                <description>CLUT ability enabled</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WINDOW_EN</name>
                <description>Windowing ability enabled</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DEF_COLOR_EN</name>
                <description>Default color programmable</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>APLANE_EN</name>
                <description>Alpha plane ability enabled</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>COLOR_FBP_EN</name>
                <description>Color FB pitch ability enabled</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>COLOR_FBDUP_EN</name>
                <description>Color FB duplication ability enabled</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CKEY_EN</name>
                <description>Color key ability enabled</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CDC_L_CFG2</name>
            <description>Layer (n) Configuration 2 Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xC0000007</resetMask>
            <fields>
              <field>
                <name>SCALEREN</name>
                <description>Scaling ability enabled</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>YUVEN</name>
                <description>YCbCr ability enabled</description>
                <bitRange>[30:30]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>YUV420FEN</name>
                <description>YCbCr 4:2:0 fully planar enabled</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>YUV420SPEN</name>
                <description>YCbCr 4:2:0 semiplanar enabled</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>YUV422EN</name>
                <description>YCbCr 4:2:2 interleaved enabled</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CDC_L_REL_CTRL</name>
            <description>Layer (n) Shadow Reload Control Register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000007</resetMask>
            <fields>
              <field>
                <name>SH_MASK</name>
                <description>Shadow reload control mask global reloading.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SH_VBLANK</name>
                <description>Shadow reload control vertical blanking.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SH_IM</name>
                <description>Shadow reload control immediate.</description>
                <bitRange>[0:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CDC_L_CTRL</name>
            <description>Layer (n) Control Register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000007FF</resetMask>
            <fields>
              <field>
                <name>DFLT_CBLEND_EN</name>
                <description>Default color blending enable.
This bit enables blending with the default color for a layer, which is disabled or for pixels on a layer outside of the window. When default color blending is disabled, the color of the subjacent layer is simply passed through for such pixels.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CLUT_EN</name>
                <description>CLUT lookup on.
This bit enables/disables the usage of the color look-up table. If enabled, the blue component of the frame buffer pixel after conversion to the internal pixel format is used to look up a RGB value in the table. This RGB value replaces the original RGB value of that pixel. The CLUT is located before the color keying.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LAYER_EN</name>
                <description>Layer on.
This bit enables/disables the layer. When a layer is enabled, data is fetched from the frame buffer, that is, the address, number of lines, line length and pitch settings have to be consistent. When a layer is disabled, the default color is used for all pixels.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CDC_L_WIN_HPOS</name>
            <description>Layer (n) Window Horizontal Position Register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>STOP_POS</name>
                <description>Horizontal Stop Position.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>START_POS</name>
                <description>Horizontal Start Position.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CDC_L_WIN_VPOS</name>
            <description>Layer (n) Window Vertical Position Register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>STOP_POS</name>
                <description>Vertical Stop Position.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>START_POS</name>
                <description>Vertical Start Position.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CDC_L_CKEY</name>
            <description>Layer (n) Color Key Register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00FFFFFF</resetMask>
            <fields>
              <field>
                <name>TRANS_COLOR</name>
                <description>Transparency color.</description>
                <bitRange>[23:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CDC_L_PIX_FORMAT</name>
            <description>Layer (n) Pixel Format Register</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000007</resetMask>
            <fields>
              <field>
                <name>PIXF</name>
                <description>Pixel format selection.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>ARGB8888, 32-bit ARGB</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>RGB888, 24-bit RGB (A = 255)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>RGB565, 16-bit RGB (A = 255)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>RGBA8888, 32-bit RGBA</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x4</name>
                    <description>AL44, 8-bit alpha + luminance (lower channel on R, G, and B)</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x5</name>
                    <description>A/L8, 8-bit single channel (value on A, R, G, and B)</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x6</name>
                    <description>ARGB1555, 16-bit ARGB with 1 bit alpha</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x7</name>
                    <description>ARGB4444, 16-bit ARGB with 4 bits alpha</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>CDC_L_CONST_ALPHA</name>
            <description>Layer (n) Constant Alpha Register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x000000FF</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>CONSTA</name>
                <description>Constant alpha.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CDC_L_DFLT_COLOR</name>
            <description>Layer (n) Default Color Register</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DFLTCOL</name>
                <description>Default color (ARGB).</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CDC_L_BLEND_CFG</name>
            <description>Layer (n) Blending Factors Register</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000607</resetValue>
            <resetMask>0x00000707</resetMask>
            <fields>
              <field>
                <name>F1_SEL</name>
                <description>Selection of blending factor f1.
Other values: Reserved</description>
                <bitRange>[10:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x4</name>
                    <description> Constant alpha</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x6</name>
                    <description>Pixel alpha x Constant alpha</description>
                    <value>0x6</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>F2_SEL</name>
                <description>Selection of blending factor f2.
Other values: Reserved</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x5</name>
                    <description>1 - Constant alpha</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x7</name>
                    <description>Pixel alpha x Constant alpha</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>CDC_L_FB_BCTRL</name>
            <description>Layer (n) FB Bus Control Register</description>
            <addressOffset>0x2C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>WNUM</name>
                <description>Number of words per burst when reading the frame buffers.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Maximum burst length (16 words).</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>1 to 15 words per burst.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>1 to 15 words per burst.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>1 to 15 words per burst.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x4</name>
                    <description>1 to 15 words per burst.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x5</name>
                    <description>1 to 15 words per burst.</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x6</name>
                    <description>1 to 15 words per burst.</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x7</name>
                    <description>1 to 15 words per burst.</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x8</name>
                    <description>1 to 15 words per burst.</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x9</name>
                    <description>1 to 15 words per burst.</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xA</name>
                    <description>1 to 15 words per burst.</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xB</name>
                    <description>1 to 15 words per burst.</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xC</name>
                    <description>1 to 15 words per burst.</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xD</name>
                    <description>1 to 15 words per burst.</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xE</name>
                    <description>1 to 15 words per burst.</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xF</name>
                    <description>1 to 15 words per burst.</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>CDC_L_CFB_ADDR</name>
            <description>Layer (n) Color FB Address Register</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SADDR</name>
                <description>Color FB start address.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CDC_L_CFB_LENGTH</name>
            <description>Layer (n) Color FB Length Register</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PITCH</name>
                <description>Pitch of color FB in bytes (signed).
The pitch is the increment from the start of one line of pixels to the start of the next line in bytes. It is a signed value. Providing negative values allows a vertical flip of the frame buffer. When reading this register, the sign bit [30] is expanded until bit [31].</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LLENGTH</name>
                <description>Line length of color FB in bytes - 1 + (width of bus in bytes).
The line length is the length of one pixel line in bytes + 7. The value of 7 relates to the bus width (8 bytes in this configuration) and serves to correctly calculate the address of the last word of data for that line internally.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CDC_L_CFB_LINES</name>
            <description>Layer (n) Color FB Lines Register</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>LNUM</name>
                <description>Number of lines in the color FB.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CDC_L_CLUT_WRACC</name>
            <description>Layer (n) CLUT Write Access Register</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000000</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Address of CLUT entry.</description>
                <bitRange>[31:24]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>RGB_VAL</name>
                <description>RGB888 value to be written.</description>
                <bitRange>[23:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>DSI</name>
      <baseAddress>0x49032000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>404</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>DSI_VERSION</name>
          <description>DSI Host Controller Version Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x3134312A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VERSION</name>
              <description>Module version</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_PWR_UP</name>
          <description>Power-up Control Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SHUTDOWNZ</name>
              <description>This bit configures the controller either to power up or to reset.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Reset the controller</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Power up the controller</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_CLKMGR_CFG</name>
          <description>Clock Control Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TO_CLK_DIVISION</name>
              <description>This field indicates the division factor for the Timeout clock used as the timing unit in the configuration of high-speed to low-power and low-power to high-speed transition error.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_ESC_CLK_DIVISION</name>
              <description>This field indicates the division factor for the TX Escape clock source (LANEBYTECLK). The values 0 and 1 stop the TXCLKESC generation.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_DPI_VCID</name>
          <description>VC ID Configuration Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DPI_VCID</name>
              <description>This field configures the DPI Virtual Channel ID that is indexed to the Video mode packets.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_DPI_COLOR_CODING</name>
          <description>DPI Color Coding Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOOSELY18_EN</name>
              <description>When set to 1, this bit activates loosely packed variant to 18-bit configurations.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPI_COLOR_CODING</name>
              <description>This field configures the DPI color for Video mode coding as follows:</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>16-bit configuration 2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>18-bit configuration 2</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>24-bit</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_DPI_CFG_POL</name>
          <description>DPI Polarity Configuration Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COLORM_ACTIVE_LOW</name>
              <description>When set to 1, this bit configures the color mode pin (DPICOLORM) as active-low.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SHUTD_ACTIVE_LOW</name>
              <description>When set to 1, this bit configures the shutdown pin (DPISHUTDN) as active-low.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HSYNC_ACTIVE_LOW</name>
              <description>When set to 1, this bit configures the horizontal synchronism pin (DPIHSYNC) as active-low.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VSYNC_ACTIVE_LOW</name>
              <description>When set to 1, this bit configures the vertical synchronism pin (DPIVSYNC) as active-low.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATAEN_ACTIVE_LOW</name>
              <description>When set to 1, this bit configures the data enable pin (DPIDATAEN) as active-low.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_DPI_LP_CMD_TIM</name>
          <description>DPI Low-Power Mode Configuration Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OUTVACT_LPCMD_TIME</name>
              <description>This field is used for the transmission of commands in low-power mode. It defines the size, in bytes, of the largest packet that can fit in a line during the VSA, VBP, and VFP regions.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INVACT_LPCMD_TIME</name>
              <description>This field is used for the transmission of commands in low-power mode. It defines the size, in bytes, of the largest packet that can fit in a line during the VACT region.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_PCKHDL_CFG</name>
          <description>Protocol Configuration Register</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EOTP_TX_LP_EN</name>
              <description>When set to 1, this bit enables the EoTp transmission in low-power.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC_RX_EN</name>
              <description>When set to 1, this bit enables the CRC reception and error reporting.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_RX_EN</name>
              <description>When set to 1, this bit enables the ECC reception, error correction, and reporting.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BTA_EN</name>
              <description>When set to 1, this bit enables the Bus Turn-Around (BTA) request.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EOTP_RX_EN</name>
              <description>When set to 1, this bit enables the EoTp reception.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EOTP_TX_EN</name>
              <description>When set to 1, this bit enables the EoTp transmission in high-speed.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_GEN_VCID</name>
          <description>Generic VC ID Configuration Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GEN_VCID_TX_AUTO</name>
              <description>This field indicates the Generic interface virtual channel identification where generic packet is automatically generated and transmitted.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GEN_VCID_TEAR_AUTO</name>
              <description>This field indicates the virtual channel identification for tear effect by hardware</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GEN_VCID_RX</name>
              <description>This field indicates the Generic interface read-back virtual channel identification.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_MODE_CFG</name>
          <description>Mode Configuration Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMD_VIDEO_MODE</name>
              <description>This bit configures the operation mode:</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Video mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Command mode. Not supported by the DSI controller in this device.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_MODE_CFG</name>
          <description>Video Mode Configuration Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VPG_ORIENTATION</name>
              <description>This field indicates the color bar orientation as follows:</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Vertical mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Horizontal mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VPG_MODE</name>
              <description>This field is to select the pattern:</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Horizontal or vertical</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Vertical only</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VPG_EN</name>
              <description>When set to 1, this bit enables the video mode pattern generator.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_CMD_EN</name>
              <description>When set to 1, this bit enables the command transmission only in low-power mode.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_BTA_ACK_EN</name>
              <description>When set to 1, this bit enables the request for an acknowledge response at the end of a frame.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_HFP_EN</name>
              <description>When set to 1, this bit enables the return to low-power inside the HFP period when timing allows.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_HBP_EN</name>
              <description>When set to 1, this bit enables the return to low-power inside the HBP period when timing allows.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_VACT_EN</name>
              <description>When set to 1, this bit enables the return to low-power inside the VACT period when timing allows.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_VFP_EN</name>
              <description>When set to 1, this bit enables the return to low-power inside the VFP period when timing allows.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_VBP_EN</name>
              <description>When set to 1, this bit enables the return to low-power inside the VBP period when timing allows.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_VSA_EN</name>
              <description>When set to 1, this bit enables the return to low-power inside the VSA period when timing allows.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VID_MODE_TYPE</name>
              <description>This field indicates the video mode transmission type as follows:</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Non-Burst with sync pulses</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Non-Burst with sync events</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Burst mode</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Burst mode</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_PKT_SIZE</name>
          <description>Video Packet Size Register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VID_PKT_SIZE</name>
              <description>This field configures the number of pixels in a single video packet.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_NUM_CHUNKS</name>
          <description>Video Chunks Configuration Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VID_NUM_CHUNKS</name>
              <description>This register configures the number of chunks to be transmitted during a Line period (a chunk is pair made of a video packet and a null packet). If set to 0 or 1, video line is still transmitted in a single packet. If set to 1 that packet is part of a chunk, meaning that a null packet follows it (if DSI_VID_NULL_SIZE &gt; 0). Otherwise, multiple chunks are used to transmit each video line.</description>
              <bitRange>[12:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_NULL_SIZE</name>
          <description>Video Null Packet Configuration Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VID_NULL_SIZE</name>
              <description>This register configures the number of bytes inside a null packet. Setting to 0 disables null packets.</description>
              <bitRange>[12:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_HSA_TIME</name>
          <description>Video HSA Configuration Register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VID_HSA_TIME</name>
              <description>This field configures the Horizontal Synchronism Active period in LANEBYTECLK cycles.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_HBP_TIME</name>
          <description>Video HBP Configuration Register</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VID_HBP_TIME</name>
              <description>This field configures the HBP period in LANEBYTECLK cycles.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_HLINE_TIME</name>
          <description>Video Line Configuration Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VID_HLINE_TIME</name>
              <description>This field configures the size of the total line time (HSA + HBP + HACT + HFP) counted in LANEBYTECLK cycles.</description>
              <bitRange>[14:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_VSA_LINES</name>
          <description>Video VSA Configuration Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VSA_LINES</name>
              <description>This field configures the VSA period measured in number of horizontal lines.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_VBP_LINES</name>
          <description>Video VBP Configuration Register</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VBP_LINES</name>
              <description>This field configures the VBP period measured in number of horizontal lines.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_VFP_LINES</name>
          <description>Video VFP Configuration Register</description>
          <addressOffset>0x5C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VFP_LINES</name>
              <description>This field configures the VFP period measured in number of horizontal lines.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_VACTIVE_LINES</name>
          <description>Video VA Configuration Register</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>V_ACTIVE_LINES</name>
              <description>This field configures the VA period measured in number of horizontal lines.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_CMD_MODE_CFG</name>
          <description>Generic Packet Command Configuration Register</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MAX_RD_PKT_SIZE</name>
              <description>This bit configures the maximum read packet size command transmission type:</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transition type is high-speed</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transition type is low-power</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GEN_LW_TX</name>
              <description>This bit configures the Generic long write packet command transmission type:</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transition type is high-speed</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transition type is low-power</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GEN_SR_2P_TX</name>
              <description>This bit configures the Generic short read packet with two parameters command transmission type:</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transition type is high-speed</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transition type is low-power</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GEN_SR_1P_TX</name>
              <description>This bit configures the Generic short read packet with one parameter command transmission type:</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transition type is high-speed</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transition type is low-power</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GEN_SR_0P_TX</name>
              <description>This bit configures the Generic short read packet with zero parameter command transmission type:</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transition type is high-speed</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transition type is low-power</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GEN_SW_2P_TX</name>
              <description>This bit configures the Generic short write packet with two parameters command transmission type:</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transition type is high-speed</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transition type is low-power</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GEN_SW_1P_TX</name>
              <description>This bit configures the Generic short write packet with one parameter command transmission type:</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transition type is high-speed</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transition type is low-power</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GEN_SW_0P_TX</name>
              <description>This bit configures the Generic short write packet with zero parameter command transmission type:</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transition type is high-speed</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transition type is low-power</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ACK_RQST_EN</name>
              <description>When set to 1, this bit enables the acknowledge request after each packet transmission.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_GEN_HDR</name>
          <description>Generic Header Configuration Register</description>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GEN_WC_MSBYTE</name>
              <description>This field configures the most significant byte of the header packet's word count for long packets or data 1 for short packets.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GEN_WC_LSBYTE</name>
              <description>This field configures the least significant byte of the header packet's Word count for long packets or data 0 for short packets.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GEN_VC</name>
              <description>This field configures the Virtual Channel ID of the header packet.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GEN_DT</name>
              <description>This field configures the packet Data Type of the header packet.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_GEN_PLD_DATA</name>
          <description>Generic Payload Data Register</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GEN_PLD_B4</name>
              <description>This field indicates byte 4 of the packet payload.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GEN_PLD_B3</name>
              <description>This field indicates byte 3 of the packet payload.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GEN_PLD_B2</name>
              <description>This field indicates byte 2 of the packet payload.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GEN_PLD_B1</name>
              <description>This field indicates byte 1 of the packet payload.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_CMD_PKT_STATUS</name>
          <description>Generic Packet Status Register</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00050015</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GEN_BUFF_PLD_FULL</name>
              <description>This bit indicates the full status of the generic payload internal buffer.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_BUFF_PLD_EMPTY</name>
              <description>This bit indicates the empty status of the generic payload internal buffer.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_BUFF_CMD_FULL</name>
              <description>This bit indicates the full status of the generic command internal buffer.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_BUFF_CMD_EMPTY</name>
              <description>This bit indicates the empty status of the generic command internal buffer.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_RD_CMD_BUSY</name>
              <description>This bit is set when a read command is issued and cleared when the entire response is stored in the FIFO for Generic interface.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_PLD_R_FULL</name>
              <description>This bit indicates the full status of the generic read payload FIFO.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_PLD_R_EMPTY</name>
              <description>This bit indicates the empty status of the generic read payload FIFO.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_PLD_W_FULL</name>
              <description>This bit indicates the full status of the generic write payload FIFO.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_PLD_W_EMPTY</name>
              <description>This bit indicates the empty status of the generic write payload FIFO.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_CMD_FULL</name>
              <description>This bit indicates the full status of the generic command FIFO.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_CMD_EMPTY</name>
              <description>This bit indicates the empty status of the generic command FIFO.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_TO_CNT_CFG</name>
          <description>Timeout Counter Configuration Register</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HSTX_TO_CNT</name>
              <description>This field configures the timeout counter that triggers a high-speed transmission timeout contention detection (measured in DSI_CLKMGR_CFG[TO_CLK_DIVISION] cycles).
If using non-burst mode and there is not sufficient time to switch from high-speed to low-power and back in the period which is from one line data finishing to the next line sync start, the DSI link returns low-power state once per frame, then the DSI_CLKMGR_CFG[TO_CLK_DIVISION] and HSTX_TO_CNT fields should be configured to satisfy the following formula: 
HSTX_TO_CNT x LANEBYTECLK_period x TO_CLK_DIVISION &gt;= the time of one FRAME data transmission x (1 + 10%) 
In burst mode, RGB pixel packets are time-compressed, leaving more time during a scan line. So if in burst mode and there is sufficient time to switch from high-speed to low-power and back in the period of time from one line data finishing to the next line sync start, the DSI link can return low-power mode and back in this time interval to save power. If this case, the DSI_CLKMGR_CFG[TO_CLK_DIVISION] and HSTX_TO_CNT fields should be configured to satisfy the following formula: 
HSTX_TO_CNT x LANEBYTECLK_period x TO_CLK_DIVISION &gt;= the time of one LINE data transmission x (1 + 10%)</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LPRX_TO_CNT</name>
              <description>This field configures the timeout counter that triggers a low-power reception timeout contention detection (measured in DSI_CLKMGR_CFG[TO_CLK_DIVISION] cycles).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_HS_RD_TO_CNT</name>
          <description>HS Read Timeout Configuration Register</description>
          <addressOffset>0x7C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HS_RD_TO_CNT</name>
              <description>This field sets a period for which DSI controller keeps the link still, after sending a high-speed Read operation. This period is measured in cycles of LANEBYTECLK, starts to count when the D-PHY enters stop state and causes no interrupts.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_LP_RD_TO_CNT</name>
          <description>LP Read Timeout Configuration Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LP_RD_TO_CNT</name>
              <description>This field sets a period for which DSI controller keeps the link still, after sending a low-power Read operation. This period is measured in cycles of LANEBYTECLK, starts to count when the D-PHY enters stop state and causes no interrupts.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_HS_WR_TO_CNT</name>
          <description>HS Write Timeout Configuration Register</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HS_WR_TO_CNT</name>
              <description>This field sets a period for which DSI controller keeps the link still, after sending a high-speed Write operation. This period is measured in cycles of LANEBYTECLK, starts to count when the D-PHY enters stop state and causes no interrupts.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_LP_WR_TO_CNT</name>
          <description>LP Write Timeout Configuration Register</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LP_WR_TO_CNT</name>
              <description>This field sets a period for which DSI controller keeps the link still, after sending a low-power Write operation. This period is measured in cycles of LANEBYTECLK, starts to count when the D-PHY enters stop state and causes no interrupts.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_BTA_TO_CNT</name>
          <description>BTA Timeout Configuration Register</description>
          <addressOffset>0x8C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BTA_TO_CNT</name>
              <description>This field sets a period for which DSI controller keeps the link still, after completing a BTA. This period is measured in cycles of LANEBYTECLK, starts to count when the D-PHY enters Stop state and causes no interrupts.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_SDF_3D</name>
          <description>3D Control Register</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SEND_3D_CFG</name>
              <description>When set, causes the next VSS packet to include 3D control payload in every VSS packet.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RIGHT_FIRST</name>
              <description>This bit defines the left/right order:</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Left eye is sent first, then right eye</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Right eye data is sent first, then left eye</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECOND_VSYNC</name>
              <description>This field defines whether there is a second VSYNC pulse between Left and Right Images, when 3D Image Format is Frame-based:</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No sync pulses between left and right data</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Sync pulse HSYNC, VSYNC, blanking between left and right data</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORMAT_3D</name>
              <description>This field defines 3D Image Format:</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Alternating lines of left and right data</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Alternating frames of left and right data</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Alternating pixels of left and right data</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MODE_3D</name>
              <description>This field defines 3D Mode On/Off and Display Orientation:</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>3D Mode Off , 2D Mode On</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>3D Mode On, Portrait Orientation</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>3D Mode On, Landscape Orientation</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_LPCLK_CTRL</name>
          <description>Clock Lane Power Control Register</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AUTO_CLKLANE_CTRL</name>
              <description>This bit enables the automatic mechanism to stop providing clock in the clock lane when time allows.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_TXREQUESTCLKHS</name>
              <description>This bit controls the D-PHY PPI TXREQUESTCLKHS signal.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_PHY_TMR_LPCLK_CFG</name>
          <description>Clock Lane Timer Configuration Register</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_CLKHS2LP_TIME</name>
              <description>This field configures the maximum time that the D-PHY clock lane takes to go from high-speed to low-power transmission measured in LANEBYTECLK cycles.</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_CLKLP2HS_TIME</name>
              <description>This field configures the maximum time that the D-PHY clock lane takes to go from low-power to high-speed transmission measured in LANEBYTECLK cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_PHY_TMR_CFG</name>
          <description>Data Lane Timer Configuration Register</description>
          <addressOffset>0x9C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_HS2LP_TIME</name>
              <description>This field configures the maximum time that the D-PHY data lanes take to go from high-speed to low-power transmission measured in LANEBYTECLK cycles.</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_LP2HS_TIME</name>
              <description>This field configures the maximum time that the D-PHY data lanes take to go from low-power to high-speed transmission measured in LANEBYTECLK cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_PHY_RSTZ</name>
          <description>PHY Control Register</description>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_FORCEPLL</name>
              <description>When the D-PHY is in ULPS, this bit enables the D-PHY PLL.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_ENABLECLK</name>
              <description>When set to 1, this bit enables the D-PHY Clock Lane module.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_RSTZ</name>
              <description>When set to 0, this bit places the digital section of the D-PHY in the reset state.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_SHUTDOWNZ</name>
              <description>When set to 0, this bit places the all D-PHY sub-blocks in power-down state.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_PHY_IF_CFG</name>
          <description>PHY Configuration Register</description>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_STOP_WAIT_TIME</name>
              <description>This field configures the minimum time PHY needs to stay in Stop state before requesting an high-speed transmission.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>N_LANES</name>
              <description>This field configures the number of active data lanes:</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Data lane 0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Data lanes 0 and 1</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_PHY_ULPS_CTRL</name>
          <description>PHY ULPS Control Register</description>
          <addressOffset>0xA8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_TXEXITULPSLAN</name>
              <description>ULPS mode Exit on all active data lanes.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_TXREQULPSLAN</name>
              <description>ULPS mode Request on all active data lanes.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_TXEXITULPSCLK</name>
              <description>ULPS mode Exit on clock lane.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_TXREQULPSCLK</name>
              <description>ULPS mode Request on clock lane.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_PHY_TX_TRIGGERS</name>
          <description>PHY TX Trigger Configuration Register</description>
          <addressOffset>0xAC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_TX_TRIGGERS</name>
              <description>This field controls the trigger transmissions.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_PHY_STATUS</name>
          <description>PHY Status Register</description>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000140</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_ULPSACTIVENOT1LANE</name>
              <description>This bit indicates the status of ULPSACTIVENOT1LANE D-PHY signal.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_STOPSTATE1LANE</name>
              <description>This bit indicates the status of PHYSTOPSTATE1LANE D-PHY signal.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_RXULPSESC0LANE</name>
              <description>This bit indicates the status of RXULPSESC0LANE D-PHY signal.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_ULPSACTIVENOT0LANE</name>
              <description>This bit indicates the status of ULPSACTIVENOT0LANE D-PHY signal.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_STOPSTATE0LANE</name>
              <description>This bit indicates the status of PHYSTOPSTATE0LANE D-PHY signal.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_ULPSACTIVENOTCLK</name>
              <description>This bit indicates the status of PHYULPSACTIVENOTCLK D-PHY signal.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_STOPSTATECLKLANE</name>
              <description>This bit indicates the status of PHYSTOPSTATECLKLANE D-PHY signal.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_DIRECTION</name>
              <description>This bit indicates the status of PHYDIRECTION D-PHY signal.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_LOCK</name>
              <description>This bit indicates the status of PHYLOCK D-PHY signal.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_PHY_TST_CTRL0</name>
          <description>PHY Test Interface Control Register 0</description>
          <addressOffset>0xB4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_TESTCLK</name>
              <description>This bit is used to clock the TESTDIN bus into the D-PHY.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_TESTCLR</name>
              <description>PHY test interface clear (active-high).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_PHY_TST_CTRL1</name>
          <description>PHY Test Interface Control Register 1</description>
          <addressOffset>0xB8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_TESTEN</name>
              <description>PHY test interface operation selector:</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The data write operation is set on the rising edge of the TESTCLK signal.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The address write operation is set on the falling edge of the TESTCLK signal.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PHY_TESTDOUT</name>
              <description>PHY output 8-bit data bus for read-back and internal probing functionalities.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_TESTDIN</name>
              <description>PHY test interface input 8-bit data bus for internal register programming and test functionalities access.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_INT_ST0</name>
          <description>Interrupt Status Register 0</description>
          <addressOffset>0xBC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DPHY_ERRORS_4</name>
              <description>This bit indicates LP1 contention error ErrContentionLP1 from Lane 0.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DPHY_ERRORS_3</name>
              <description>This bit indicates LP0 contention error ErrContentionLP0 from Lane 0.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DPHY_ERRORS_2</name>
              <description>This bit indicates control error ErrControl from Lane 0.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DPHY_ERRORS_1</name>
              <description>This bit indicates ErrSyncEsc low-power data transmission synchronization error from Lane 0.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DPHY_ERRORS_0</name>
              <description>This bit indicates ErrEsc escape entry error from Lane 0.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_15</name>
              <description>This bit retrieves the DSI protocol violation from the Acknowledge error report.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_14</name>
              <description>This bit retrieves the reserved (specific to device) from the Acknowledge error report.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_13</name>
              <description>This bit retrieves the invalid transmission length from the Acknowledge error report.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_12</name>
              <description>This bit retrieves the DSI VC ID Invalid from the Acknowledge error report.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_11</name>
              <description>This bit retrieves the not recognized DSI data type from the Acknowledge error report.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_10</name>
              <description>This bit retrieves the checksum error (long packet only) from the Acknowledge error report.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_9</name>
              <description>This bit retrieves the ECC error, multi-bit (detected, not corrected) from the Acknowledge error report.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_8</name>
              <description>This bit retrieves the ECC error, single-bit (detected and corrected) from the Acknowledge error report.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_7</name>
              <description>This bit retrieves the reserved (specific to device) from the acknowledge error report.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_6</name>
              <description>This bit retrieves the False Control error from the Acknowledge error report.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_5</name>
              <description>This bit retrieves the Peripheral Timeout error from the Acknowledge error report.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_4</name>
              <description>This bit retrieves the low-power Transmit Sync error from the Acknowledge error report.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_3</name>
              <description>This bit retrieves the Escape Mode Entry Command error from the Acknowledge error report.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_2</name>
              <description>This bit retrieves the EoT Sync error from the Acknowledge error report.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_1</name>
              <description>This bit retrieves the SoT Sync error from the Acknowledge error report.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_0</name>
              <description>This bit retrieves the SoT error from the Acknowledge error report.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_INT_ST1</name>
          <description>Interrupt Status Register 1</description>
          <addressOffset>0xC0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DPI_BUFF_PLD_UNDER</name>
              <description>This bit indicates that an underflow has occurred when reading payload to build DSI packet for video mode.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_PLD_RECEV_ERR</name>
              <description>This bit indicates that during a generic interface packet read back, the payload FIFO becomes full and the received data is corrupted.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_PLD_RD_ERR</name>
              <description>This bit indicates that during a DCS read data, the payload FIFO becomes empty and the data sent to the interface is corrupted.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_PLD_SEND_ERR</name>
              <description>This bit indicates that during a Generic interface packet build, the payload FIFO becomes empty and corrupt data is sent.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_PLD_WR_ERR</name>
              <description>This bit indicates that the system tried to write a payload data through the Generic interface and the FIFO is full. Therefore, the payload is not written.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_CMD_WR_ERR</name>
              <description>This bit indicates that the system tried to write a command through the Generic interface and the FIFO is full. Therefore, the command is not written.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DPI_PLD_WR_ERR</name>
              <description>This bit indicates that during a DPI pixel line storage, the payload FIFO becomes full and the data stored is corrupted.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EOPT_ERR</name>
              <description>This bit indicates that the EoTp packet has not been received at the end of the incoming peripheral transmission.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PKT_SIZE_ERR</name>
              <description>This bit indicates that the packet size error has been detected during the packet reception.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CRC_ERR</name>
              <description>This bit indicates that the CRC error has been detected in the received packet payload.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ECC_MILTI_ERR</name>
              <description>This bit indicates that the ECC multiple error has been detected in a received packet.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ECC_SINGLE_ERR</name>
              <description>This bit indicates that the ECC single error has been detected and corrected in a received packet.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TO_LP_RX</name>
              <description>This bit indicates that the low-power reception timeout counter reached the end and contention has been detected.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TO_HS_TX</name>
              <description>This bit indicates that the high-speed transmission timeout counter reached the end and contention has been detected.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_INT_MSK0</name>
          <description>Interrupt Mask Register 0</description>
          <addressOffset>0xC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_DPHY_ERRORS_4</name>
              <description>Mask for DPHY_ERRORS_4.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_DPHY_ERRORS_3</name>
              <description>Mask for DPHY_ERRORS_3.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_DPHY_ERRORS_2</name>
              <description>Mask for DPHY_ERRORS_2.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_DPHY_ERRORS_1</name>
              <description>Mask for DPHY_ERRORS_1.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_DPHY_ERRORS_0</name>
              <description>Mask for DPHY_ERRORS_0.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_15</name>
              <description>Mask for ACK_WITH_ERR_15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_14</name>
              <description>Mask for ACK_WITH_ERR_14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_13</name>
              <description>Mask for ACK_WITH_ERR_13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_12</name>
              <description>Mask for ACK_WITH_ERR_12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_11</name>
              <description>Mask for ACK_WITH_ERR_11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_10</name>
              <description>Mask for ACK_WITH_ERR_10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_9</name>
              <description>Mask for ACK_WITH_ERR_9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_8</name>
              <description>Mask for ACK_WITH_ERR_8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_7</name>
              <description>Mask for ACK_WITH_ERR_7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_6</name>
              <description>Mask for ACK_WITH_ERR_6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_5</name>
              <description>Mask for ACK_WITH_ERR_5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_4</name>
              <description>Mask for ACK_WITH_ERR_4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_3</name>
              <description>Mask for ACK_WITH_ERR_3</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_2</name>
              <description>Mask for ACK_WITH_ERR_2</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_1</name>
              <description>Mask for ACK_WITH_ERR_1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_0</name>
              <description>Mask for ACK_WITH_ERR_0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_INT_MSK1</name>
          <description>Interrupt Mask Register 1</description>
          <addressOffset>0xC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_DPI_BUFF_PLD_UNDER</name>
              <description>Mask for DPI_BUFF_PLD_UNDER.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_GEN_PLD_RECEV_ERR</name>
              <description>Mask for GEN_PLD_RECEV_ERR.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_GEN_PLD_RD_ERR</name>
              <description>Mask for GEN_PLD_RD_ERR.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_GEN_PLD_SEND_ERR</name>
              <description>Mask for GEN_PLD_SEND_ERR.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_GEN_PLD_WR_ERR</name>
              <description>Mask for GEN_PLD_WR_ERR.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_GEN_CMD_WR_ERR</name>
              <description>Mask for GEN_CMD_WR_ERR.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_DPI_PLD_WR_ERR</name>
              <description>Mask for DPI_PLD_WR_ERR.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_EOPT_ERR</name>
              <description>Mask for EOPT_ERR.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_PKT_SIZE_ERR</name>
              <description>Mask for PKT_SIZE_ERR.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_CRC_ERR</name>
              <description>Mask for CRC_ERR.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ECC_MILTI_ERR</name>
              <description>Mask for ECC_MILTI_ERR.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ECC_SINGLE_ERR</name>
              <description>Mask for ECC_SINGLE_ERR.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_TO_LP_RX</name>
              <description>Mask for TO_LP_RX.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_TO_HS_TX</name>
              <description>Mask for TO_HS_TX.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_PHY_CAL</name>
          <description>PHY skew calibration control</description>
          <addressOffset>0xCC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXSKEWCALHS</name>
              <description>High-speed skew calibration is started when this field is set high (assuming that PHY is in Stop state).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_INT_FORCE0</name>
          <description>Force Interrupt Register 0</description>
          <addressOffset>0xD8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FORCE_DPHY_ERRORS_4</name>
              <description>Force DPHY_ERRORS_4.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_DPHY_ERRORS_3</name>
              <description>Force DPHY_ERRORS_3.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_DPHY_ERRORS_2</name>
              <description>Force DPHY_ERRORS_2.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_DPHY_ERRORS_1</name>
              <description>Force DPHY_ERRORS_1.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_DPHY_ERRORS_0</name>
              <description>Force DPHY_ERRORS_0.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_15</name>
              <description>Force ACK_WITH_ERR_15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_14</name>
              <description>Force ACK_WITH_ERR_14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_13</name>
              <description>Force ACK_WITH_ERR_13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_12</name>
              <description>Force ACK_WITH_ERR_12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_11</name>
              <description>Force ACK_WITH_ERR_11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_10</name>
              <description>Force ACK_WITH_ERR_10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_9</name>
              <description>Force ACK_WITH_ERR_9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_8</name>
              <description>Force ACK_WITH_ERR_8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_7</name>
              <description>Force ACK_WITH_ERR_7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_6</name>
              <description>Force ACK_WITH_ERR_6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_5</name>
              <description>Force ACK_WITH_ERR_5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_4</name>
              <description>Force ACK_WITH_ERR_4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_3</name>
              <description>Force ACK_WITH_ERR_3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_2</name>
              <description>Force ACK_WITH_ERR_2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_1</name>
              <description>Force ACK_WITH_ERR_1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_0</name>
              <description>Force ACK_WITH_ERR_0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_INT_FORCE1</name>
          <description>Force Interrupt Register 1</description>
          <addressOffset>0xDC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FORCE_DPI_BUFF_PLD_UNDER</name>
              <description>Force for DPI_BUFF_PLD_UNDER.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_GEN_PLD_RECEV_ERR</name>
              <description>Force GEN_PLD_RECEV_ERR.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_GEN_PLD_RD_ERR</name>
              <description>Force GEN_PLD_RD_ERR.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_GEN_PLD_SEND_ERR</name>
              <description>Force GEN_PLD_SEND_ERR.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_GEN_PLD_WR_ERR</name>
              <description>Force GEN_PLD_WR_ERR.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_GEN_CMD_WR_ERR</name>
              <description>Force GEN_CMD_WR_ERR.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_DPI_PLD_WR_ERR</name>
              <description>Force DPI_PLD_WR_ERR.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_EOPT_ERR</name>
              <description>Force EOPT_ERR.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_PKT_SIZE_ERR</name>
              <description>Force PKT_SIZE_ERR.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_CRC_ERR</name>
              <description>Force CRC_ERR.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ECC_MILTI_ERR</name>
              <description>Force ECC_MILTI_ERR.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ECC_SINGLE_ERR</name>
              <description>Force ECC_SINGLE_ERR.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_TO_LP_RX</name>
              <description>Force TO_LP_RX.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_TO_HS_TX</name>
              <description>Force TO_HS_TX.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_PHY_TMR_RD_CFG</name>
          <description>Data Lane Timer Read Configuration Register</description>
          <addressOffset>0xF4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MAX_RD_TIME</name>
              <description>This field configures the maximum time required to perform a read command in LANEBYTECLK cycles. This register can only be modified when no read command is in progress.</description>
              <bitRange>[14:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_SHADOW_CTRL</name>
          <description>Video Shadow Control Register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VID_SHADOW_REQ</name>
              <description>When set to 1, this bit requests that the DPI registers are copied to the auxiliary registers. When the request is completed this bit is auto cleared.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VID_SHADOW_EN</name>
              <description>When set to 1, DPI receives the active configuration from the auxiliary registers. When the feature is set at the same time than VID_SHADOW_REQ the auxiliary registers are automatically updated.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_DPI_VCID_ACT</name>
          <description>Current VC ID Register</description>
          <addressOffset>0x10C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DPI_VCID</name>
              <description>This field specifies the DPI Virtual Channel ID that is indexed to the Video mode packets.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_DPI_COLOR_CODING_ACT</name>
          <description>Current Color Coding Register</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOOSELY18_EN</name>
              <description>When 1, this bit activates loosely packed variant to 18-bit configurations.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DPI_COLOR_CODING</name>
              <description>This field configures the DPI color for Video Mode/eDPI Command Mode coding as follows:</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>16-bit configuration 2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>18-bit configuration 2</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>24-bit</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_DPI_LP_CMD_TIM_ACT</name>
          <description>Low-Power Mode Current Configuration Register</description>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OUTVACT_LPCMD_TIME</name>
              <description>This field is used for the transmission of commands in low-power mode. It specifies the size, in bytes, of the largest packet that can fit in a line during the VSA, VBP, and VFP regions.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INVACT_LPCMD_TIME</name>
              <description>This field is used for the transmission of commands in low-power mode. It specifies the size, in bytes, of the largest packet that can fit in a line during the VACT region.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_MODE_CFG_ACT</name>
          <description>Video Mode Current Configuration Register</description>
          <addressOffset>0x138</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LP_CMD_EN</name>
              <description>When 1, this bit enables the command transmission only in low-power mode.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAME_BTA_ACK_EN</name>
              <description>When 1, this bit enables the request for an acknowledge response at the end of a frame.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LP_HFP_EN</name>
              <description>When 1, this bit enables the return to low-power inside the HFP period when timing allows.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LP_HBP_EN</name>
              <description>When 1, this bit enables the return to low-power inside the HBP period when timing allows.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LP_VACT_EN</name>
              <description>When 1, this bit enables the return to low-power inside the VACT period when timing allows.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LP_VFP_EN</name>
              <description>When 1, this bit enables the return to low-power inside the VFP period when timing allows.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LP_VBP_EN</name>
              <description>When 1, this bit enables the return to low-power inside the VBP period when timing allows.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LP_VSA_EN</name>
              <description>When 1, this bit enables the return to low-power inside the VSA period when timing allows.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VID_MODE_TYPE</name>
              <description>This field specifies the Video mode transmission type as follows:</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Non-Burst with sync pulses</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Non-Burst with sync events</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Burst mode</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Burst mode</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_PKT_SIZE_ACT</name>
          <description>Video Packet Size Current Configuration Register</description>
          <addressOffset>0x13C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VID_PKT_SIZE</name>
              <description>This field specifies the number of pixels in a single video packet.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_NUM_CHUNKS_ACT</name>
          <description>Video Chunks Current Configuration Register</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VID_NUM_CHUNKS</name>
              <description>This register specifies the number of chunks to be transmitted during a Line period (a chunk is pair made of a video packet and a null packet). If set to 0 or 1, video line is still transmitted in a single packet. If set to 1 that packet is part of a chunk, meaning that a null packet follows it (if DSI_VID_NULL_SIZE &gt; 0). Otherwise, multiple chunks are used to transmit each video line.</description>
              <bitRange>[12:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_NULL_SIZE_ACT</name>
          <description>Video Null Packet Size Current Configuration Register</description>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VID_NULL_SIZE</name>
              <description>This register specifies the number of bytes inside a null packet. Setting to 0 disables null packets.</description>
              <bitRange>[12:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_HSA_TIME_ACT</name>
          <description>Video HSA Current Configuration Register</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VID_HSA_TIME</name>
              <description>This field specifies the HSA period in LANEBYTECLK cycles.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_HBP_TIME_ACT</name>
          <description>Video HBP Current Configuration Register</description>
          <addressOffset>0x14C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VID_HBP_TIME</name>
              <description>This field specifies the HBP period in LANEBYTECLK cycles.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_HLINE_TIME_ACT</name>
          <description>Video Line Current Configuration Register</description>
          <addressOffset>0x150</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VID_HLINE_TIME</name>
              <description>This field specifies the size of the total line time (HSA + HBP + HACT + HFP) counted in LANEBYTECLK cycles.</description>
              <bitRange>[14:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_VSA_LINES_ACT</name>
          <description>Video VSA Current Configuration Register</description>
          <addressOffset>0x154</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VSA_LINES</name>
              <description>This field specifies the VSA period measured in number of horizontal lines.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_VBP_LINES_ACT</name>
          <description>Video VBP Current Configuration Register</description>
          <addressOffset>0x158</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VBP_LINES</name>
              <description>This field specifies the VBP period measured in number of horizontal lines.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_VFP_LINES_ACT</name>
          <description>Video VFP Current Configuration Register</description>
          <addressOffset>0x15C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VFP_LINES</name>
              <description>This field specifies the VFP period measured in number of horizontal lines.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_VACTIVE_LINES_ACT</name>
          <description>Video VA Current Configuration Register</description>
          <addressOffset>0x160</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>V_ACTIVE_LINES</name>
              <description>This field specifies the VA period measured in number of horizontal lines.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_PKT_STATUS</name>
          <description>Video Packet Status Register</description>
          <addressOffset>0x168</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00010005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DPI_BUFF_PLD_FULL</name>
              <description>This bit indicates the full status of the payload internal buffer for Video mode. This bit is set to 0 for Command mode.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DPI_BUFF_PLD_EMPTY</name>
              <description>This bit indicates the empty status of the payload internal buffer for Video mode. This bit is set to 0 for Command mode.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DPI_PLD_W_FULL</name>
              <description>This bit indicates the full status of write payload FIFO for Video mode. This bit is set to 0 for Command mode.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DPI_PLD_W_EMPTY</name>
              <description>This bit indicates the empty status of write payload FIFO for Video mode. This bit is set to 0 for Command mode.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DPI_CMD_W_FULL</name>
              <description>This bit indicates the full status of write command FIFO for Video mode. This bit is set to 0 for Command mode.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DPI_CMD_W_EMPTY</name>
              <description>This bit indicates the empty status of write command FIFO for Video mode. This bit is set to 0 for Command mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_SDF_3D_ACT</name>
          <description>3D Current Configuration Register</description>
          <addressOffset>0x190</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SEND_3D_CFG</name>
              <description>When set, causes the next VSS packet to include 3D control payload in every VSS packet.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RIGHT_FIRST</name>
              <description>This bit specifies the left/right order:</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Left eye is sent first, then right eye</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Right eye data is sent first, then left eye</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECOND_VSYNC</name>
              <description>This field specifies whether there is a second VSYNC pulse between Left and Right Images, when 3D Image Format is Frame-based:</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No sync pulses between left and right data.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Sync pulse (HSYNC, VSYNC, blanking) between left and right data.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORMAT_3D</name>
              <description>This field specifies 3D Image Format:</description>
              <bitRange>[3:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Alternating lines of left and right data</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Alternating frames of left and right data</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Alternating pixels of left and right data</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MODE_3D</name>
              <description>This field specifies 3D Mode On/Off and Display Orientation:</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>3D Mode Off, 2D Mode On</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>3D Mode On, Portrait Orientation</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>3D Mode On, Landscape Orientation</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CSI</name>
      <baseAddress>0x49033000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>780</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CSI_VERSION</name>
          <description>Module Version Code Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x30313534</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VERSION</name>
              <description>Module version code</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_N_LANES</name>
          <description>Lane Configuration Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>N_LANES</name>
              <description>This can only be updated when the PHY lane is in Stop state.
Number of active data lanes:</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1 Data Lane</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>2 Data Lanes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_CSI2_RESETN</name>
          <description>CSI Controller Reset Control Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CSI2_RESETN</name>
              <description>CSI controller reset output. Active low.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_ST_MAIN</name>
          <description>Main Interrupt Status Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STATUS_INT_ST_IPI_FATAL</name>
              <description>Status of INT_ST_IPI_FATAL.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>STATUS_INT_ST_LINE</name>
              <description>Status of INT_ST_LINE.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>STATUS_INT_ST_PHY</name>
              <description>Status of INT_ST_PHY.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>STATUS_INT_ST_ECC_CORRECTED</name>
              <description>Status of INT_ST_ECC_CORRECTED.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>STATUS_INT_ST_DATA_ID</name>
              <description>Status of INT_ST_DATA_ID.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>STATUS_INT_ST_PLD_CRC_FATAL</name>
              <description>Status of INT_ST_PLD_CRC_FATAL.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>STATUS_INT_ST_CRC_FRAME_FATAL</name>
              <description>Status of INT_ST_CRC_FRAME_FATAL.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>STATUS_INT_ST_SEQ_FRAME_FATAL</name>
              <description>Status of INT_ST_SEQ_FRAME_FATAL.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>STATUS_INT_ST_BNDRY_FRAME_FATAL</name>
              <description>Status of INT_ST_BNDRY_FRAME_FATAL.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>STATUS_INT_ST_PKT_FATAL</name>
              <description>Status of INT_ST_PKT_FATAL.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>STATUS_INT_ST_PHY_FATAL</name>
              <description>Status of INT_ST_PHY_FATAL.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_DATA_IDS_1</name>
          <description>DT Data ID Monitors Configuration Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DI3_DT</name>
              <description>Data type for programmed Data ID 3.</description>
              <bitRange>[29:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DI2_DT</name>
              <description>Data type for programmed Data ID 2.</description>
              <bitRange>[21:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DI1_DT</name>
              <description>Data type for programmed Data ID 1.</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DI0_DT</name>
              <description>Data type for programmed Data ID 0.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_DATA_IDS_VC_1</name>
          <description>VC Data ID Monitors Configuration Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DI3_VCX_0_1</name>
              <description>Virtual channel extension for programmed Data ID 3.</description>
              <bitRange>[27:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DI3_VC</name>
              <description>Virtual channel for programmed Data ID 3.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DI2_VCX_0_1</name>
              <description>Virtual channel extension for programmed Data ID 2.</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DI2_VC</name>
              <description>Virtual channel for programmed Data ID 2.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DI1_VCX_0_1</name>
              <description>Virtual channel extension for programmed Data ID 1.</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DI1_VC</name>
              <description>Virtual channel for programmed Data ID 1.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DI0_VCX_0_1</name>
              <description>Virtual channel extension for programmed data ID 0.</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DI0_VC</name>
              <description>Virtual channel for programmed Data ID 0.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_PHY_SHUTDOWNZ</name>
          <description>PHY Shutdown Control Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_SHUTDOWNZ</name>
              <description>Shutdown input. This line is used to place the complete PHY module in power down. All analog blocks are in power down mode and digital logic is cleared. Active low.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_DPHY_RSTZ</name>
          <description>PHY Reset Control Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DPHY_RSTZ</name>
              <description>PHY reset output. Active low.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_PHY_RX</name>
          <description>PHY RX Signals Status Register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00010000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_RXCLKACTIVEHS</name>
              <description>Indicates that D-PHY clock lane is actively receiving a DDR clock.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_RXULPSCLKNOT</name>
              <description>Active low. This signal indicates that D-PHY Clock Lane module has entered the Ultra Low Power State.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_RXULPSESC_1</name>
              <description>Lane module 1 has entered the Ultra Low Power mode.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_RXULPSESC_0</name>
              <description>Lane module 0 has entered the Ultra Low Power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_PHY_STOPSTATE</name>
          <description>PHY STOPSTATE Signal Status Register</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_STOPSTATECLK</name>
              <description>D-PHY Clock lane in Stop state.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_STOPSTATEDATA_1</name>
              <description>Data lane 1 in Stop state.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_STOPSTATEDATA_0</name>
              <description>Data lane 0 in Stop state.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_PHY_TEST_CTRL0</name>
          <description>PHY Test Control 0 Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_TESTCLK</name>
              <description>Clock to capture TESTDIN bus contents into the PHY module, with TESTEN signal controlling the operation selection.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_TESTCLR</name>
              <description>When active, performs test interface initialization. Active high.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_PHY_TEST_CTRL1</name>
          <description>PHY Test Control 1 Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_TESTEN</name>
              <description>When asserted high, it configures an address write operation on the falling edge of TESTCLK. When asserted low, it configures a data write operation on the rising edge of TESTCLK.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_TESTDOUT</name>
              <description>Test interface 8-bit data output for reading data and other probing functionalities.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_TESTDIN</name>
              <description>Test interface 8-bit data input for programming internal registers and accessing test functionalities.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_IPI_MODE</name>
          <description>IPI Mode Selection Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IPI_ENABLE</name>
              <description>This register enables the interface.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IPI_CUT_THROUGH</name>
              <description>This field indicates Cut-Through mode state:</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Cut-Through mode inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Cut-Through mode active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IPI_COLOR_COM</name>
              <description>This field indicates if color mode components are delivered as follows:</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>48-bit interface</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>16-bit interface</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IPI_MODE</name>
              <description>This field indicates the video mode transmission type as follows:</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Camera timing</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Controller timing</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_IPI_VCID</name>
          <description>IPI VC Selection Register</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IPI_VCX_0_1</name>
              <description>Virtual channel extension of data to be processed by pixel interface.</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IP_VCID</name>
              <description>Virtual channel of data to be processed by pixel interface.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_IPI_DATA_TYPE</name>
          <description>IPI DT Selection Register</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EMBEDDED_DATA</name>
              <description>For Camera Timing Mode, this bit enables embedded data processing on IPI 1 interface.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IPI_DATA_TYPE</name>
              <description>Data type of data to be processed by pixel interface 1.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_IPI_MEM_FLUSH</name>
          <description>IPI Memory Flush Control Register</description>
          <addressOffset>0x8C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IPI_AUTO_FLUSH</name>
              <description>Memory is automatically flushed at each Frame Start.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IPI_FLUSH</name>
              <description>Flush IPI memory. This bit is auto cleared.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_IPI_HSA_TIME</name>
          <description>IPI HSA Configuration Register</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IPI_HSA_TIME</name>
              <description>This field configures the HSA period in PIXCLK cycles.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_IPI_HBP_TIME</name>
          <description>IPI HBP Configuration Register</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IPI_HBP_TIME</name>
              <description>This field configures the HBP period in PIXCLK cycles.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_IPI_HSD_TIME</name>
          <description>IPI HSD Configuration Register</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IPI_HSD_TIME</name>
              <description>This field configures the Horizontal Sync Delay period in PIXCLK cycles.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_IPI_HLINE_TIME</name>
          <description>IPI HLINE Configuration Register</description>
          <addressOffset>0x9C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IPI_HLINE_TIME</name>
              <description>This field configures the size of the line time counted in PIXCLK cycles.</description>
              <bitRange>[14:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_IPI_SOFTRSTN</name>
          <description>IPI Reset Control Register</description>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IPI_SOFTRSTN</name>
              <description>This field resets IPI. Active low.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_IPI_ADV_FEATURES</name>
          <description>IPI Advanced Features Configuration Register</description>
          <addressOffset>0xAC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IPI_SYNC_EVENT_MODE</name>
              <description>For Camera Timing Mode:</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Frame Start does not trigger any sync event.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Legacy mode. Frame Start triggers a sync event.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN_EMBEDDED</name>
              <description>This field allows the use of embedded packets for IPI synchronization events.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_BLANKING</name>
              <description>This field allows the use of blanking packets for IPI synchronization events.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_NULL</name>
              <description>This field allows the use of null packets for IPI synchronization events.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_LINE_START</name>
              <description>This field allows the use of line start packets for IPI synchronization events.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_VIDEO</name>
              <description>This field allows the use of video packets for IPI synchronization events.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LINE_EVENT_SELECTION</name>
              <description>For Camera Timing Mode, this field allows manual selection of the Packet for line delimiter as follows:</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Controller selects it automatically.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select packets from list programmed in bits [21-17] of this register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IPI_DT</name>
              <description>Data type to overwrite.</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IPI_DT_OVERWRITE</name>
              <description>Ignore Data type of the header using the programmed Data type for decoding.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_IPI_VSA_LINES</name>
          <description>IPI VSA Configuration Register</description>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IPI_VSA_LINES</name>
              <description>This field configures the VSA period measured in number of horizontal lines.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_IPI_VBP_LINES</name>
          <description>IPI VBP Configuration Register</description>
          <addressOffset>0xB4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IPI_VBP_LINES</name>
              <description>This field configures the VBP period measured in number of horizontal lines.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_IPI_VFP_LINES</name>
          <description>IPI VFP Configuration Register</description>
          <addressOffset>0xB8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IPI_VFP_LINES</name>
              <description>This field configures the VFP period measured in number of horizontal lines.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_IPI_VACTIVE_LINES</name>
          <description>IPI VACTIVE Configuration Register</description>
          <addressOffset>0xBC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IPI_VACTIVE_LINES</name>
              <description>This field configures the Vertical Active period measured in number of horizontal lines.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_VC_EXTENSION</name>
          <description>VC Extension Configuration Register</description>
          <addressOffset>0xC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VCX</name>
              <description>This field indicates status of virtual channel extension:</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Virtual channel extension is enabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Legacy mode. Virtual channel extension is disabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_PHY_CAL</name>
          <description>PHY CALIBRATION Signal Status Register</description>
          <addressOffset>0xCC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXSKEWCALHS</name>
              <description>A low-to-high transition on RXSKEWCALHS signal means that the PHY has initiated the deskew calibration.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_ST_PHY_FATAL</name>
          <description>PHY Packet Discarded Interrupt Status Register</description>
          <addressOffset>0xE0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_ERRSOTSYNCHS_1</name>
              <description>Start of transmission error on data lane 1 (no synchronization achieved).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>PHY_ERRSOTSYNCHS_0</name>
              <description>Start of transmission error on data lane 0 (no synchronization achieved).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_MSK_PHY_FATAL</name>
          <description>PHY Packet Discarded Interrupt Mask Register</description>
          <addressOffset>0xE4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_PHY_ERRSOTSYNCHS_1</name>
              <description>Mask for PHY_ERRSOTSYNCHS_1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_PHY_ERRSOTSYNCHS_0</name>
              <description>Mask for PHY_ERRSOTSYNCHS_0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_FORCE_PHY_FATAL</name>
          <description>PHY Packet Discarded Interrupt Force Register</description>
          <addressOffset>0xE8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FORCE_PHY_ERRSOTSYNCHS_1</name>
              <description>Force PHY_ERRSOTSYNCHS_1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_PHY_ERRSOTSYNCHS_0</name>
              <description>Force PHY_ERRSOTSYNCHS_0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_ST_PKT_FATAL</name>
          <description>PHY Packet Construction Interrupt Status Register</description>
          <addressOffset>0xF0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SHORTER_PAYLOAD</name>
              <description>D-PHY mode: Reported greater WC than received, unrecoverable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_DOUBLE</name>
              <description>D-PHY mode: Header ECC contains at least 2 errors, unrecoverable.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_MSK_PKT_FATAL</name>
          <description>PHY Packet Construction Interrupt Mask Register</description>
          <addressOffset>0xF4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_SHORTER_PAYLOAD</name>
              <description>Mask for SHORTER_PAYLOAD.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ERR_ECC_DOUBLE</name>
              <description>Mask for ERR_ECC_DOUBLE.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_FORCE_PKT_FATAL</name>
          <description>PHY Packet Construction Interrupt Force Register</description>
          <addressOffset>0xF8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FORCE_SHORTER_PAYLOAD</name>
              <description>Force SHORTER_PAYLOAD.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_ECC_DOUBLE</name>
              <description>Force ERR_ECC_DOUBLE.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_ST_PHY</name>
          <description>PHY Interrupt Status Register</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_ERRESC_1</name>
              <description>Escape Entry Error on data lane 1.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>PHY_ERRESC_0</name>
              <description>Escape Entry Error on data lane 0.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>PHY_ERRSOTHS_1</name>
              <description>Start of transmission error on data lane 1 (synchronization can still be achieved).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>PHY_ERRSOTHS_0</name>
              <description>Start of transmission error on data lane 0 (synchronization can still be achieved).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_MSK_PHY</name>
          <description>PHY Interrupt Mask Register</description>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_PHY_ERRESC_1</name>
              <description>Mask for PHY_ERRESC_1.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_PHY_ERRESC_0</name>
              <description>Mask for PHY_ERRESC_0.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_PHY_ERRSOTHS_1</name>
              <description>Mask for PHY_ERRSOTHS_1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_PHY_ERRSOTHS_0</name>
              <description>Mask for PHY_ERRSOTHS_0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_FORCE_PHY</name>
          <description>PHY Interrupt Force Register</description>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FORCE_PHY_ERRESC_1</name>
              <description>Force PHY_ERRESC_1.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_PHY_ERRESC_0</name>
              <description>Force PHY_ERRESC_0.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_PHY_ERRSOTHS_1</name>
              <description>Force PHY_ERRSOTHS_1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_PHY_ERRSOTHS_0</name>
              <description>Force PHY_ERRSOTHS_0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_ST_LINE</name>
          <description>PHY Line Construction Interrupt Status Register</description>
          <addressOffset>0x130</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_L_SEQ_DI3</name>
              <description>Error in the sequence of lines for VC3 and DT3.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_L_SEQ_DI2</name>
              <description>Error in the sequence of lines for VC2 and DT2.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_L_SEQ_DI1</name>
              <description>Error in the sequence of lines for VC1 and DT1.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_L_SEQ_DI0</name>
              <description>Error in the sequence of lines for VC0 and DT0.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_L_BNDRY_MATCH_DI3</name>
              <description>Error matching line start with line end for VC3 and DT3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_L_BNDRY_MATCH_DI2</name>
              <description>Error matching line start with line end for VC2 and DT2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_L_BNDRY_MATCH_DI1</name>
              <description>Error matching line start with line end for VC1 and DT1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_L_BNDRY_MATCH_DI0</name>
              <description>Error matching line start with line end for VC0 and DT0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_MSK_LINE</name>
          <description>PHY Line Construction Interrupt Mask Register</description>
          <addressOffset>0x134</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_ERR_L_SEQ_DI3</name>
              <description>Mask for ERR_L_SEQ_DI3.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ERR_L_SEQ_DI2</name>
              <description>Mask for ERR_L_SEQ_DI2.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ERR_L_SEQ_DI1</name>
              <description>Mask for ERR_L_SEQ_DI1.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ERR_L_SEQ_DI0</name>
              <description>Mask for ERR_L_SEQ_DI0.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ERR_L_BNDRY_MATCH_DI3</name>
              <description>Mask for ERR_L_BNDRY_MATCH_DI3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ERR_L_BNDRY_MATCH_DI2</name>
              <description>Mask for ERR_L_BNDRY_MATCH_DI2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ERR_L_BNDRY_MATCH_DI1</name>
              <description>Mask for ERR_L_BNDRY_MATCH_DI1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ERR_L_BNDRY_MATCH_DI0</name>
              <description>Mask for ERR_L_BNDRY_MATCH_DI0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_FORCE_LINE</name>
          <description>PHY Line Construction Interrupt Force Register</description>
          <addressOffset>0x138</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FORCE_ERR_L_SEQ_DI3</name>
              <description>Force ERR_L_SEQ_DI3.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_L_SEQ_DI2</name>
              <description>Force ERR_L_SEQ_DI2.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_L_SEQ_DI1</name>
              <description>Force ERR_L_SEQ_DI1.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_L_SEQ_DI0</name>
              <description>Force ERR_L_SEQ_DI0.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_L_BNDRY_MATCH_DI3</name>
              <description>Force ERR_L_BNDRY_MATCH_DI3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_L_BNDRY_MATCH_DI2</name>
              <description>Force ERR_L_BNDRY_MATCH_DI2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_L_BNDRY_MATCH_DI1</name>
              <description>Force ERR_L_BNDRY_MATCH_DI1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_L_BNDRY_MATCH_DI0</name>
              <description>Force ERR_L_BNDRY_MATCH_DI0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_ST_IPI_FATAL</name>
          <description>IPI Interface Interrupt Status Register</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INT_PULSE_DELAY_OVERFLOW</name>
              <description>Reporting internal FIFO overflow on pulse delay block.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>INT_EVENT_FIFO_OVERFLOW</name>
              <description>Reporting internal FIFO overflow during IPI data processing.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>PIXEL_IF_HLINE_ERR</name>
              <description>Horizontal line time error (only available in Controller timing mode).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>PIXEL_IF_FIFO_NEMPTY_FS</name>
              <description>Controller timing mode: The FIFO of pixel interface is not empty at the start of a new frame. If this is expected this interrupt should be masked.
Camera timing mode: The FIFO of pixel interface is not empty at the start of a new frame. There are some scenarios where synchronization events of new frame can be lost on IPI interface.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>PIXEL_IF_FRAME_SYNC_ERR</name>
              <description>Whenever in Controller timing mode, notifies if a new frame is received but previous has not been completed.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>PIXEL_IF_FIFO_OVERFLOW</name>
              <description>The FIFO of pixel interface has lost information because some data arrived and FIFO is already full.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>PIXEL_IF_FIFO_UNDERFLOW</name>
              <description>The FIFO has become empty before the expected number of pixels (calculated from the packet header) could be extracted to the pixel interface.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_MSK_IPI_FATAL</name>
          <description>IPI Interface Interrupt Mask Register</description>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MSK_INT_PULSE_DELAY_OVERFLOW</name>
              <description>Mask for INT_PULSE_DELAY_OVERFLOW.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_INT_EVENT_FIFO_OVERFLOW</name>
              <description>Mask for INT_EVENT_FIFO_OVERFLOW.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_PIXEL_IF_HLINE_ERR</name>
              <description>Mask for PIXEL_IF_HLINE_ERR.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_PIXEL_IF_FIFO_NEMPTY_FS</name>
              <description>Mask for PIXEL_IF_FIFO_NEMPTY_FS.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_FRAME_SYNC_ERR</name>
              <description>Mask for PIXEL_IF_FRAME_SYNC_ERR.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_PIXEL_IF_FIFO_OVERFLOW</name>
              <description>Mask for PIXEL_IF_FIFO_OVERFLOW.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_PIXEL_IF_FIFO_UNDERFLOW</name>
              <description>Mask for PIXEL_IF_FIFO_UNDERFLOW.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_FORCE_IPI_FATAL</name>
          <description>IPI Interface Interrupt Force Register</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FORCE_INT_PULSE_DELAY_OVERFLOW</name>
              <description>Force for INT_INT_PULSE_DELAY_OVERFLOW.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_INT_EVENT_FIFO_OVERFLOW</name>
              <description>Force for INT_EVENT_FIFO_OVERFLOW.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_PIXEL_IF_HLINE_ERR</name>
              <description>Force for PIXEL_IF_HLINE_ERR.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_PIXEL_IF_FIFO_NEMPTY_FS</name>
              <description>Force for PIXEL_IF_FIFO_NEMPTY_FS.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_FRAME_SYNC_ERR</name>
              <description>Force for FRAME_SYNC_ERR.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_PIXEL_IF_FIFO_OVERFLOW</name>
              <description>Force for PIXEL_IF_FIFO_OVERFLOW.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_PIXEL_IF_FIFO_UNDERFLOW</name>
              <description>Force for PIXEL_IF_FIFO_UNDERFLOW.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_ST_BNDRY_FRAME_FATAL</name>
          <description>Frame Boundary Error Interrupt Status Register</description>
          <addressOffset>0x280</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC15</name>
              <description>Error matching Frame Start with Frame End for VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC14</name>
              <description>Error matching Frame Start with Frame End for VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC13</name>
              <description>Error matching Frame Start with Frame End for VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC12</name>
              <description>Error matching Frame Start with Frame End for VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC11</name>
              <description>Error matching Frame Start with Frame End for VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC10</name>
              <description>Error matching Frame Start with Frame End for VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC9</name>
              <description>Error matching Frame Start with Frame End for VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC8</name>
              <description>Error matching Frame Start with Frame End for VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC7</name>
              <description>Error matching Frame Start with Frame End for VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC6</name>
              <description>Error matching Frame Start with Frame End for VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC5</name>
              <description>Error matching Frame Start with Frame End for VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC4</name>
              <description>Error matching Frame Start with Frame End for VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC3</name>
              <description>Error matching Frame Start with Frame End for VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC2</name>
              <description>Error matching Frame Start with Frame End for VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC1</name>
              <description>Error matching Frame Start with Frame End for VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC0</name>
              <description>Error matching Frame Start with Frame End for VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_MSK_BNDRY_FRAME_FATAL</name>
          <description>Frame Boundary Error Interrupt Mask Register</description>
          <addressOffset>0x284</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC15</name>
              <description>Mask for ERR_F_BNDRY_MATCH_VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC14</name>
              <description>Mask for ERR_F_BNDRY_MATCH_VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC13</name>
              <description>Mask for ERR_F_BNDRY_MATCH_VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC12</name>
              <description>Mask for ERR_F_BNDRY_MATCH_VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC11</name>
              <description>Mask for ERR_F_BNDRY_MATCH_VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC10</name>
              <description>Mask for ERR_F_BNDRY_MATCH_VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC9</name>
              <description>Mask for ERR_F_BNDRY_MATCH_VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC8</name>
              <description>Mask for ERR_F_BNDRY_MATCH_VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC7</name>
              <description>Mask for ERR_F_BNDRY_MATCH_VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC6</name>
              <description>Mask for ERR_F_BNDRY_MATCH_VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC5</name>
              <description>Mask for ERR_F_BNDRY_MATCH_VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC4</name>
              <description>Mask for ERR_F_BNDRY_MATCH_VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC3</name>
              <description>Mask for ERR_F_BNDRY_MATCH_VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC2</name>
              <description>Mask for ERR_F_BNDRY_MATCH_VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC1</name>
              <description>Mask for ERR_F_BNDRY_MATCH_VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC0</name>
              <description>Mask for ERR_F_BNDRY_MATCH_VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_FORCE_BNDRY_FRAME_FATAL</name>
          <description>Frame Boundary Error Interrupt Force Register</description>
          <addressOffset>0x288</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC15</name>
              <description>Force ERR_F_BNDRY_MATCH_VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC14</name>
              <description>Force ERR_F_BNDRY_MATCH_VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC13</name>
              <description>Force ERR_F_BNDRY_MATCH_VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC12</name>
              <description>Force ERR_F_BNDRY_MATCH_VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC11</name>
              <description>Force ERR_F_BNDRY_MATCH_VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC10</name>
              <description>Force ERR_F_BNDRY_MATCH_VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC9</name>
              <description>Force ERR_F_BNDRY_MATCH_VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC8</name>
              <description>Force ERR_F_BNDRY_MATCH_VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC7</name>
              <description>Force ERR_F_BNDRY_MATCH_VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC6</name>
              <description>Force ERR_F_BNDRY_MATCH_VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC5</name>
              <description>Force ERR_F_BNDRY_MATCH_VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC4</name>
              <description>Force ERR_F_BNDRY_MATCH_VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC3</name>
              <description>Force ERR_F_BNDRY_MATCH_VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC2</name>
              <description>Force ERR_F_BNDRY_MATCH_VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC1</name>
              <description>Force ERR_F_BNDRY_MATCH_VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC0</name>
              <description>Force ERR_F_BNDRY_MATCH_VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_ST_SEQ_FRAME_FATAL</name>
          <description>Frame Sequence Error Interrupt Status Register</description>
          <addressOffset>0x290</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_F_SEQ_VC15</name>
              <description>Incorrect Frame sequence detected in VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC14</name>
              <description>Incorrect Frame sequence detected in VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC13</name>
              <description>Incorrect Frame sequence detected in VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC12</name>
              <description>Incorrect Frame sequence detected in VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC11</name>
              <description>Incorrect Frame sequence detected in VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC10</name>
              <description>Incorrect Frame sequence detected in VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC9</name>
              <description>Incorrect Frame sequence detected in VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC8</name>
              <description>Incorrect Frame sequence detected in VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC7</name>
              <description>Incorrect Frame sequence detected in VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC6</name>
              <description>Incorrect Frame sequence detected in VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC5</name>
              <description>Incorrect Frame sequence detected in VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC4</name>
              <description>Incorrect Frame sequence detected in VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC3</name>
              <description>Incorrect Frame sequence detected in VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC2</name>
              <description>Incorrect Frame sequence detected in VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC1</name>
              <description>Incorrect Frame sequence detected in VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC0</name>
              <description>Incorrect Frame sequence detected in VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_MSK_SEQ_FRAME_FATAL</name>
          <description>Frame Sequence Error Interrupt Mask Register</description>
          <addressOffset>0x294</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_F_SEQ_VC15</name>
              <description>Mask for ERR_F_SEQ_VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_SEQ_VC14</name>
              <description>Mask for ERR_F_SEQ_VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_SEQ_VC13</name>
              <description>Mask for ERR_F_SEQ_VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_SEQ_VC12</name>
              <description>Mask for ERR_F_SEQ_VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_SEQ_VC11</name>
              <description>Mask for ERR_F_SEQ_VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_SEQ_VC10</name>
              <description>Mask for ERR_F_SEQ_VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_SEQ_VC9</name>
              <description>Mask for ERR_F_SEQ_VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_SEQ_VC8</name>
              <description>Mask for ERR_F_SEQ_VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_SEQ_VC7</name>
              <description>Mask for ERR_F_SEQ_VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_SEQ_VC6</name>
              <description>Mask for ERR_F_SEQ_VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_SEQ_VC5</name>
              <description>Mask for ERR_F_SEQ_VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_SEQ_VC4</name>
              <description>Mask for ERR_F_SEQ_VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_SEQ_VC3</name>
              <description>Mask for ERR_F_SEQ_VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_SEQ_VC2</name>
              <description>Mask for ERR_F_SEQ_VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_SEQ_VC1</name>
              <description>Mask for ERR_F_SEQ_VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_SEQ_VC0</name>
              <description>Mask for ERR_F_SEQ_VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_FORCE_SEQ_FRAME_FATAL</name>
          <description>Frame Sequence Error Interrupt Force Register</description>
          <addressOffset>0x298</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_F_SEQ_VC15</name>
              <description>Force ERR_F_SEQ_VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_SEQ_VC14</name>
              <description>Force ERR_F_SEQ_VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_SEQ_VC13</name>
              <description>Force ERR_F_SEQ_VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_SEQ_VC12</name>
              <description>Force ERR_F_SEQ_VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_SEQ_VC11</name>
              <description>Force ERR_F_SEQ_VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_SEQ_VC10</name>
              <description>Force ERR_F_SEQ_VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_SEQ_VC9</name>
              <description>Force ERR_F_SEQ_VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_SEQ_VC8</name>
              <description>Force ERR_F_SEQ_VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_SEQ_VC7</name>
              <description>Force ERR_F_SEQ_VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_SEQ_VC6</name>
              <description>Force ERR_F_SEQ_VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_SEQ_VC5</name>
              <description>Force ERR_F_SEQ_VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_SEQ_VC4</name>
              <description>Force ERR_F_SEQ_VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_SEQ_VC3</name>
              <description>Force ERR_F_SEQ_VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_SEQ_VC2</name>
              <description>Force ERR_F_SEQ_VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_SEQ_VC1</name>
              <description>Force ERR_F_SEQ_VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_F_SEQ_VC0</name>
              <description>Force ERR_F_SEQ_VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_ST_CRC_FRAME_FATAL</name>
          <description>Frame CRC Error Interrupt Status Register</description>
          <addressOffset>0x2A0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_FRAME_DATA_VC15</name>
              <description>Last received Frame in VC15, had at least one CRC error.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC14</name>
              <description>Last received Frame in VC14, had at least one CRC error.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC13</name>
              <description>Last received Frame in VC13, had at least one CRC error.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC12</name>
              <description>Last received Frame in VC12, had at least one CRC error.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC11</name>
              <description>Last received Frame in VC11, had at least one CRC error.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC10</name>
              <description>Last received Frame in VC10, had at least one CRC error.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC9</name>
              <description>Last received Frame in VC9, had at least one CRC error.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC8</name>
              <description>Last received Frame in VC8, had at least one CRC error.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC7</name>
              <description>Last received Frame in VC7, had at least one CRC error.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC6</name>
              <description>Last received Frame in VC6, had at least one CRC error.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC5</name>
              <description>Last received Frame in VC5, had at least one CRC error.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC4</name>
              <description>Last received Frame in VC4, had at least one CRC error.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC3</name>
              <description>Last received Frame in VC3, had at least one CRC error.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC2</name>
              <description>Last received Frame in VC2, had at least one CRC error.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC1</name>
              <description>Last received Frame in VC1, had at least one CRC error.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC0</name>
              <description>Last received Frame in VC0, had at least one CRC error.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_MSK_CRC_FRAME_FATAL</name>
          <description>Frame CRC Error Interrupt Mask Register</description>
          <addressOffset>0x2A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_FRAME_DATA_VC15</name>
              <description>Mask for ERR_FRAME_DATA_VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC14</name>
              <description>Mask for ERR_FRAME_DATA_VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC13</name>
              <description>Mask for ERR_FRAME_DATA_VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC12</name>
              <description>Mask for ERR_FRAME_DATA_VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC11</name>
              <description>Mask for ERR_FRAME_DATA_VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC10</name>
              <description>Mask for ERR_FRAME_DATA_VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC9</name>
              <description>Mask for ERR_FRAME_DATA_VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC8</name>
              <description>Mask for ERR_FRAME_DATA_VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC7</name>
              <description>Mask for ERR_FRAME_DATA_VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC6</name>
              <description>Mask for ERR_FRAME_DATA_VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC5</name>
              <description>Mask for ERR_FRAME_DATA_VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC4</name>
              <description>Mask for ERR_FRAME_DATA_VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC3</name>
              <description>Mask for ERR_FRAME_DATA_VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC2</name>
              <description>Mask for ERR_FRAME_DATA_VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC1</name>
              <description>Mask for ERR_FRAME_DATA_VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC0</name>
              <description>Mask for ERR_FRAME_DATA_VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_FORCE_CRC_FRAME_FATAL</name>
          <description>Frame CRC Error Interrupt Force Register</description>
          <addressOffset>0x2A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_FRAME_DATA_VC15</name>
              <description>Force ERR_FRAME_DATA_VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC14</name>
              <description>Force ERR_FRAME_DATA_VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC13</name>
              <description>Force ERR_FRAME_DATA_VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC12</name>
              <description>Force ERR_FRAME_DATA_VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC11</name>
              <description>Force ERR_FRAME_DATA_VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC10</name>
              <description>Force ERR_FRAME_DATA_VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC9</name>
              <description>Force ERR_FRAME_DATA_VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC8</name>
              <description>Force ERR_FRAME_DATA_VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC7</name>
              <description>Force ERR_FRAME_DATA_VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC6</name>
              <description>Force ERR_FRAME_DATA_VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC5</name>
              <description>Force ERR_FRAME_DATA_VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC4</name>
              <description>Force ERR_FRAME_DATA_VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC3</name>
              <description>Force ERR_FRAME_DATA_VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC2</name>
              <description>Force ERR_FRAME_DATA_VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC1</name>
              <description>Force ERR_FRAME_DATA_VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC0</name>
              <description>Force ERR_FRAME_DATA_VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_ST_PLD_CRC_FATAL</name>
          <description>Frame Payload Error Interrupt Status Register</description>
          <addressOffset>0x2B0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_CRC_VC15</name>
              <description>Payload Checksum error detected on VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC14</name>
              <description>Payload Checksum error detected on VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC13</name>
              <description>Payload Checksum error detected on VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC12</name>
              <description>Payload Checksum error detected on VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC11</name>
              <description>Payload Checksum error detected on VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC10</name>
              <description>Payload Checksum error detected on VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC9</name>
              <description>Payload Checksum error detected on VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC8</name>
              <description>Payload Checksum error detected on VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC7</name>
              <description>Payload Checksum error detected on VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC6</name>
              <description>Payload Checksum error detected on VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC5</name>
              <description>Payload Checksum error detected on VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC4</name>
              <description>Payload Checksum error detected on VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC3</name>
              <description>Payload Checksum error detected on VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC2</name>
              <description>Payload Checksum error detected on VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC1</name>
              <description>Payload Checksum error detected on VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC0</name>
              <description>Payload Checksum error detected on VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_MSK_PLD_CRC_FATAL</name>
          <description>Frame Payload Error Interrupt Mask Register</description>
          <addressOffset>0x2B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_CRC_VC15</name>
              <description>Mask for ERR_CRC_VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_CRC_VC14</name>
              <description>Mask for ERR_CRC_VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_CRC_VC13</name>
              <description>Mask for ERR_CRC_VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_CRC_VC12</name>
              <description>Mask for ERR_CRC_VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_CRC_VC11</name>
              <description>Mask for ERR_CRC_VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_CRC_VC10</name>
              <description>Mask for ERR_CRC_VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_CRC_VC9</name>
              <description>Mask for ERR_CRC_VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_CRC_VC8</name>
              <description>Mask for ERR_CRC_VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_CRC_VC7</name>
              <description>Mask for ERR_CRC_VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_CRC_VC6</name>
              <description>Mask for ERR_CRC_VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_CRC_VC5</name>
              <description>Mask for ERR_CRC_VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_CRC_VC4</name>
              <description>Mask for ERR_CRC_VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_CRC_VC3</name>
              <description>Mask for ERR_CRC_VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_CRC_VC2</name>
              <description>Mask for ERR_CRC_VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_CRC_VC1</name>
              <description>Mask for ERR_CRC_VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_CRC_VC0</name>
              <description>Mask for ERR_CRC_VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_FORCE_PLD_CRC_FATAL</name>
          <description>Frame Payload Error Interrupt Force Register</description>
          <addressOffset>0x2B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_CRC_VC15</name>
              <description>Force ERR_CRC_VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_CRC_VC14</name>
              <description>Force ERR_CRC_VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_CRC_VC13</name>
              <description>Force ERR_CRC_VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_CRC_VC12</name>
              <description>Force ERR_CRC_VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_CRC_VC11</name>
              <description>Force ERR_CRC_VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_CRC_VC10</name>
              <description>Force ERR_CRC_VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_CRC_VC9</name>
              <description>Force ERR_CRC_VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_CRC_VC8</name>
              <description>Force ERR_CRC_VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_CRC_VC7</name>
              <description>Force ERR_CRC_VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_CRC_VC6</name>
              <description>Force ERR_CRC_VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_CRC_VC5</name>
              <description>Force ERR_CRC_VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_CRC_VC4</name>
              <description>Force ERR_CRC_VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_CRC_VC3</name>
              <description>Force ERR_CRC_VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_CRC_VC2</name>
              <description>Force ERR_CRC_VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_CRC_VC1</name>
              <description>Force ERR_CRC_VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_CRC_VC0</name>
              <description>Force ERR_CRC_VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_ST_DATA_ID</name>
          <description>DT Error Interrupt Status Register</description>
          <addressOffset>0x2C0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_ID_VC15</name>
              <description>Unrecognized or unimplemented data type detected in VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC14</name>
              <description>Unrecognized or unimplemented data type detected in VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC13</name>
              <description>Unrecognized or unimplemented data type detected in VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC12</name>
              <description>Unrecognized or unimplemented data type detected in VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC11</name>
              <description>Unrecognized or unimplemented data type detected in VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC10</name>
              <description>Unrecognized or unimplemented data type detected in VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC9</name>
              <description>Unrecognized or unimplemented data type detected in VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC8</name>
              <description>Unrecognized or unimplemented data type detected in VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC7</name>
              <description>Unrecognized or unimplemented data type detected in VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC6</name>
              <description>Unrecognized or unimplemented data type detected in VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC5</name>
              <description>Unrecognized or unimplemented data type detected in VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC4</name>
              <description>Unrecognized or unimplemented data type detected in VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC3</name>
              <description>Unrecognized or unimplemented data type detected in VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC2</name>
              <description>Unrecognized or unimplemented data type detected in VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC1</name>
              <description>Unrecognized or unimplemented data type detected in VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC0</name>
              <description>Unrecognized or unimplemented data type detected in VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_MSK_DATA_ID</name>
          <description>DT Error Interrupt Mask Register</description>
          <addressOffset>0x2C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_ID_VC15</name>
              <description>Mask for ERR_ID_VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ID_VC14</name>
              <description>Mask for ERR_ID_VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ID_VC13</name>
              <description>Mask for ERR_ID_VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ID_VC12</name>
              <description>Mask for ERR_ID_VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ID_VC11</name>
              <description>Mask for ERR_ID_VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ID_VC10</name>
              <description>Mask for ERR_ID_VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ID_VC9</name>
              <description>Mask for ERR_ID_VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ID_VC8</name>
              <description>Mask for ERR_ID_VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ID_VC7</name>
              <description>Mask for ERR_ID_VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ID_VC6</name>
              <description>Mask for ERR_ID_VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ID_VC5</name>
              <description>Mask for ERR_ID_VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ID_VC4</name>
              <description>Mask for ERR_ID_VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ID_VC3</name>
              <description>Mask for ERR_ID_VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ID_VC2</name>
              <description>Mask for ERR_ID_VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ID_VC1</name>
              <description>Mask for ERR_ID_VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ID_VC0</name>
              <description>Mask for ERR_ID_VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_FORCE_DATA_ID</name>
          <description>DT Error Interrupt Force Register</description>
          <addressOffset>0x2C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_ID_VC15</name>
              <description>Force ERR_ID_VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ID_VC14</name>
              <description>Force ERR_ID_VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ID_VC13</name>
              <description>Force ERR_ID_VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ID_VC12</name>
              <description>Force ERR_ID_VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ID_VC11</name>
              <description>Force ERR_ID_VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ID_VC10</name>
              <description>Force ERR_ID_VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ID_VC9</name>
              <description>Force ERR_ID_VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ID_VC8</name>
              <description>Force ERR_ID_VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ID_VC7</name>
              <description>Force ERR_ID_VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ID_VC6</name>
              <description>Force ERR_ID_VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ID_VC5</name>
              <description>Force ERR_ID_VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ID_VC4</name>
              <description>Force ERR_ID_VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ID_VC3</name>
              <description>Force ERR_ID_VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ID_VC2</name>
              <description>Force ERR_ID_VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ID_VC1</name>
              <description>Force ERR_ID_VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ID_VC0</name>
              <description>Force ERR_ID_VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_ST_ECC_CORRECTED</name>
          <description>ECC Interrupt Status Register</description>
          <addressOffset>0x2D0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_ECC_CORRECTED_VC15</name>
              <description>D-PHY mode: Header error detected and corrected on VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC14</name>
              <description>D-PHY mode: Header error detected and corrected on VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC13</name>
              <description>D-PHY mode: Header error detected and corrected on VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC12</name>
              <description>D-PHY mode: Header error detected and corrected on VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC11</name>
              <description>D-PHY mode: Header error detected and corrected on VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC10</name>
              <description>D-PHY mode: Header error detected and corrected on VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC9</name>
              <description>D-PHY mode: Header error detected and corrected on VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC8</name>
              <description>D-PHY mode: Header error detected and corrected on VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC7</name>
              <description>D-PHY mode: Header error detected and corrected on VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC6</name>
              <description>D-PHY mode: Header error detected and corrected on VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC5</name>
              <description>D-PHY mode: Header error detected and corrected on VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC4</name>
              <description>D-PHY mode: Header error detected and corrected on VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC3</name>
              <description>D-PHY mode: Header error detected and corrected on VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC2</name>
              <description>D-PHY mode: Header error detected and corrected on VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC1</name>
              <description>D-PHY mode: Header error detected and corrected on VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC0</name>
              <description>D-PHY mode: Header error detected and corrected on VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_MSK_ECC_CORRECTED</name>
          <description>ECC Interrupt Mask Register</description>
          <addressOffset>0x2D4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_ECC_CORRECTED_VC15</name>
              <description>Mask for ERR_ECC_CORRECTED_VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC14</name>
              <description>Mask for ERR_ECC_CORRECTED_VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC13</name>
              <description>Mask for ERR_ECC_CORRECTED_VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC12</name>
              <description>Mask for ERR_ECC_CORRECTED_VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC11</name>
              <description>Mask for ERR_ECC_CORRECTED_VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC10</name>
              <description>Mask for ERR_ECC_CORRECTED_VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC9</name>
              <description>Mask for ERR_ECC_CORRECTED_VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC8</name>
              <description>Mask for ERR_ECC_CORRECTED_VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC7</name>
              <description>Mask for ERR_ECC_CORRECTED_VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC6</name>
              <description>Mask for ERR_ECC_CORRECTED_VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC5</name>
              <description>Mask for ERR_ECC_CORRECTED_VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC4</name>
              <description>Mask for ERR_ECC_CORRECTED_VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC3</name>
              <description>Mask for ERR_ECC_CORRECTED_VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC2</name>
              <description>Mask for ERR_ECC_CORRECTED_VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC1</name>
              <description>Mask for ERR_ECC_CORRECTED_VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC0</name>
              <description>Mask for ERR_ECC_CORRECTED_VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_FORCE_ECC_CORRECTED</name>
          <description>ECC Interrupt Force Register</description>
          <addressOffset>0x2D8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_ECC_CORRECTED_VC15</name>
              <description>Force ERR_ECC_CORRECTED_VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC14</name>
              <description>Force ERR_ECC_CORRECTED_VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC13</name>
              <description>Force ERR_ECC_CORRECTED_VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC12</name>
              <description>Force ERR_ECC_CORRECTED_VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC11</name>
              <description>Force ERR_ECC_CORRECTED_VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC10</name>
              <description>Force ERR_ECC_CORRECTED_VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC9</name>
              <description>Force ERR_ECC_CORRECTED_VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC8</name>
              <description>Force ERR_ECC_CORRECTED_VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC7</name>
              <description>Force ERR_ECC_CORRECTED_VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC6</name>
              <description>Force ERR_ECC_CORRECTED_VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC5</name>
              <description>Force ERR_ECC_CORRECTED_VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC4</name>
              <description>Force ERR_ECC_CORRECTED_VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC3</name>
              <description>Force ERR_ECC_CORRECTED_VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC2</name>
              <description>Force ERR_ECC_CORRECTED_VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC1</name>
              <description>Force ERR_ECC_CORRECTED_VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC0</name>
              <description>Force ERR_ECC_CORRECTED_VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_SCRAMBLING</name>
          <description>Descrambling Control Register</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCRAMBLE_ENABLE</name>
              <description>Enables data descrambling on the CSI controller side.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_SCRAMBLING_SEED1</name>
          <description>Descrambling Seed Configuration Lane 0 Register</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00001008</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCRAMBLE_SEED_LANE1</name>
              <description>Seed used by descrambler block for lane 1.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_SCRAMBLING_SEED2</name>
          <description>Descrambling Seed Configuration Lane 1 Register</description>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00001188</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCRAMBLE_SEED_LANE2</name>
              <description>Seed used by descrambler block for lane 2.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="LPI3C">
      <name>I3C</name>
      <baseAddress>0x49034000</baseAddress>
    </peripheral>
    <peripheral>
      <name>EVTRTR0</name>
      <baseAddress>0x49035000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>160</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <dim>32</dim>
          <dimIncrement>4</dimIncrement>
          <name>EVTRTR0_DMA_CTRL[%s]</name>
          <description>DMA/Event Router Control and Status Register (n)</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACK_TYPE</name>
              <description>DMA handshake type status for DMA peripheral</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Peripheral completes the REQ-ACK handshake with DMA controller. Event Router passing through REQ-ACK between DMA controller and peripheral.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Event Router completes the REQ-ACK handshake with DMA controller. Peripheral raises DMA request without responding to ACK from DMA controller.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENA</name>
              <description>DMA channel enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable DMA channel</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable DMA channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEL</name>
              <description>Select one channel from the four input groups</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select group 0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select group 1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Select group 2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Select group 3</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>EVTRTR0_DMA_REQ_CTRL</name>
          <description>DMA Request Control Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00001000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CB</name>
              <description>Enable DMA request on DMACBREQ</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CS</name>
              <description>Enable DMA request on DMACSREQ</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLB</name>
              <description>Enable DMA request on DMACLBREQ</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLS</name>
              <description>Enable DMA request on DMACLSREQ</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>EVTRTR0_DMA_ACK_TYPE0</name>
          <description>DMA Handshake Type Register 0</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFF00</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACK</name>
              <description>Select DMA handshake type for DMA group #0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EVTRTR0_DMA_ACK_TYPE1</name>
          <description>DMA Handshake Type Register 1</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFF3FF300</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACK</name>
              <description>Select DMA handshake type for DMA group #1</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EVTRTR0_DMA_ACK_TYPE2</name>
          <description>DMA Handshake Type Register 2</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC3FF0000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACK</name>
              <description>Select DMA handshake type for DMA group #2</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EVTRTR0_DMA_ACK_TYPE3</name>
          <description>DMA Handshake Type Register 3</description>
          <addressOffset>0x9C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACK</name>
              <description>Select DMA handshake type for DMA group #3</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CANFD</name>
      <baseAddress>0x49036000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>209</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <dim>20</dim>
          <dimIncrement>4</dimIncrement>
          <name>CANFD_RBUF[%s]</name>
          <description>Receive Buffer Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RBUF</name>
              <description>Receive Buffer Register</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>18</dim>
          <dimIncrement>4</dimIncrement>
          <name>CANFD_TBUF[%s]</name>
          <description>Transmit Buffer Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TBUF</name>
              <description>Transmit Buffer Register</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_TTS</name>
          <description>Transmission Time Stamp Register</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TTS</name>
              <description>Transmission Time Stamp.
This bit field holds the time-stamp of the last transmitted frame for CiA 603 time stamping. Every new frame overwrites it if the TTSEN field of TBUF register is 0x1. The TTS bit field is intended to be used by the time master to acquire the time-stamp of the SYNC message.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_CFG_STAT</name>
          <description>Configuration and Status Register</description>
          <addressOffset>0xA0</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x80</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>RESET</name>
              <description>RESET Request Bit.
Some registers can only be modified if the RESET bit is set to 0x1.
This bit forces several components to a reset state. A detailed definition is given in Section Software Reset. It is automatically set if the node enters bus off state (refer to Section Error Handling).
Note that a CAN node will participate in CAN communication after the RESET bit is switched to 0x0 after 11 CAN bit times. This delay is required by the CAN standard (bus idle time).
If the RESET bit is set to 0x1 and immediately set to 0x0, then it takes some time until it can be read as 0x0 and becomes inactive. The reason is clock domain crossing from host to CAN clock domain. The RESET bit is held active as long as needed depending on the relation between host and CAN clock.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No local reset of the CAN controller</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The host controller performs a local reset of the CAN controller</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LBME</name>
              <description>Loop Back Mode, External (refer to Section Loop Back Mode (LBMI and LBME)).
Note that this bit should not be enabled while a transmission is active.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LBMI</name>
              <description>Loop Back Mode, Internal (refer to Section Loop Back Mode (LBMI and LBME)).
Note that this bit should not be enabled while a transmission is active.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TPSS</name>
              <description>Transmission Primary Single Shot Mode for PTB (refer to Section Single Shot Transmission (SST)).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSSS</name>
              <description>Transmission Secondary Single Shot Mode for STB (refer to Section Single Shot Transmission (SST)).</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RACTIVE</name>
              <description>Reception ACTIVE (Receive Status Bit).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No receive activity</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The controller is currently receiving a frame</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TACTIVE</name>
              <description>Transmission ACTIVE (Transmit Status Bit).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No transmit activity</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The controller is currently transmitting a frame</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUSOFF</name>
              <description>Bus Off (Bus Status Bit, refer to Section Error Handling).
Writing a 0x1 to this bit will reset the CANFD_TECNT and CANFD_RECNT registers. This should be done only for debugging. For more details, refer Section Error Counter Reset.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The controller status is bus on</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The controller status is bus off</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_TCMD</name>
          <description>Command Register</description>
          <addressOffset>0xA1</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>TBSEL</name>
              <description>Transmit Buffer Select.
Selects the transmit buffer to be loaded with a message. Use the TBUF registers for access. The TBSEL bit needs to be stable all the time the TBUF registers are written and when the CANFD_TCTRL[TSNEXT] bit is set.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>PTB (high-priority buffer)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>STB</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOM</name>
              <description>Listen Only Mode (refer to Section Listen Only Mode (LOM)).
This bit cannot be set if the TPE, TSONE, or TSALL bit is set. No transmission can be started if it is enabled and the CANFD_CFG_STAT[LBME] bit is disabled.
The LOM = 0x1 and CANFD_CFG_STAT[LBME] = 0x0 disables all transmissions.
The LOM = 0x1 and CANFD_CFG_STAT[LBME] = 0x1 disables the ACK for received frames and error frames, but enables the transmission of own frames.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STBY</name>
              <description>Transceiver Standby Mode (refer to Section Transceiver Standby Mode).
This register bit can be used to control a standby mode of a transceiver.
This bit cannot be set to 0x1 if the TPE, TSONE, or TSALL bit is set to 0x1.
If the host sets it to 0x0 then the host needs to wait for the time required by the transceiver to start up before the host requests a new transmission.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TPE</name>
              <description>Transmit Primary Enable.
If this bit is set, the message from the PTB will be transmitted at the next possible transmit position. A started transmission from the STB will be completed before, but pending new messages are delayed until the PTB message has been transmitted.
The TPE bit stays set until the message has been transmitted successfully or it is aborted using the TPA bit.
The host controller can set the TPE bit to 0x1 but can not reset it to 0x0. This would only be possible using the TPA bit and aborting the message.
The bit will be reset to the hardware reset value if the CANFD_CFG_STAT[RESET] = 0x1, STBY = 0x1, (LOM = 0x1 and CANFD_CFG_STAT[LBME] = 0x0).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No transmission for the PTB</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmission enable for the message in the high-priority PTB</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TPA</name>
              <description>Transmit Primary Abort.
The bit has to be set by the host controller and will be reset by the CAN controller. Setting this bit automatically de-asserts the TPE bit.
The host controller can set the TPA bit to 0x1 but can not reset it to 0x0.
During the short time while the CAN controller resets the bit, it cannot be set by the host.
The bit will be reset to the hardware reset value if the CANFD_CFG_STAT[RESET] = 0x1.
This bit should not be set simultaneously with the TPE bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No abort</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Aborts a transmission from PTB which has been requested by the TPE = 0x1 but not started yet (the data bytes of the message remains in the PTB)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSONE</name>
              <description>Transmit Secondary One Frame.
This bit in priority mode is difficult to handle, because it is not always clear which message will be transmitted if new messages are written to the STB meanwhile.
The controller starts the transmission as soon as the bus becomes vacant and no request of the PTB (the TPE bit) is pending.
The TSONE bit stays set until the message has been transmitted successfully or it is aborted using the TSA bit.
The host controller can set the TSONE bit to 0x1 but can not reset it to 0x0. This would only be possible using the TSA bit and aborting the message.
The bit will be reset to the hardware reset value if the CANFD_CFG_STAT[RESET] = 0x1, STBY = 0x1, (LOM = 0x1 and CANFD_CFG_STAT[LBME] = 0x0).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No transmission for the STB</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmission enable of one in the STB. In FIFO mode this is the oldest message and in priority mode this is the one with the highest priority</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSALL</name>
              <description>Transmit Secondary All Frames.
The controller starts the transmission as soon as the bus becomes vacant and no request of the PTB (the TPE bit) is pending.
This bit stays set until all messages have been transmitted successfully or they are aborted using the TSA bit.
The host controller can set the TSALL bit to 0x1 but can not reset it to 0x0. This would only be possible using the TSA bit and aborting the messages.
The bit will be reset to the hardware reset value if the CANFD_CFG_STAT[RESET] = 0x1, STBY = 0x1, (LOM = 0x1 and CANFD_CFG_STAT[LBME] = 0x0).
If during a transmission the STB is loaded with a new frame then the new frame will be transmitted too. In other words: a transmission initiated by this bit is finished when the STB becomes empty.
Note: Setting both TSONE and TSALL bits is meaningless. While the TSALL bit is already set, it is impossible to set the TSONE bit and vice versa. If both TSONE and TSALL bits are set simultaneously then the TSALL bit wins and the TSONE bit is cleared by the CAN controller.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No transmission for the STB</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmission enable of all messages in the STB</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSA</name>
              <description>Transmit Secondary Abort.
The bit has to be set by the host controller and will be reset by the CAN controller. Setting this bit, automatically de-asserts the TSONE or TSALL bit respectively.
The host controller can set this bit to 0x1 but can not reset it to 0x0.
The bit will be reset to the hardware reset value if the CANFD_CFG_STAT[RESET] = 0x1.
This bit should not be set simultaneously with the TSONE or TSALL bit.
For a TSONE transmission, only one frame is aborted while for a TSALL transmission, all frames are aborted.
One or all message slots will be released which updates the CANFD_TCTRL[TSSTAT] bit field.
All aborted messages are lost because they are not accessible any more.
If in priority mode a TSONE transmission is aborted, then it is not clear which frame will be aborted if new frames are written to the STB meanwhile.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No abort</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Aborts a transmission from STB which has been requested but not started yet</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_TCTRL</name>
          <description>Transmit Control Register</description>
          <addressOffset>0xA2</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x84</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>FD_ISO</name>
              <description>CAN FD ISO Mode.
ISO CAN FD mode has a different CRC initialization value and an additional stuff bit count. Both modes are incompatible and must not be mixed in one CAN network.
This bit has no impact to CAN 2.0B.
This bit is only writeable if the CANFD_CFG_STAT[RESET] = 0x1.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Bosch CAN FD (non-ISO) mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ISO CAN FD mode (ISO 11898-1:2015)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSNEXT</name>
              <description>Transmit Buffer Secondary Next.
After all frame bytes are written to the TBUF registers, the host controller has to set this bit to signal that this slot has been filled. Then the CAN controller connects the TBUF registers to the next slot. Once a slot is marked as filled a transmission can be started using the CANFD_TCMD[TSONE] or CANFD_TCMD[TSALL] bit.
It is possible to set the TSNEXT bit and the CANFD_TCMD[TSONE] or CANFD_TCMD[TSALL] bit together in one write access.
This bit has to be set by the host controller and is automatically reset by the CAN controller immediately after it was set.
Setting the TSNEXT bit is meaning less if the CANFD_TCMD[TBSEL] = 0x0. In this case the TSNEXT bit is ignored and automatically cleared. It does not do any harm.
If all slots of the STB are filled, this bit stays set until a slot becomes free (refer to Section Full STB).</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No action</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>STB slot filled, select next slot</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSMODE</name>
              <description>Transmit Buffer Secondary Operation Mode.
In FIFO mode frames are transmitted in the order in that they are written into the STB.
In priority decision mode the frame with the highest priority in the STB is automatically transmitted first. The ID of a frame is used for the priority decision. A lower ID means a higher priority of a frame. A frame in the PTB has always the highest priority regardless of the ID.
This bit shall be switched only if the STB is empty.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>FIFO mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Priority decision mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSSTAT</name>
              <description>Transmission Secondary Status Bits.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>STB is empty</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>STB is less than or equal to half full</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>STB is more than half full</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>STB is full</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_RCTRL</name>
          <description>Receive Control Register</description>
          <addressOffset>0xA3</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>SACK</name>
              <description>Self-Acknowledge.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No self-ACK</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Self-ACK when the CANFD_CFG_STAT[LBME] = 0x1</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ROM</name>
              <description>Receive Buffer Overflow Mode.
In case of a full RBUF when a new message is received, then this bit selects the following:</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The oldest message will be overwritten</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description> The new message will not be stored</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ROV</name>
              <description>Receive Buffer Overflow.
This bit is cleared by setting the RREL = 0x1.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No Overflow</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description> Overflow. At least one message is lost</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RREL</name>
              <description>Receive Buffer Release.
The host controller has read the actual RB slot and releases it. Afterwards the CAN controller points to the next RB slot. The RSTAT bit field gets updated.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No release</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Release: The host has read the RB</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RBALL</name>
              <description>Receive Buffer Stores All Data Frames.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Normal operation</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RB stores correct data frames as well as data frames with error (refer to Section Reception of All Data Frames (CANFD_RCTRL[RBALL]))</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RSTAT</name>
              <description>Receive Buffer Status.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Empty</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>&gt; Empty and &lt; almost full (CANFD_LIMIT[AFWL])</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Almost full (programmable threshold by the CANFD_LIMIT[AFWL] bit field) but not full and no overflow</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Full (stays set in case of overflow-for overflow signaling, see the ROV bit)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_RTIE</name>
          <description>Receive and Transmit Interrupt Enable Register</description>
          <addressOffset>0xA4</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0xFE</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>RIE</name>
              <description>Receive Interrupt Enable.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ROIE</name>
              <description>RB Overrun Interrupt Enable.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFIE</name>
              <description>RB Full Interrupt Enable.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RAFIE</name>
              <description>RB Almost Full Interrupt Enable.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TPIE</name>
              <description>Transmission Primary Interrupt Enable.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSIE</name>
              <description>Transmission Secondary Interrupt Enable.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EIE</name>
              <description>Error Interrupt Enable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSFF</name>
              <description>Transmit Secondary Buffer Full Flag.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The STB is not filled with the maximal number of messages</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The STB is filled with the maximal number of messages</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_RTIF</name>
          <description>Receive and Transmit Interrupt Flag Register</description>
          <addressOffset>0xA5</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>RIF</name>
              <description>Receive Interrupt Flag.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No frame has been received</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Data or a remote frame has been received and is available in the receive buffer</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ROIF</name>
              <description>RB Overrun Interrupt Flag.
In case of an overrun both ROIF and RFIF bits are set.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No RB overwritten</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>At least one received message has been overwritten in the RB</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFIF</name>
              <description>RB Full Interrupt Flag.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The RB FIFO is not full</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>All RBs are full. If no RB is released until the next valid message is received, the oldest message is lost</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RAFIF</name>
              <description>RB Almost Full Interrupt Flag.
Refer to the CANFD_LIMIT[AFWL] bit field.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>number of filled RB slots &lt; AFWL_i</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>number of filled RB slots AFWL_i</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TPIF</name>
              <description>Transmission Primary Interrupt Flag.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No transmission of the PTB has been completed</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The requested transmission of the PTB has been successfully completed</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSIF</name>
              <description>Transmission Secondary Interrupt Flag.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No transmission of the STB has been completed successfully</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The requested transmission of the STB has been successfully completed</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EIF</name>
              <description>Error Interrupt Flag.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>There has been no change</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The border of the error warning limit has been crossed in either direction, or the CANFD_CFG_STAT[BUSOFF] bit has been changed in either direction</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AIF</name>
              <description>Abort Interrupt Flag.
It is recommended to not set both CANFD_TCMD[TPA] and CANFD_TCMD[TSA] bits simultaneously because both source this bit.
This bit does not have an associated enable register.
Refer to Section Message Transmission Abort.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No abort has been executed</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>After setting the CANFD_TCMD[TPA] or CANFD_TCMD[TSA] bit the appropriated message(s) have been aborted</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_ERRINT</name>
          <description>Error Interrupt Enable and Flag Register</description>
          <addressOffset>0xA6</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>EWARN</name>
              <description>Error Warning Limit Reached.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The values in both counters are less than the CANFD_LIMIT[EWL] bit field</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>One of the error counters (the CANFD_RECNT or CANFD_TECNT register) is equal or bigger than the CANFD_LIMIT[EWL] bit field</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EPASS</name>
              <description>Error Passive Mode Active.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not active (node is error active)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Active (node is error passive)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EPIE</name>
              <description>Error Passive Interrupt Enable.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EPIF</name>
              <description>Error Passive Interrupt Flag.
This bit will be activated if the error status changes from error active to error passive or vice versa and if this interrupt is enabled.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>ALIE</name>
              <description>Arbitration Lost Interrupt Enable.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALIF</name>
              <description>Arbitration Lost Interrupt Flag.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>BEIE</name>
              <description>Bus Error Interrupt Enable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BEIF</name>
              <description>Bus Error Interrupt Flag.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_LIMIT</name>
          <description>Warning Limits Register</description>
          <addressOffset>0xA7</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x1B</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>AFWL</name>
              <description>Almost Full Warning Limit.
The AFWL bit field defines the internal warning limit AFWL_i with nRB being the number of available RB slots.
AFWL_i is compared to the number of filled RB slots and triggers the CANFD_RTIF[RAFIF] bit if equal. The valid range of AFWL_i is [1KB nRB].
AFWL = 0 is meaningless and automatically treated as 0x1.
 Note that AFWL is meant in this rule and not AFWL_i.
 AFWL_i &gt; nRB is meaningless and automatically treated as nRB.
AFWL_i = nRB is a valid value, but note that the CANFD_RTIF[RFIF] bit also exists.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EWL</name>
              <description>Programmable Error Warning Limit = (EWL + 1) x 8.
Possible Limit values: 8, 16, ...128. The value of this bit field controls the CANFD_RTIF[EIF] bit.
The EWL bit field needs to be transferred using Clock Domain Crossing (CDC) from host to CAN clock domain. During transfer, this bit field is write-locked for the host for a few clocks until CDC is complete.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_S_SEG_1</name>
          <description>Slow Speed Bit Timing 1 Register (Segment 1)</description>
          <addressOffset>0xA8</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x03</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>S_SEG_1</name>
              <description>Bit Timing Segment 1 (Slow Speed).
The sample point will be set to tSeg_1 = (Seg_1 + 2) x TQ after start of bit time.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_S_SEG_2</name>
          <description>Slow Speed Bit Timing 2 Register (Segment 2)</description>
          <addressOffset>0xA9</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x02</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>S_SEG_2</name>
              <description>Bit Timing Segment 2 (Slow Speed).
Time tSeg_2 = (Seg_2 + 1) x TQ after the sample point.</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_S_SJW</name>
          <description>Slow Speed Bit Timing 3 Register (Synchronization Jump Width)</description>
          <addressOffset>0xAA</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x02</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>S_SJW</name>
              <description>Synchronization Jump Width (Slow Speed).
The Synchronization Jump Width tSJW = (SJW + 1) x TQ is the maximum time for shortening or lengthening the Bit Time for resynchronization, where TQ is a time quanta.</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_S_PRESC</name>
          <description>Slow Speed Prescaler Register</description>
          <addressOffset>0xAB</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x01</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>S_PRESC</name>
              <description>Prescaler Slow Speed.
The prescaler divides the system clock to get the time quanta clock.
Valid range for the CANFD_S_PRESC[S_PRESC] bit field is from 0x00 to 0xFF (results in divider values from 1 to 255).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_F_SEG_1</name>
          <description>Fast Speed Bit Timing 1 Register (Segment 1)</description>
          <addressOffset>0xAC</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x03</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>F_SEG_1</name>
              <description>Bit Timing Segment 1 (Fast Speed).
The sample point will be set to tSeg_1 = (Seg_1 + 2) x TQ after start of bit time.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_F_SEG_2</name>
          <description>Fast Speed Bit Timing 2 Register (Segment 2)</description>
          <addressOffset>0xAD</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x02</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>F_SEG_2</name>
              <description>Bit Timing Segment 2 (Fast Speed).
Time tSeg_2 = (Seg_2 + 1) x TQ after the sample point.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_F_SJW</name>
          <description>Fast Speed Bit Timing 3 Register (Synchronization Jump Width)</description>
          <addressOffset>0xAE</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x02</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>F_SJW</name>
              <description>Synchronization Jump Width (Fast Speed).
The Synchronization Jump Width tSJW = (SJW + 1) x TQ is the maximum time for shortening or lengthening the Bit Time for resynchronization, where TQ is a time quanta.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_F_PRESC</name>
          <description>Fast Speed Prescaler Register</description>
          <addressOffset>0xAF</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x01</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>F_PRESC</name>
              <description>Prescaler Fast Speed.
The prescaler divides the system clock to get the time quanta clock.
Valid range for the CANFD_F_PRESC[F_PRESC] bit field is from 0x00 to 0xFF (results in divider values from 1 to 255).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_EALCAP</name>
          <description>Error and Arbitration Lost Capture Register</description>
          <addressOffset>0xB0</addressOffset>
          <size>8</size>
          <access>read-only</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>KOER</name>
              <description>Kind of Error (Error Code).
(dominant bits after own error flag, received active Error Flag too long, dominant bit during Passive-Error-Flag after ACK error)
This bit field is updated with each new error. Therefore, it stays untouched when frames are successfully transmitted or received.</description>
              <bitRange>[7:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>BIT ERROR</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>FORM ERROR</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>STUFF ERROR</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>ACKNOWLEDGEMENT ERROR</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>CRC ERROR</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>OTHER ERROR</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>Not used</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ALC</name>
              <description>Arbitration Lost Capture (bit position in the frame where the arbitration has been lost)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_TDC</name>
          <description>Transmitter Delay Compensation Register</description>
          <addressOffset>0xB1</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>TDCEN</name>
              <description>Transmitter Delay Compensation Enable.
The Transmitter Delay Compensation (TDC) will be activated during the data phase of a CAN FD frame if BRS is active and if the TDCEN = 0x1. For more details about TDC refer to Section Bit Rate Switching and Sample Point.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSPOFF</name>
              <description>Secondary Sample Point Offset.
The transmitter delay plus defines the time of the secondary sample point for TDC (the SSPOFF bit field value is given as a number of TQ).</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_RECNT</name>
          <description>Receive Error Counter Register</description>
          <addressOffset>0xB2</addressOffset>
          <size>8</size>
          <access>read-only</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>RECNT</name>
              <description>Receive Error Count (Number of Errors During Reception).
This bit field is incremented and decremented as defined in the CAN specification.
The CANFD_RECNT register does not overflow.
For more details about the CANFD_RECNT register and the bus off state, refer to Section Error Handling.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_TECNT</name>
          <description>Transmit Error Counter Register</description>
          <addressOffset>0xB3</addressOffset>
          <size>8</size>
          <access>read-only</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>TECNT</name>
              <description>Transmit Error Count (Number of Errors During Transmission).
This bit field is incremented and decremented as defined in the CAN specification.
In case of the bus off state, the TECNT bit field may overflow.
 For more details about this bit field and the bus off state, refer to Section Error Handling.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_ACFCTRL</name>
          <description>Acceptance Filter Control Register</description>
          <addressOffset>0xB4</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>SELMASK</name>
              <description>Select Acceptance MASK.
The ACFADR bit field selects one specific acceptance filter.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The ACF_X registers (where X = 1 to 3) point to acceptance code</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The ACF_X registers (where X = 1 to 3) point to acceptance mask</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ACFADR</name>
              <description>Acceptance Filter Address.
This bit field points to a specific acceptance filter. The selected filter is accessible using the ACF_X registers (where X = 1 to 3). The SELMASK bit selects between acceptance code and mask for the selected acceptance filter.
A value of the ACFADR bit field &gt; Number of Acceptance Filters (NAF) - 1 is meaningless and automatically treated as value NAF - 1.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_TIMECFG</name>
          <description>CiA 603 Time-Stamping Register</description>
          <addressOffset>0xB5</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x02</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>TIMEPOS</name>
              <description>Time-Stamping Position.
For description of the SOF and EOF bits, refer to Section Table 1-2 CAN Bit Abbreviations.
This bit can only be changed if the TIMEEN = 0x0, but it is possible to modify it with the same write access that sets the TIMEEN = 0x1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SOF</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>EOF</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIMEEN</name>
              <description>Time-Stamping Enable.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_ACF_EN_0</name>
          <description>Acceptance Filter Enable 0 Register</description>
          <addressOffset>0xB6</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x01</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>AE_X</name>
              <description>Acceptance Filter Enable.
Each acceptance filter (AMASK/ACODE) can be individually enabled or disabled. Only filter number 0 is enabled by default after hardware reset.
Disabled filters reject a message. Only enabled filters can accept a message if the appropriate AMASK/ACODE configuration matches.
To accept all messages one filter x has to be enabled by setting AE_X = 0x1, AMASK_X = 0xFF and ACODE_X = 0x00. This is the default configuration after hardware reset for filter X = 0 while all other filters are disabled.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Acceptance filter disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Acceptance filter enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_ACF_EN_1</name>
          <description>Acceptance Filter Enable 1 Register</description>
          <addressOffset>0xB7</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>AE_X</name>
              <description>Acceptance Filter Enable.
Each acceptance filter (AMASK/ACODE) can be individually enabled or disabled.
Disabled filters reject a message. Only enabled filters can accept a message if the appropriate AMASK/ACODE configuration matches.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Acceptance filter disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Acceptance filter enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_ACF_0_3_CODE</name>
          <description>Acceptance CODE Register</description>
          <addressOffset>0xB8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACODE_X</name>
              <description>Acceptance CODE.
The ID bits are compared with the corresponding acceptance code bits as follows:
- ACODE_X(10-0) will be used for standard frames.
- ACODE_X(28-0) will be used for extended frames.
Only filter 0 is affected by the power-on reset. All other filters stay uninitialized.
Refer to Section Software Reset.</description>
              <bitRange>[28:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Acceptance code bit value to compare with ID bit of the received message is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Acceptance code bit value to compare with ID bit of the received message is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_ACF_0_3_MASK</name>
          <description>Acceptance MASK Register</description>
          <alternateRegister>CANFD_ACF_0_3_CODE</alternateRegister>
          <addressOffset>0xB8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1FFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AIDEE</name>
              <description>Acceptance Mask IDE Bit Check Enable.
Only filter 0 is affected by the power-on reset. All other filters stay uninitialized.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Acceptance filter accepts both standard or extended frames</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Acceptance filter accepts either standard or extended as defined by this bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AIDE</name>
              <description>Acceptance Mask IDE Bit Value.
If the AIDEE = 0x1 then:
Only filter 0 is affected by the power-on reset. All other filters stay uninitialized.
Note: The AIDEE and AIDE bits can only be accessed if the CANFD_ACFCTRL[SELMASK] = 0x1. These bits can be used to accept only either standard or extended frames with the selected ACODE / AMASK setting or to accept both frame types. Only acceptance filter 0 is affected by the power-on reset and it is configured to accept both frame types after power-up.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Acceptance filter accepts only standard frames</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Acceptance filter accepts only extended frames</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AMASK_X</name>
              <description>Acceptance MASK 3.
- AMASK_X(10-0) will be used for standard frames.
- AMASK_X(28-0) will be used for extended frames.
Disabled bits result in accepting the message. Therefore, the default configuration after reset for filter 0 accepts all messages.
Only filter 0 is affected by the power-on reset. All other filters stay uninitialized.
Refer to Section Software Reset.</description>
              <bitRange>[28:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Acceptance check for these bits of receive identifier enable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Acceptance check for these bits of receive identifier disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_VER_0</name>
          <description>Version Information 0 Register</description>
          <addressOffset>0xBC</addressOffset>
          <size>8</size>
          <access>read-only</access>
          <resetValue>0x09</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>VER_0</name>
              <description>Version (minor) [7-0]</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_VER_1</name>
          <description>Version Information 1 Register</description>
          <addressOffset>0xBD</addressOffset>
          <size>8</size>
          <access>read-only</access>
          <resetValue>0x07</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>VER_1</name>
              <description>Version (major) [15-0]</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_MEM_PROT</name>
          <description>Memory Protection Register</description>
          <addressOffset>0xCA</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>MAEIF</name>
              <description>Memory: Address Error Interrupt Flag.
This bit will be set if memory protection has detected an error in the address. The error was not corrected.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MDEIF</name>
              <description>Memory: Data Error Interrupt Flag.
This bit will be set if memory protection has detected an error in the data which was not correctable.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MDWIF</name>
              <description>Memory: Data Warning Interrupt Flag.
This bit will be set if the MDWIE bit is set and memory protection has detected an error in the data which has been automatically corrected. The system continues operation.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MDWIE</name>
              <description>Memory: Data Warning Interrupt Enable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MPEN</name>
              <description>Memory Protection Enable.
This bit is only writable if the CANFD_CFG_STAT[RESET] = 0x1.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_MEM_STAT</name>
          <description>Memory Status Register</description>
          <addressOffset>0xCB</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>HELOC</name>
              <description>Host Side Memory Error Location.
This bit field will be updated with every new error during a read access from the host side. This is sufficient, because read errors during read accesses from the CAN side will be signaled by the ACFA, TXS and TXB bits.
The HELOC bit field will only be updated in case of an error, but not in case of a warning caused by a corrected single bit error.</description>
              <bitRange>[4:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error during access from host side</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error during access from host side in TBUF</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Error during access from host side in RBUF</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Error during access from host side in ACF</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXB</name>
              <description>Transmission Block.
If the CANFD_MEM_PROT[MDEIF] or CANFD_MEM_PROT[MAEIF] bit is set because of an error while the CAN protocol machine is reading data for transmission, then the transmission is immediately blocked.
If the CANFD_SRCFG[SREIF] bit is set, then the transmission is immediately blocked too.
The TXB bit is reset if the CANFD_CFG_STAT[RESET] = 0x1.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Normal operation</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmission blocked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXS</name>
              <description>Transmission Stop.
If the CANFD_MEM_PROT[MDEIF] or CANFD_MEM_PROT[MAEIF] bit is set because of an error while the priority reordering machine accesses the memory, then any new transmission is stopped. If there is an active transmission, this will be completed before the stop, but if an error occurs during this transmission then no retransmission will be started.
The TXS bit is reset if the CANFD_CFG_STAT[RESET] = 0x1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Normal operation</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmission stopped</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ACFA</name>
              <description>Acceptance Filter Accept.
If the CANFD_MEM_PROT[MDEIF] or CANFD_MEM_PROT[MAEIF] bit is set because of an error in the address range of the ACF, this bit is set. Then acceptance filtering is disabled and all frames will be accepted.
The ACFA bit can be reset similar to an interrupt flag by writing a 0x1 to it. But because it will be set while the reception is still active, it is required to reset if later after the reception has been completed and the CANFD_RTIF[RIF] bit has been set.
This bit is also reset if the CANFD_CFG_STAT[RESET] = 0x1.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Normal operation of ACF</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ACF disabled: all received frames are accepted</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_MEM_ES_0</name>
          <description>Memory Error Stimulation 0 Register</description>
          <addressOffset>0xCC</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>MEAEE</name>
              <description>Memory Error: Address Error Enable.
If the MEAEE = 0x1 then the address bit 2 is flipped. The result is an access to the neighbor 32 bit word. The error is only triggered for the access defined by the CANFD_MEM_ES_2[MEEEC], CANFD_MEM_ES_2[MENEC], CANFD_MEM_ES_3[MEL] bit fields and the CANFD_MEM_ES_3[MES] bit.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ME1EE</name>
              <description>Memory Error: 1^st Error Enable.
If ME1EE = 0x1 then the MEBP1 bit field is used to do stimulation of a single bit error. To stimulate a dual bit error, the CANFD_MEM_ES_1[MEBP2] bit field and the CANFD_MEM_ES_1[ME2EE] bit needs to be used too. The error is only triggered for the access defined by the CANFD_MEM_ES_2[MEEEC], CANFD_MEM_ES_2[MENEC], CANFD_MEM_ES_3[MEL] bit fields and the CANFD_MEM_ES_3[MES] bit.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MEBP1</name>
              <description>Memory Error: Bit Position 1.
This bit field defines the position of one single bit error during memory read.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_MEM_ES_1</name>
          <description>Memory Error Stimulation 1 Register</description>
          <addressOffset>0xCD</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ME2EE</name>
              <description>Memory Error: 2^nd Error Enable.
If the ME2EE = 0x1 then the MEBP2 bit field is used to do stimulation of a single bit error. The error is only triggered for the access defined by the CANFD_MEM_ES_2[MEEEC], CANFD_MEM_ES_2[MENEC], CANFD_MEM_ES_3[MEL] bit fields and the CANFD_MEM_ES_3[MES] bit.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MEBP2</name>
              <description>Memory Error: Bit Position 2.
This bit field defines the position of one single bit error during memory read. To stimulate a dual bit error, the CANFD_MEM_ES_0[MEBP1] bit field and the CANFD_MEM_ES_0[ME1EE] bit needs to be used too.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_MEM_ES_2</name>
          <description>Memory Error Stimulation 2 Register</description>
          <addressOffset>0xCE</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>MENEC</name>
              <description>Memory Error: No Error Counter.
Error stimulation is delayed if the MEEEC bit field value &gt; 0.
The MEEEC bit field value is automatically decremented after each memory read access (defined by the CANFD_MEM_ES_3[MEL] bit field and the CANFD_MEM_ES_3[MES] bit) until it reaches the value 0x0.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEEEC</name>
              <description>Memory Error: Error Enable Counter.
Error stimulation is activated if the MENEC = 0x0 and the MEEEC bit field value &gt; 0.
This bit field is automatically decremented after each event of an error stimulation (defined by the CANFD_MEM_ES_3[MEL] bit field and the CANFD_MEM_ES_3[MES] bit) until it reaches the value 0x0.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_MEM_ES_3</name>
          <description>Memory Error Stimulation 3 Register</description>
          <addressOffset>0xCF</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>MES</name>
              <description>Memory Error Side.
This bit defines the side which will be hit by the next memory error together with the MEL bit field.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Host side</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CAN side</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MEL</name>
              <description>Memory Error Location.
This bit field defines the memory area which will be hit by the next memory error together with the MES bit.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>ACF</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>TBUF</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>RBUF</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>ACF</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_SRCFG</name>
          <description>Spatial Redundancy Configuration Register</description>
          <addressOffset>0xD0</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x01</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>SREEC</name>
              <description>Spatial Redundancy: Error Enable in CANFD_CLK Domain.
If the SREEC = 0x1 and SREN = 0x1, then output signal is flipped in the instance defined by the SRISEL bit. This results in a difference between the two instances which will be detected by the logic checker.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error stimulation</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error stimulation</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SREEH</name>
              <description>Spatial Redundancy: Error Enable in CANFD_HOST_CLK Domain.
If the SREEH = 0x1 and SREN = 0x1, then VERSION(15) is flipped in the instance defined by the SRISEL bit. As a consequence a read access to VERSION results in a difference between the two instances which will be detected by the logic checker.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error stimulation</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error stimulation</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SREIF</name>
              <description>Spatial Redundancy: Error Interrupt Flag.
If the SREN = 0x1 and if there is a severe mismatch between both instances of the logic core of the CAN controller then the SREIF and CANFD_MEM_STAT[TXB] bits will be set.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Interrupt pending</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRISEL</name>
              <description>Spatial Redundancy: Instance Selection.
If the SREN= 0x0 then this bit selects the instance, that is used for operation.
The SRISEL bit can only be modified if the CANFD_CFG_STAT[RESET] = 0x1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SREN</name>
              <description>Spatial Redundancy: Enable.
If enabled, then two instances of the logic core of the CAN controller are compared at runtime to each other. If this comparison is disabled then one of the two instances is used for operation as defined by the SRISEL bit.
This bit can only be modified if the CANFD_CFG_STAT[RESET] = 0x1.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CAN_CNT</name>
      <baseAddress>0x49037000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>12</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CANFD_CNTR_CTRL</name>
          <description>CANFD Counter Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>CNTR_CLEAR</name>
              <description>Clear the CANFD counter.</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CNTR_STOP</name>
              <description>Stop the CANFD counter.</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CNTR_START</name>
              <description>Start the CANFD counter.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_CNTR_LOW</name>
          <description>CANFD Counter Low Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTR_LO</name>
              <description>CANFD counter bits [31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_CNTR_HIGH</name>
          <description>CANFD Counter High Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTR_HI</name>
              <description>CANFD counter bits [63:32].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CLKCTL_PER_MST</name>
      <baseAddress>0x4903F000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>176</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CAMERA_PIXCLK_CTRL</name>
          <description>CPI Pixel Clock Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x01FF0000</resetValue>
          <resetMask>0x01FF0011</resetMask>
          <fields>
            <field>
              <name>CLK_DIVISOR</name>
              <description>Pixel clock divisor
n: Clock divided by n</description>
              <bitRange>[24:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Illegal values</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Illegal values</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Clock divided by 2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Clock divided by 3</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>Pixel clock select</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select 400 MHz clock source (SYST_ACLK)</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_ENA</name>
              <description>Pixel clock enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC200_PIXCLK_CTRL</name>
          <description>CDC Pixel Clock Control Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x01FF0000</resetValue>
          <resetMask>0x01FF0011</resetMask>
          <fields>
            <field>
              <name>CLK_DIVISOR</name>
              <description>Pixel clock divisor
n: Clock divided by n</description>
              <bitRange>[24:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Illegal values</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Illegal values</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Clock divided by 2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Clock divided by 3</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>Pixel clock select</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select 400 MHz clock source (SYST_ACLK)</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_ENA</name>
              <description>Pixel clock enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_PIXCLK_CTRL</name>
          <description>CSI Pixel Clock Control Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x01FF0000</resetValue>
          <resetMask>0x01FF0011</resetMask>
          <fields>
            <field>
              <name>CLK_DIVISOR</name>
              <description>Pixel clock divisor
n: Clock divided by n</description>
              <bitRange>[24:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Illegal values</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Illegal values</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Clock divided by 2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Clock divided by 3</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>Pixel clock select</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select 400 MHz clock source (SYST_ACLK)</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_ENA</name>
              <description>Pixel clock enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PERIPH_CLK_ENA</name>
          <description>Peripheral Clock Enable Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x11111113</resetMask>
          <fields>
            <field>
              <name>DSI_CKEN</name>
              <description>Enable clock for DSI</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CSI_CKEN</name>
              <description>Enable clock for CSI</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USB_CKEN</name>
              <description>Enable clock for USB</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SDC_CKEN</name>
              <description>Enable clock for SDMMC</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ETH_CKEN</name>
              <description>Enable clock for ETH</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GPU_CKEN</name>
              <description>Enable clock for GPU2D</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DMA_CKEN</name>
              <description>Enable clock for DMA0</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DPI_CKEN</name>
              <description>Enable clock for DPI controller (CDC)</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CPI_CKEN</name>
              <description>Enable clock for CPI</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DPHY_PLL_CTRL0</name>
          <description>MIPI-DPHY PLL Control Register 0</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x01331111</resetMask>
          <fields>
            <field>
              <name>PLL_SOC_GP_CLK_EN</name>
              <description>Enable signal for CLKOUT_GP clock</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_SOC_CLKSEL</name>
              <description>Control of PLL clock output selection</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clocks stopped</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clock generation</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Buffered clkext</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Forbidden</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PLL_SOC_GMP_CNTRL</name>
              <description>Controls the effective loop-filter resistance (=1/gmp) to increase/decrease MPLL bandwidth</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_SOC_SHADOW_CLEAR</name>
              <description>Shadow registers clear</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_SOC_UPDATEPLL</name>
              <description>Control for PLL operation frequency updated</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_SOC_SHADOW_CONTROL</name>
              <description>Selection of PLL configuration mechanism</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_SOC_FORCE_LOCK</name>
              <description>Force lock to device</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DPHY_PLL_CTRL1</name>
          <description>MIPI-DPHY PLL Control Register 1</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000F3FF</resetMask>
          <fields>
            <field>
              <name>PLL_SOC_N</name>
              <description>Control of the input frequency division ratio N (1 to 16) for device direct PLL control</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_SOC_M</name>
              <description>Control of the feedback multiplication ratio M (40 to 625) for device direct PLL control</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DPHY_PLL_CTRL2</name>
          <description>MIPI-DPHY PLL Control Register 2</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3F3F3F7F</resetMask>
          <fields>
            <field>
              <name>PLL_SOC_VCO_CNTRL</name>
              <description>VCO operating range for device direct PLL control</description>
              <bitRange>[29:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_SOC_PROP_CNTRL</name>
              <description>Proportional charge pump control for device direct PLL control</description>
              <bitRange>[21:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_SOC_INT_CNTRL</name>
              <description>Integral charge pump control for device direct PLL control</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_SOC_CPBIAS_CNTRL</name>
              <description>Charge pump bias control for device direct PLL control</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DPHY_PLL_STAT0</name>
          <description>MIPI-DPHY PLL Status Register 0</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xF3FF0311</resetMask>
          <fields>
            <field>
              <name>PLL_SOC_N</name>
              <description>Control of the input frequency division ratio N (1 to 16) for device direct PLL control</description>
              <bitRange>[31:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PLL_SOC_M</name>
              <description>Control of the feedback multiplication ratio M (40 to 625) for device direct PLL control</description>
              <bitRange>[25:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PLL_SOC_GMP_CNTRL</name>
              <description>Control of the effective loop-filter resistance (=1/gmp) to increase/decrease MPLL bandwidth</description>
              <bitRange>[9:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PLL_SOC_SHADOW_CONTROL</name>
              <description>Selection of PLL configuration mechanism</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PLL_SOC_LOCK</name>
              <description>Force lock to device</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DPHY_PLL_STAT1</name>
          <description>MIPI-DPHY PLL Status Register 1</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3F3F3F7F</resetMask>
          <fields>
            <field>
              <name>PLL_SOC_VCO_CNTRL</name>
              <description>VCO operating range for device direct PLL control</description>
              <bitRange>[29:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PLL_SOC_PROP_CNTRL</name>
              <description>Proportional charge pump control for device direct PLL control</description>
              <bitRange>[21:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PLL_SOC_INT_CNTRL</name>
              <description>Integral charge pump control for device direct PLL control</description>
              <bitRange>[13:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PLL_SOC_CPBIAS_CNTRL</name>
              <description>Charge pump bias control for device direct PLL control</description>
              <bitRange>[6:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_DPHY_CTRL0</name>
          <description>MIPI-DPHY TX Control Register 0</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFF7F311F</resetMask>
          <fields>
            <field>
              <name>CFGCLKFREQRANGE</name>
              <description>Input reference clock frequency</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HSFREQRANGE</name>
              <description>Module operating frequency</description>
              <bitRange>[22:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b0000000</name>
                  <description>Range - 80-97.125 Mbps; Default Bit Rate - 80 Mbps </description>
                  <value>0b0000000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0010000</name>
                  <description>Range - 80-107.625 Mbps; Default Bit Rate - 90 Mbps </description>
                  <value>0b0010000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0100000</name>
                  <description>Range - 83.125-118.125 Mbps; Default Bit Rate - 100 Mbps </description>
                  <value>0b0100000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0110000</name>
                  <description>Range - 92.625-128.625 Mbps; Default Bit Rate - 110 Mbps </description>
                  <value>0b0110000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0000001</name>
                  <description>Range - 102.125-139.125 Mbps; Default Bit Rate - 120 Mbps </description>
                  <value>0b0000001</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0010001</name>
                  <description>Range - 111.625-149.625 Mbps; Default Bit Rate - 130 Mbps </description>
                  <value>0b0010001</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0100001</name>
                  <description>Range - 121.125-160.125 Mbps; Default Bit Rate - 140 Mbps </description>
                  <value>0b0100001</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0110001</name>
                  <description>Range - 130.625-170.625 Mbps; Default Bit Rate - 150 Mbps </description>
                  <value>0b0110001</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0000010</name>
                  <description>Range - 140.125-181.125 Mbps; Default Bit Rate - 160 Mbps </description>
                  <value>0b0000010</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0010010</name>
                  <description>Range - 149.625-191.625 Mbps; Default Bit Rate - 170 Mbps </description>
                  <value>0b0010010</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0100010</name>
                  <description>Range - 159.125-202.125 Mbps; Default Bit Rate - 180 Mbps </description>
                  <value>0b0100010</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0110010</name>
                  <description>Range - 168.625-212.625 Mbps; Default Bit Rate - 190 Mbps </description>
                  <value>0b0110010</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0000011</name>
                  <description>Range - 182.875-228.375 Mbps; Default Bit Rate - 205 Mbps </description>
                  <value>0b0000011</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0010011</name>
                  <description>Range - 197.125-244.125 Mbps; Default Bit Rate - 220 Mbps </description>
                  <value>0b0010011</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0100011</name>
                  <description>Range - 211.375-259.875 Mbps; Default Bit Rate - 235 Mbps </description>
                  <value>0b0100011</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0110011</name>
                  <description>Range - 225.625-275.625 Mbps; Default Bit Rate - 250 Mbps </description>
                  <value>0b0110011</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0000100</name>
                  <description>Range - 249.375-301.875 Mbps; Default Bit Rate - 275 Mbps </description>
                  <value>0b0000100</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0010100</name>
                  <description>Range - 273.125-328.125 Mbps; Default Bit Rate - 300 Mbps </description>
                  <value>0b0010100</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0100101</name>
                  <description>Range - 296.875-354.375 Mbps; Default Bit Rate - 325 Mbps </description>
                  <value>0b0100101</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0110101</name>
                  <description>Range - 320.625-380.625 Mbps; Default Bit Rate - 350 Mbps </description>
                  <value>0b0110101</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0000101</name>
                  <description>Range - 368.125-433.125 Mbps; Default Bit Rate - 400 Mbps </description>
                  <value>0b0000101</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0010110</name>
                  <description>Range - 415.625-485.625 Mbps; Default Bit Rate - 450 Mbps </description>
                  <value>0b0010110</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0100110</name>
                  <description>Range - 463.125-538.125 Mbps; Default Bit Rate - 500 Mbps </description>
                  <value>0b0100110</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0110111</name>
                  <description>Range - 510.625-590.625 Mbps; Default Bit Rate - 550 Mbps </description>
                  <value>0b0110111</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0000111</name>
                  <description>Range - 558.125-643.125 Mbps; Default Bit Rate - 600 Mbps </description>
                  <value>0b0000111</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0011000</name>
                  <description>Range - 605.625-695.625 Mbps; Default Bit Rate - 650 Mbps </description>
                  <value>0b0011000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0101000</name>
                  <description>Range - 653.125-748.125 Mbps; Default Bit Rate - 700 Mbps </description>
                  <value>0b0101000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0111001</name>
                  <description>Range - 700.625-800.625 Mbps; Default Bit Rate - 750 Mbps </description>
                  <value>0b0111001</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0001001</name>
                  <description>Range - 748.125-853.125 Mbps; Default Bit Rate - 800 Mbps </description>
                  <value>0b0001001</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0011001</name>
                  <description>Range - 795.625-905.625 Mbps; Default Bit Rate - 850 Mbps </description>
                  <value>0b0011001</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0101001</name>
                  <description>Range - 843.125-958.125 Mbps; Default Bit Rate - 900 Mbps </description>
                  <value>0b0101001</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0111010</name>
                  <description>Range - 890.625-1010.625 Mbps; Default Bit Rate - 950 Mbps </description>
                  <value>0b0111010</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0001010</name>
                  <description>Range - 938.125-1063.125 Mbps; Default Bit Rate - 1000 Mbps </description>
                  <value>0b0001010</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0011010</name>
                  <description>Range - 985.625-1115.625 Mbps; Default Bit Rate - 1050 Mbps </description>
                  <value>0b0011010</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0101010</name>
                  <description>Range - 1033.125-1168.125 Mbps; Default Bit Rate - 1100 Mbps </description>
                  <value>0b0101010</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0111011</name>
                  <description>Range - 1080.625-1220.625 Mbps; Default Bit Rate - 1150 Mbps </description>
                  <value>0b0111011</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0001011</name>
                  <description>Range - 1128.125-1273.125 Mbps; Default Bit Rate - 1200 Mbps </description>
                  <value>0b0001011</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0011011</name>
                  <description>Range - 1175.625-1325.625 Mbps; Default Bit Rate - 1250 Mbps </description>
                  <value>0b0011011</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0101011</name>
                  <description>Range - 1223.125-1378.125 Mbps; Default Bit Rate - 1300 Mbps </description>
                  <value>0b0101011</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0111100</name>
                  <description>Range - 1270.625-1430.625 Mbps; Default Bit Rate - 1350 Mbps </description>
                  <value>0b0111100</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0001100</name>
                  <description>Range - 1318.125-1483.125 Mbps; Default Bit Rate - 1400 Mbps </description>
                  <value>0b0001100</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0011100</name>
                  <description>Range - 1365.625-1535.625 Mbps; Default Bit Rate - 1450 Mbps </description>
                  <value>0b0011100</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0101100</name>
                  <description>Range - 1413.125-1588.125 Mbps; Default Bit Rate - 1500 Mbps </description>
                  <value>0b0101100</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0111101</name>
                  <description>Range - 1460.625-1640.625 Mbps; Default Bit Rate - 1550 Mbps </description>
                  <value>0b0111101</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0001101</name>
                  <description>Range - 1508.125-1693.125 Mbps; Default Bit Rate - 1600 Mbps </description>
                  <value>0b0001101</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0011101</name>
                  <description>Range - 1555.625-1745.625 Mbps; Default Bit Rate - 1650 Mbps </description>
                  <value>0b0011101</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0101110</name>
                  <description>Range - 1603.125-1798.125 Mbps; Default Bit Rate - 1700 Mbps </description>
                  <value>0b0101110</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0111110</name>
                  <description>Range - 1650.625-1850.625 Mbps; Default Bit Rate - 1750 Mbps </description>
                  <value>0b0111110</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0001110</name>
                  <description>Range - 1698.125-1903.125 Mbps; Default Bit Rate - 1800 Mbps </description>
                  <value>0b0001110</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0011110</name>
                  <description>Range - 1745.625-1955.625 Mbps; Default Bit Rate - 1850 Mbps </description>
                  <value>0b0011110</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0101111</name>
                  <description>Range - 1793.125-2008.125 Mbps; Default Bit Rate - 1900 Mbps </description>
                  <value>0b0101111</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0111111</name>
                  <description>Range - 1840.625-2060.625 Mbps; Default Bit Rate - 1950 Mbps </description>
                  <value>0b0111111</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0001111</name>
                  <description>Range - 1888.125-2113.125 Mbps; Default Bit Rate - 2000 Mbps </description>
                  <value>0b0001111</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1000000</name>
                  <description>Range - 1935.625-2165.625 Mbps; Default Bit Rate - 2050 Mbps </description>
                  <value>0b1000000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1000001</name>
                  <description>Range - 1983.125-2218.125 Mbps; Default Bit Rate - 2100 Mbps </description>
                  <value>0b1000001</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1000010</name>
                  <description>Range - 2030.625-2270.625 Mbps; Default Bit Rate - 2150 Mbps </description>
                  <value>0b1000010</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1000011</name>
                  <description>Range - 2078.125-2323.125 Mbps; Default Bit Rate - 2200 Mbps </description>
                  <value>0b1000011</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1000100</name>
                  <description>Range - 2125.625-2375.625 Mbps; Default Bit Rate - 2250 Mbps </description>
                  <value>0b1000100</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1000101</name>
                  <description>Range - 2173.125-2428.125 Mbps; Default Bit Rate - 2300 Mbps </description>
                  <value>0b1000101</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1000110</name>
                  <description>Range - 2220.625-2480.625 Mbps; Default Bit Rate - 2350 Mbps </description>
                  <value>0b1000110</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1000111</name>
                  <description>Range - 2268.125-2500 Mbps; Default Bit Rate - 2400 Mbps </description>
                  <value>0b1000111</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1001000</name>
                  <description>Range - 2315.625-2500 Mbps; Default Bit Rate - 2450 Mbps </description>
                  <value>0b1001000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1001001</name>
                  <description>Range - 2363.125-2500 Mbps; Default Bit Rate - 2500 Mbps</description>
                  <value>0b1001001</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BASEDIR</name>
              <description>Configures the base direction for PHY data lane 0 (bit [12]) and data lane 1 (bit [13]).</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Configures lane as TX upon startup of the PHY</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Configures lane as RX</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXRXZ</name>
              <description>Selects master or slave configuration for the PHY. The configuration applies to all the PHY lanes (data and clock).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slave-side D-PHY implementation</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Master-side D-PHY implementation</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TESTPORT_SEL</name>
              <description>Test port select</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select TX_TESTPORT</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select RX_TESTPORT</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CONT_EN</name>
              <description>This bit places the PHY in IO continuity test mode. All other PHY control bits should be placed in their default values.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BIST_OK</name>
              <description>BIST OK</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BIST_DONE</name>
              <description>BIST done</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BIST_ON</name>
              <description>BIST ON</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_DPHY_CTRL1</name>
          <description>MIPI-DPHY TX Control Register 1</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0007FFFF</resetMask>
          <fields>
            <field>
              <name>CONT_DATA</name>
              <description>Continuity data. Each pin of this output bus is used to verify the continuity from the
chips pin all the way to the PHY's analog ports (package, bonding,
die, among others).</description>
              <bitRange>[18:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TURNREQUEST</name>
              <description>Controls TURNREQUEST pin of DPHY (bit [6] for data lane 0; bit [7] for data lane 1)</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TURNDISABLE</name>
              <description>Controls TURNDISABLE pin of DPHY (bit [4] for data lane 0; bit [5] for data lane 1)</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCETXSTOPMODE</name>
              <description>Controls FORCETXSTOPMODE pin of DPHY (bit [2] for data lane 0; bit [3] for data lane 1)</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCERXMODE</name>
              <description>Controls FORCERXMODE pin of DPHY (bit [0] for data lane 0; bit [1] for data lane 1)</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DPHY_CTRL0</name>
          <description>MIPI-DPHY RX Control Register 0</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFF7F311F</resetMask>
          <fields>
            <field>
              <name>CFGCLKFREQRANGE</name>
              <description>Input reference clock frequency</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HSFREQRANGE</name>
              <description>Module operating frequency</description>
              <bitRange>[22:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b0000000</name>
                  <description>Range - 80-97.125 Mbps; Default Bit Rate - 80 Mbps </description>
                  <value>0b0000000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0010000</name>
                  <description>Range - 80-107.625 Mbps; Default Bit Rate - 90 Mbps </description>
                  <value>0b0010000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0100000</name>
                  <description>Range - 83.125-118.125 Mbps; Default Bit Rate - 100 Mbps </description>
                  <value>0b0100000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0110000</name>
                  <description>Range - 92.625-128.625 Mbps; Default Bit Rate - 110 Mbps </description>
                  <value>0b0110000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0000001</name>
                  <description>Range - 102.125-139.125 Mbps; Default Bit Rate - 120 Mbps </description>
                  <value>0b0000001</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0010001</name>
                  <description>Range - 111.625-149.625 Mbps; Default Bit Rate - 130 Mbps </description>
                  <value>0b0010001</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0100001</name>
                  <description>Range - 121.125-160.125 Mbps; Default Bit Rate - 140 Mbps </description>
                  <value>0b0100001</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0110001</name>
                  <description>Range - 130.625-170.625 Mbps; Default Bit Rate - 150 Mbps </description>
                  <value>0b0110001</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0000010</name>
                  <description>Range - 140.125-181.125 Mbps; Default Bit Rate - 160 Mbps </description>
                  <value>0b0000010</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0010010</name>
                  <description>Range - 149.625-191.625 Mbps; Default Bit Rate - 170 Mbps </description>
                  <value>0b0010010</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0100010</name>
                  <description>Range - 159.125-202.125 Mbps; Default Bit Rate - 180 Mbps </description>
                  <value>0b0100010</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0110010</name>
                  <description>Range - 168.625-212.625 Mbps; Default Bit Rate - 190 Mbps </description>
                  <value>0b0110010</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0000011</name>
                  <description>Range - 182.875-228.375 Mbps; Default Bit Rate - 205 Mbps </description>
                  <value>0b0000011</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0010011</name>
                  <description>Range - 197.125-244.125 Mbps; Default Bit Rate - 220 Mbps </description>
                  <value>0b0010011</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0100011</name>
                  <description>Range - 211.375-259.875 Mbps; Default Bit Rate - 235 Mbps </description>
                  <value>0b0100011</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0110011</name>
                  <description>Range - 225.625-275.625 Mbps; Default Bit Rate - 250 Mbps </description>
                  <value>0b0110011</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0000100</name>
                  <description>Range - 249.375-301.875 Mbps; Default Bit Rate - 275 Mbps </description>
                  <value>0b0000100</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0010100</name>
                  <description>Range - 273.125-328.125 Mbps; Default Bit Rate - 300 Mbps </description>
                  <value>0b0010100</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0100101</name>
                  <description>Range - 296.875-354.375 Mbps; Default Bit Rate - 325 Mbps </description>
                  <value>0b0100101</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0110101</name>
                  <description>Range - 320.625-380.625 Mbps; Default Bit Rate - 350 Mbps </description>
                  <value>0b0110101</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0000101</name>
                  <description>Range - 368.125-433.125 Mbps; Default Bit Rate - 400 Mbps </description>
                  <value>0b0000101</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0010110</name>
                  <description>Range - 415.625-485.625 Mbps; Default Bit Rate - 450 Mbps </description>
                  <value>0b0010110</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0100110</name>
                  <description>Range - 463.125-538.125 Mbps; Default Bit Rate - 500 Mbps </description>
                  <value>0b0100110</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0110111</name>
                  <description>Range - 510.625-590.625 Mbps; Default Bit Rate - 550 Mbps </description>
                  <value>0b0110111</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0000111</name>
                  <description>Range - 558.125-643.125 Mbps; Default Bit Rate - 600 Mbps </description>
                  <value>0b0000111</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0011000</name>
                  <description>Range - 605.625-695.625 Mbps; Default Bit Rate - 650 Mbps </description>
                  <value>0b0011000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0101000</name>
                  <description>Range - 653.125-748.125 Mbps; Default Bit Rate - 700 Mbps </description>
                  <value>0b0101000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0111001</name>
                  <description>Range - 700.625-800.625 Mbps; Default Bit Rate - 750 Mbps </description>
                  <value>0b0111001</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0001001</name>
                  <description>Range - 748.125-853.125 Mbps; Default Bit Rate - 800 Mbps </description>
                  <value>0b0001001</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0011001</name>
                  <description>Range - 795.625-905.625 Mbps; Default Bit Rate - 850 Mbps </description>
                  <value>0b0011001</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0101001</name>
                  <description>Range - 843.125-958.125 Mbps; Default Bit Rate - 900 Mbps </description>
                  <value>0b0101001</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0111010</name>
                  <description>Range - 890.625-1010.625 Mbps; Default Bit Rate - 950 Mbps </description>
                  <value>0b0111010</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0001010</name>
                  <description>Range - 938.125-1063.125 Mbps; Default Bit Rate - 1000 Mbps </description>
                  <value>0b0001010</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0011010</name>
                  <description>Range - 985.625-1115.625 Mbps; Default Bit Rate - 1050 Mbps </description>
                  <value>0b0011010</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0101010</name>
                  <description>Range - 1033.125-1168.125 Mbps; Default Bit Rate - 1100 Mbps </description>
                  <value>0b0101010</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0111011</name>
                  <description>Range - 1080.625-1220.625 Mbps; Default Bit Rate - 1150 Mbps </description>
                  <value>0b0111011</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0001011</name>
                  <description>Range - 1128.125-1273.125 Mbps; Default Bit Rate - 1200 Mbps </description>
                  <value>0b0001011</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0011011</name>
                  <description>Range - 1175.625-1325.625 Mbps; Default Bit Rate - 1250 Mbps </description>
                  <value>0b0011011</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0101011</name>
                  <description>Range - 1223.125-1378.125 Mbps; Default Bit Rate - 1300 Mbps </description>
                  <value>0b0101011</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0111100</name>
                  <description>Range - 1270.625-1430.625 Mbps; Default Bit Rate - 1350 Mbps </description>
                  <value>0b0111100</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0001100</name>
                  <description>Range - 1318.125-1483.125 Mbps; Default Bit Rate - 1400 Mbps </description>
                  <value>0b0001100</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0011100</name>
                  <description>Range - 1365.625-1535.625 Mbps; Default Bit Rate - 1450 Mbps </description>
                  <value>0b0011100</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0101100</name>
                  <description>Range - 1413.125-1588.125 Mbps; Default Bit Rate - 1500 Mbps </description>
                  <value>0b0101100</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0111101</name>
                  <description>Range - 1460.625-1640.625 Mbps; Default Bit Rate - 1550 Mbps </description>
                  <value>0b0111101</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0001101</name>
                  <description>Range - 1508.125-1693.125 Mbps; Default Bit Rate - 1600 Mbps </description>
                  <value>0b0001101</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0011101</name>
                  <description>Range - 1555.625-1745.625 Mbps; Default Bit Rate - 1650 Mbps </description>
                  <value>0b0011101</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0101110</name>
                  <description>Range - 1603.125-1798.125 Mbps; Default Bit Rate - 1700 Mbps </description>
                  <value>0b0101110</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0111110</name>
                  <description>Range - 1650.625-1850.625 Mbps; Default Bit Rate - 1750 Mbps </description>
                  <value>0b0111110</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0001110</name>
                  <description>Range - 1698.125-1903.125 Mbps; Default Bit Rate - 1800 Mbps </description>
                  <value>0b0001110</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0011110</name>
                  <description>Range - 1745.625-1955.625 Mbps; Default Bit Rate - 1850 Mbps </description>
                  <value>0b0011110</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0101111</name>
                  <description>Range - 1793.125-2008.125 Mbps; Default Bit Rate - 1900 Mbps </description>
                  <value>0b0101111</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0111111</name>
                  <description>Range - 1840.625-2060.625 Mbps; Default Bit Rate - 1950 Mbps </description>
                  <value>0b0111111</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b0001111</name>
                  <description>Range - 1888.125-2113.125 Mbps; Default Bit Rate - 2000 Mbps </description>
                  <value>0b0001111</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1000000</name>
                  <description>Range - 1935.625-2165.625 Mbps; Default Bit Rate - 2050 Mbps </description>
                  <value>0b1000000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1000001</name>
                  <description>Range - 1983.125-2218.125 Mbps; Default Bit Rate - 2100 Mbps </description>
                  <value>0b1000001</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1000010</name>
                  <description>Range - 2030.625-2270.625 Mbps; Default Bit Rate - 2150 Mbps </description>
                  <value>0b1000010</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1000011</name>
                  <description>Range - 2078.125-2323.125 Mbps; Default Bit Rate - 2200 Mbps </description>
                  <value>0b1000011</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1000100</name>
                  <description>Range - 2125.625-2375.625 Mbps; Default Bit Rate - 2250 Mbps </description>
                  <value>0b1000100</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1000101</name>
                  <description>Range - 2173.125-2428.125 Mbps; Default Bit Rate - 2300 Mbps </description>
                  <value>0b1000101</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1000110</name>
                  <description>Range - 2220.625-2480.625 Mbps; Default Bit Rate - 2350 Mbps </description>
                  <value>0b1000110</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1000111</name>
                  <description>Range - 2268.125-2500 Mbps; Default Bit Rate - 2400 Mbps </description>
                  <value>0b1000111</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1001000</name>
                  <description>Range - 2315.625-2500 Mbps; Default Bit Rate - 2450 Mbps </description>
                  <value>0b1001000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1001001</name>
                  <description>Range - 2363.125-2500 Mbps; Default Bit Rate - 2500 Mbps</description>
                  <value>0b1001001</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BASEDIR</name>
              <description>Configures the base direction for PHY data lane 0 (bit [12]) and data lane 1 (bit [13]).</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Configures lane as TX upon startup of the PHY</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Configures lane as RX</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXRXZ</name>
              <description>Selects master or slave configuration for the PHY. The configuration applies to all the PHY lanes (data and clock).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slave-side D-PHY implementation</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Master-side D-PHY implementation</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TESTPORT_SEL</name>
              <description>Test port select</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select TX_TESTPORT</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select RX_TESTPORT</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CONT_EN</name>
              <description>This bit places the PHY in IO continuity test mode. All other PHY control bits should be placed in their default values.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BIST_OK</name>
              <description>BIST OK</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BIST_DONE</name>
              <description>BIST done</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BIST_ON</name>
              <description>BIST ON</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DPHY_CTRL1</name>
          <description>MIPI-DPHY RX Control Register 1</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0007FFFF</resetMask>
          <fields>
            <field>
              <name>CONT_DATA</name>
              <description>Continuity data. Each pin of this output bus is used to verify the continuity from the
chips pin all the way to the PHY's analog ports (package, bonding,
die, among others).</description>
              <bitRange>[18:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TURNREQUEST</name>
              <description>Controls TURNREQUEST pin of DPHY (bit [6] for data lane 0; bit [7] for data lane 1)</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TURNDISABLE</name>
              <description>Controls TURNDISABLE pin of DPHY (bit [4] for data lane 0; bit [5] for data lane 1)</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCETXSTOPMODE</name>
              <description>Controls FORCETXSTOPMODE pin of DPHY (bit [2] for data lane 0; bit [3] for data lane 1)</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCERXMODE</name>
              <description>Controls FORCERXMODE pin of DPHY (bit [0] for data lane 0; bit [1] for data lane 1)</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MIPI_CKEN</name>
          <description>MIPI-DPHY Clock Enable Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001111</resetMask>
          <fields>
            <field>
              <name>BYPASS_CKEN</name>
              <description>Enable bypass clock for MIPI D-PHY PLL</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable bypass clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable bypass clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PLLREF_CKEN</name>
              <description>Enable reference clock for MIPI D-PHY PLL</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXDPHY_CKEN</name>
              <description>Enable configure clock for RX D-PHY</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXDPHY_CKEN</name>
              <description>Enable configure clock for TX D-PHY</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_CTRL</name>
          <description>DSI Control Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000711</resetMask>
          <fields>
            <field>
              <name>PHYSEL_TX_RXN</name>
              <description>DSI PHY direction select</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Rx</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Tx</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CAM2_EN</name>
              <description>Second camera port enable</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSI_EDPI_HALT</name>
              <description>DSI EDPI halt status</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DSI_COLOR_MODE</name>
              <description>DSI color mode</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSI_UPD_CFG</name>
              <description>DSI update configuration</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_CTRL</name>
          <description>DMA0 Boot Control Register</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x00010001</resetMask>
          <fields>
            <field>
              <name>SW_RST</name>
              <description>Software reset for DMA0</description>
              <bitRange>[16:16]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No reset</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Reset DMA0. This bit is self-cleared.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BOOT_MANAGER</name>
              <description>When DMA0 exits from reset, this bit controls the security state of the DMA manager thread</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Assigns DMA manager to the secure state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Assigns DMA manager to the non-secure state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_IRQ</name>
          <description>DMA0 Boot IRQ Non-Secure Register</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BOOT_IRQ</name>
              <description>Controls the security state of an event-interrupt resource, when DMA0 exits from reset</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DMA0 assigns event x or IRQ[x] to the secure state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA0 assigns event x or IRQ[x] to the non-secure state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_PERIPH</name>
          <description>DMA0 Boot Peripheral Non-Secure Register</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BOOT_PERIPH</name>
              <description>Controls the security state of a peripheral request interface, when DMA0 exits from reset</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DMA0 assigns peripheral request interface x to the secure state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA0 assigns peripheral request interface x to the non-secure state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_GLITCH_FLT</name>
          <description>DMA0 Glitch Filter Register</description>
          <addressOffset>0x7C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ENA</name>
              <description>Enable glitch filter for each DMA0 channel. One bit per channel.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable the glitch filter</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable the glitch filter</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_CTRL0</name>
          <description>ETH Control Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>RMII_CLKSEL</name>
              <description>Select RMII clock source</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RMII clock source from ETH_REFCLK pin</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RMII clock source from internal 50 MHz PLL clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SBD_FLOWCTRL_I</name>
              <description>ETH sideband flow control
When set to 0x1, instructs the MAC to transmit Pause frames in full-duplex mode. In half-duplex mode, the MAC enables the backpressure function until this bit is set to 0x0.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWR_CLAMP_CTRL_I</name>
              <description>ETH always-ON logic reset control</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>ETH always-ON logic is not in reset (resets are inactive)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ETH always-ON logic is in reset (resets are active)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PWR_ISOLATE_I</name>
              <description>Isolation cells enable
The isolation cells isolate the signals of the ETH powered-OFF domain from the always-ON domain.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Isolation cells disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Isolation cells enabled and provide required signal values to the ETH always-ON domain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PWR_DOWN_CTRL_I</name>
              <description>ETH power down control</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Power ON. The whole ETH module is powered-ON.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Power OFF. All ETH blocks are powered-OFF except the always-ON logic.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_STAT0</name>
          <description>ETH Status Register</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000020</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>MAC_SPEED_O</name>
              <description>Indicates the MAC speed mode selected</description>
              <bitRange>[5:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>10 Mbps</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>100 Mbps</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SBD_PWR_DOWN_ACK_O</name>
              <description>ETH power-down sequence acknowledge</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Power-down not acknowledged. ETH power-down sequence cannot be started.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Power-down acknowledged. ETH power-down sequence can be started.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SBD_INTR_O</name>
              <description>This bit reflects the value of the ETH_SBD_IRQ interrupt</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_PTP_TMST0</name>
          <description>ETH Timestamp Register 0</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ETH_PTP_TMST</name>
              <description>ETH PTP timestamp output value - bits[31-0]</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_PTP_TMST1</name>
          <description>ETH Timestamp Register 1</description>
          <addressOffset>0x8C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ETH_PTP_TMST</name>
              <description>ETH PTP timestamp output value - bits[63-32]</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDC_CTRL0</name>
          <description>SDMMC Control Register</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000000F</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>INT_TMCLK_STABLE</name>
              <description>Internal TMCLK stable
Indicates stability of internal clock to SDMMC controller</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_BCLK_STABLE</name>
              <description>Internal BCLK stable
Indicates stability of internal clock to SDMMC controller</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_ACLK_STABLE</name>
              <description>Internal ACLK stable
Indicates stability of internal clock to SDMMC controller</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST_REG_VOL_STABLE</name>
              <description>Indicates stability of host regulator voltage to SDMMC controller</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDC_STAT0</name>
          <description>SDMMC Status Register 0</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00001000</resetValue>
          <resetMask>0x00003FFF</resetMask>
          <fields>
            <field>
              <name>CARD_CLK_FREQ_SEL</name>
              <description>Card clock frequency select</description>
              <bitRange>[13:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>100 MHz</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>50 MHz</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>25 MHz</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>12.5 MHz</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x10</name>
                  <description>6.25 MHz</description>
                  <value>0x10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x20</name>
                  <description>3.125 MHz</description>
                  <value>0x20</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x40</name>
                  <description>1.56 MHz</description>
                  <value>0x40</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x80</name>
                  <description>781.25 kHz</description>
                  <value>0x80</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x100</name>
                  <description>390.625 kHz</description>
                  <value>0x100</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x200</name>
                  <description>195.312 kHz</description>
                  <value>0x200</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_CLK_GEN_SEL</name>
              <description>Card clock generator mode</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Divided clock mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Programmable clock mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_CLK_EN</name>
              <description>Card clock PLL enable</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CLK2CARD_ON</name>
              <description>Control to switch on clock supplied to the card</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INTCLK_EN</name>
              <description>Internal clock request. When
this is 0, ACLK and BCLK can be stopped.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDC_STAT1</name>
          <description>SDMMC Status Register 1</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>UHS1_DRV_STH</name>
              <description>UHS-I driver strength select
Host controller indicates output driver strength in 1.8-V signaling. In 3.3-V signaling, this output is not effective.</description>
              <bitRange>[6:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Driver Type B (Default)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Driver Type A</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Driver Type C</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Driver Type D</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UHS1_SWVOLT_EN</name>
              <description>Switch voltage from 3.3 V to 1.8 V for UHS-I
This bit is a command to external voltage regulator to switch voltage from 3.3V to 1.8V.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>3.3-V SD card signaling</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>1.8-V SD card signaling</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SD_VDD1_SEL</name>
              <description>Select VDD1 voltage level for SD card/eMMC</description>
              <bitRange>[3:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>1.8V</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>3.0V</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>3.3V</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SD_VDD1_ON</name>
              <description>Switch on VDD1/VDD bus power for SD card/eMMC</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USB_GPIO0</name>
          <description>USB GPIO Register</description>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GP_OUT</name>
              <description>USB GPIO output</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GP_IN</name>
              <description>USB GPIO input</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USB_STAT0</name>
          <description>USB Status Register</description>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PME_GENERATION</name>
              <description>PME generation output</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HOST_LEGACY_SMI_INTERRUPT</name>
              <description>Host legacy SMI interrupt output</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HUB_VBUS_CTRL</name>
              <description>Host VBUS control output</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HOST_SYSTEM_ERR</name>
              <description>Host system error output</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HOST_CURRENT_BELT</name>
              <description>Host current belt output</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USB_CTRL1</name>
          <description>USB Control Register 1</description>
          <addressOffset>0xA8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>HOST_LEGACY_SMI_BAR_WR</name>
              <description>PCI Base Address Register (BAR) write: one clock pulse. The PCIe interface need to generate one clock pulse during PCIe BAR write.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST_LEGACY_SMI_PCI_CMD_REG_WR</name>
              <description>PCI command register write: one clock pulse. The PCIe interface needs to generate one clock pulse during PCIe command register write.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST_MSI_ENABLE</name>
              <description>This enables the pulse type interrupt signal (one bus clock cycle) interrupt port instead of level-sensitive interrupt. When interfacing to PCIe, this allows the user to easily map interrupt to MSI in the PCIe controller.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST_PORT_POWER_CONTROL_PRESENT</name>
              <description>This bit defines the bit [3] of Capability Parameters (HCCPARAMS). This indicates whether the host controller implementation includes port power control.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Port does not have port power switches</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Port has port power switches</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HOST_U2_PORT_DISABLE</name>
              <description>USB 2.0 Port Disable Control
This bit should either be static (should not change during operation) or change only once from 0x0 to 0x1 during operation and stay at 0x1 after that.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Port enabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Port disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HOST_NUM_U2_PORT</name>
              <description>Number of USB 2.0 ports</description>
              <bitRange>[5:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HUB_PORT_PERM_ATTACH</name>
              <description>Indicates if the device attached to a downstream port is permanently attached or not</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not permanently attached</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Permanently attached</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HUB_PORT_OVERCURRENT</name>
              <description>This is the port over-current indication of the root-hub ports</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No over-current</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Over-current</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>USB_CTRL2</name>
          <description>USB Control Register 2</description>
          <addressOffset>0xAC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000100</resetValue>
          <resetMask>0x0000017F</resetMask>
          <fields>
            <field>
              <name>POR_RST_MASK</name>
              <description>Active-high USB PHY PoR reset mask. Must be set/cleared during PHY power-down/up sequence.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PME_EN</name>
              <description>Power management enable of USB</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLADJ_30MHZ_REG</name>
              <description>Frequency adjust value of USB</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPU2D</name>
      <baseAddress>0x49040000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>236</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>GPU2D_CONTROL</name>
          <description>Geometry Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2C_LIMITERPRECISION</name>
              <description>Limiter precision is increased by 6 (10.22)</description>
              <bitRange>[24:24]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_SPANSTORE</name>
              <description>Enable span store</description>
              <bitRange>[23:23]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_SPANABORT</name>
              <description>Enable span abort</description>
              <bitRange>[22:22]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_UNIONCD</name>
              <description>Combine (AB)/(56) as union</description>
              <bitRange>[21:21]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_UNIONAB</name>
              <description>Combine (12)/(34) as union</description>
              <bitRange>[20:20]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_UNION56</name>
              <description>Combine 5/6 as union (+) otherwise intersect (*)</description>
              <bitRange>[19:19]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_UNION34</name>
              <description>Combine 3/4 as union (+) otherwise intersect (*)</description>
              <bitRange>[18:18]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_UNION12</name>
              <description>Combine 1/2 as union (+) otherwise intersect (*)</description>
              <bitRange>[17:17]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_BAND1ENABLE</name>
              <description>Band filter N enable
Bit 16: Band filter 2 enable
Bit 15: Band filter 1 enable</description>
              <bitRange>[16:15]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_LIMNTHRESHOLD</name>
              <description>Limiter N threshold enable
Bit 14: Limiter 6 threshold enable
Bit 13: Limiter 5 threshold enable
Bit 12: Limiter 4 threshold enable 
Bit 11: Limiter 3 threshold enable
Bit 10: Limiter 2 threshold enable
Bit 9: Limiter 1 threshold enable</description>
              <bitRange>[14:9]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_QUADNENABLE</name>
              <description>Quadratic coupling N enable
Bit 8: Quadratic coupling 3 enable
Bit 7: Quadratic coupling 2 enable
Bit 6: Quadratic coupling 1 enable</description>
              <bitRange>[8:6]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_LIMNENABLE</name>
              <description>Limiter N enable
Bit 5: Limiter 6 enable
Bit 4: Limiter 5 enable
Bit 3: Limiter 4 enable 
Bit 2: Limiter 3 enable
Bit 1: Limiter 2 enable
Bit 0: Limiter 1 enable</description>
              <bitRange>[5:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_STATUS</name>
          <description>Status Control Register</description>
          <alternateRegister>GPU2D_CONTROL</alternateRegister>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2C_BUS_ERROR_SRC</name>
              <bitRange>[10:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MFB bus error</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>MTX bus error</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>MDL bus error</description>
                  <value>0x4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_IRQ_BUS_ERROR</name>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No bus error occurred or interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Bus error interrupt triggered</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_IRQ_DLIST</name>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Display list not finished or interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Display list finished interrupt triggered</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_IRQ_ENUM</name>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Enumeration not finished or interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enumeration finished interrupt triggered</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_DLISTACTIVE</name>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Display list reader is idle</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Display list reader busy, no direct access to registers</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_CACHE_DIRTY</name>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Framebuffer cache is not dirty</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Framebuffer cache is dirty, frame should not be flipped</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_BUSY_WRITE</name>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Framebuffer writeback finished</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Framebuffer writeback busy, framebuffer type can not be changed</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_BUSY_ENUM</name>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Enumeration unit idle</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enumeration unit busy, new primitive can not be started</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_CONTROL2</name>
          <description>Surface Control Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2C_RLE_PIXEL_WIDTH</name>
              <description>Width of a texel for the RLE unit:</description>
              <bitRange>[31:30]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1 byte per texel</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>2 bytes per texel</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>3 bytes per texel</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>4 bytes per texel</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_BDIA</name>
              <description>If bit D2C_USE_ ACB == 1:</description>
              <bitRange>[29:29]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Use blend factor as specified through bit D2C_BDFA</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Invert destination blend factor (1-x)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_BSIA</name>
              <description>If bit D2C_USE_ ACB == 1:</description>
              <bitRange>[28:28]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Use blend factor as specified through bit D2C_BSFA</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Invert source blend factor (1-x)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_CLUTFORMAT</name>
              <bitRange>[27:27]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>ARGB8888 (default)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RGB565</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_COLKEY_ENABLE</name>
              <description>Enable the color keying unit.</description>
              <bitRange>[26:26]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_CLUT_ENABLE</name>
              <description>Enables the CLUT. If CLUT is not enabled for an indexed format, the index will be directly put on the internal R, G, B channels.</description>
              <bitRange>[25:25]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_RLE_ENABLE</name>
              <description>Enables the RLE unit.</description>
              <bitRange>[24:24]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_WRITEALPHA</name>
              <description>If bit D2C_USE_ ACB == 0:
Set the 'alpha source' for the framebuffer.
0x0: Use alpha from color2
0x1: Use source alpha (pixel coverage)
0x2: Use 0.0 as alpha 
0x3: Use alpha from framebuffer
If bit D2C_USE_ ACB == 1:
0x0: BC2A is 1. Use destination alpha from color2
0x1, 0x2, or 0x3 = BC2A is 0. Use destination alpha</description>
              <bitRange>[23:22]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_WRITEFORMAT</name>
              <description>Pixel format of the framebuffer. This includes configuring the D2C_WRITEFORMAT3 bit.
0x0: ALPHA8 (1 bpp)
0x1: RGB565 (2 bpp)
0x2: ARGB8888 (4 bpp)
0x3: ARGB4444 (2 bpp)
0x6: RGBA8888 (4 bpp)
0x7: RGBA4444 (2 bpp)</description>
              <bitRange>[21:20]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_READFORMAT</name>
              <description>Pixel format of the texture buffer. This includes configuring the D2C_READFORMAT3 and D2C_READFORMAT4 bits.
0x0: ALPHA8 (1 bpp)
0x1: RGB565 (2 bpp)
0x2: ARGB8888 and RGB888 (4 bpp)
0x3: ARGB4444 and RGB444 (2 bpp)
0x4: ARGB1555 and RGB555 (2 bpp)
0x5: AI44: 4-bit alpha, 4-bit indexed color (1 bpp)
0x6: RGBA8888 (4 bpp)
0x7: RGBA4444 (2 bpp)
0x8: RGBA5551 (2 bpp)
0x9: I8, 8-bit indexed color (1 bpp)
0xA: I4, 4-bit indexed color (2 ppb)
0xB: I2, 2-bit indexed color (4 ppb)
0xC: I1, 1-bit indexed color (8 ppb)</description>
              <bitRange>[19:18]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_TEXTUREFILTERY</name>
              <bitRange>[17:17]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No filtering on texture V-axis</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Linear filtering on texture V-axis</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_TEXTUREFILTERX</name>
              <bitRange>[16:16]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No filtering on texture U-axis</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Linear filtering on texture U-axis</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_TEXTURECLAMPY</name>
              <bitRange>[15:15]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Mask texture V-coordinate</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clamp texture V-coordinate</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_TEXTURECLAMPX</name>
              <bitRange>[14:14]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Mask texture U-coordinate</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clamp texture U-coordinate</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_BC2</name>
              <description>Blend color2 instead of framebuffer pixel</description>
              <bitRange>[13:13]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Use pixel from framebuffer as destination</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Use color2 as destination</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_BDI</name>
              <bitRange>[12:12]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Use blend factor as specified through bit D2C_BDF</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Invert destination blend factor (1-x)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_BSI</name>
              <bitRange>[11:11]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Use blend factor as specified through bit D2C_BSF</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Invert source blend factor (1-x)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_BDF</name>
              <bitRange>[10:10]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Use 1.0 as destination blend factor</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Use alpha as destination blend factor</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_BSF</name>
              <bitRange>[9:9]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Use 1.0 as source blend factor</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Use alpha as source blend factor</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_WRITEFORMAT3</name>
              <description>Third bit of the framebuffer format. 
See bit D2C_WRITEFORMAT for description.</description>
              <bitRange>[8:8]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_BDFA</name>
              <description>If bit D2C_USE_ ACB == 1:</description>
              <bitRange>[7:7]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Use 1.0 as destination blend factor for alpha channel</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Use alpha as destination blend factor for alpha channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_BSFA</name>
              <description>If bit D2C_USE_ ACB == 1:</description>
              <bitRange>[6:6]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Use 1.0 as source blend factor for alpha channel</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Use alpha as source blend factor for alpha channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_READFORMAT4</name>
              <description>Fourth bit of the texture buffer format. 
See bit D2C_READFORMAT for description.</description>
              <bitRange>[5:5]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_READFORMAT3</name>
              <description>Third bit of the texture buffer format. 
See bit D2C_READFORMAT for description</description>
              <bitRange>[4:4]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_USE_ACB</name>
              <description> (see bit D2C_WRITEFORMAT)
 (see bits D2C_BSFA, D2C_BDFA, D2C_BSIA, 
 D2C_BDIA, D2C_WRITEFORMAT)</description>
              <bitRange>[3:3]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Use 'write alpha' mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Use full alpha channel blending mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_PATTERNSOURCEL5</name>
              <description>Limiter 5 is used as pattern index instead of the default U-limiter</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_TEXTUREENABLE</name>
              <description>Pixel source is read from texture and used as an alpha to blend between GPU2D_COLOR1 and GPU2D_COLOR2.</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable texture</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable texture</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_PATTERNENABLE</name>
              <description>Pixel source is a pattern color (blend of GPU2D_COLOR1 and GPU2D_COLOR2 depending on GPU2D_PATTERN and pattern index)</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable pattern</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable pattern</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_HWREVISION</name>
          <description>Hardware Version and Feature Set ID Register</description>
          <alternateRegister>GPU2D_CONTROL2</alternateRegister>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0FBE000B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ALPHACHANNELBLENDING</name>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ACB is available</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HILIMITERPRECISION</name>
              <bitRange>[26:26]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>QLimiter can be switched to high precision</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COLORKEY</name>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Color keying available</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TEXCLUT256</name>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CLUT size is 256 entries</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RLEUNIT</name>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RLE unit available</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TEXCLUT</name>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CLUT vailable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PERFCOUNT</name>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Two performance counters available</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXCACHE</name>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Texture cache available</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FBCACHE</name>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Framebuffer cache available</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DLR</name>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Display list reader available</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SWDAVE</name>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Hardware GPU2D</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GPU2DTYPE</name>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>GPU2D 2D-TS</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REVISIONNUMBER</name>
              <description>Reserved</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L1START</name>
          <description>Geometry Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L1START</name>
              <description>Start value of the 1st limiter. The start value is a 16:16 fixed-point number valid at the first pixel of the bounding box.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L2START</name>
          <description>Geometry Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L2START</name>
              <description>Start value of the 2nd limiter. The start value is a 16:16 fixed-point number valid at the first pixel of the bounding box.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L3START</name>
          <description>Geometry Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L3START</name>
              <description>Start value of the 3rd limiter. The start value is a 16:16 fixed-point number valid at the first pixel of the bounding box.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L4START</name>
          <description>Geometry Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L4START</name>
              <description>Start value of the 4th limiter. The start value is a 16:16 fixed-point number valid at the first pixel of the bounding box.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L5START</name>
          <description>Geometry Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L5START</name>
              <description>Start value of the 5th limiter. The start value is a 16:16 fixed-point number valid at the first pixel of the bounding box.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L6START</name>
          <description>Geometry Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L6START</name>
              <description>Start value of the 6th limiter. The start value is a 16:16 fixed-point number valid at the first pixel of the bounding box.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L1XADD</name>
          <description>Geometry Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L1XADD</name>
              <description>X-axis increment (XADD) value for the 1st limiter. The XADD value is the 16:16 fixed-point difference between two samples with a distance of 1 pixel along the X-axis.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L2XADD</name>
          <description>Geometry Register</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L2XADD</name>
              <description>X-axis increment (XADD) value for the 2nd limiter. The XADD value is the 16:16 fixed-point difference between two samples with a distance of 1 pixel along the X-axis.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L3XADD</name>
          <description>Geometry Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L3XADD</name>
              <description>X-axis increment (XADD) value for the 3rd limiter. The XADD value is the 16:16 fixed-point difference between two samples with a distance of 1 pixel along the X-axis.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L4XADD</name>
          <description>Geometry Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L4XADD</name>
              <description>X-axis increment (XADD) value for the 4th limiter. The XADD value is the 16:16 fixed-point difference between two samples with a distance of 1 pixel along the X-axis.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L5XADD</name>
          <description>Geometry Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L5XADD</name>
              <description>X-axis increment (XADD) value for the 5th limiter. The XADD value is the 16:16 fixed-point difference between two samples with a distance of 1 pixel along the X-axis.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L6XADD</name>
          <description>Geometry Register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L6XADD</name>
              <description>X-axis increment (XADD) value for the 6th limiter. The XADD value is the 16:16 fixed-point difference between two samples with a distance of 1 pixel along the X-axis.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L1YADD</name>
          <description>Geometry Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L1YADD</name>
              <description>Y-axis increment (YADD) value for the 1st limiter. The YADD value is the 16:16 fixed-point difference between two samples with a distance of 1 pixel along the Y-axis.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L2YADD</name>
          <description>Geometry Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L2YADD</name>
              <description>Y-axis increment (YADD) value for the 2nd limiter. The YADD value is the 16:16 fixed-point difference between two samples with a distance of 1 pixel along the Y-axis.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L3YADD</name>
          <description>Geometry Register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L3YADD</name>
              <description>Y-axis increment (YADD) value for the 3rd limiter. The YADD value is the 16:16 fixed-point difference between two samples with a distance of 1 pixel along the Y-axis.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L4YADD</name>
          <description>Geometry Register</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L4YADD</name>
              <description>Y-axis increment (YADD) value for the 4th limiter. The YADD value is the 16:16 fixed-point difference between two samples with a distance of 1 pixel along the Y-axis.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L5YADD</name>
          <description>Geometry Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L5YADD</name>
              <description>Y-axis increment (YADD) value for the 5th limiter. The YADD value is the 16:16 fixed-point difference between two samples with a distance of 1 pixel along the Y-axis.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L6YADD</name>
          <description>Geometry Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L6YADD</name>
              <description>Y-axis increment (YADD) value for the 6th limiter. The YADD value is the 16:16 fixed-point difference between two samples with a distance of 1 pixel along the Y-axis.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L1BAND</name>
          <description>Geometry Register</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L1BAND</name>
              <description>Limiter1 band width parameter</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L2BAND</name>
          <description>Geometry Register</description>
          <addressOffset>0x5C</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L2BAND</name>
              <description>Limiter2 band width parameter</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_COLOR1</name>
          <description>Base Color Register</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COLOR1_ALPHA</name>
              <description>Alpha channel of color1</description>
              <bitRange>[31:24]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transparent</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xFF</name>
                  <description>Opaque</description>
                  <value>0xFF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COLOR1_RED</name>
              <description>Red channel of color1</description>
              <bitRange>[23:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>COLOR1_GREEN</name>
              <description>Green channel of color1</description>
              <bitRange>[15:8]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>COLOR1_BLUE</name>
              <description>Blue channel of color1</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_COLOR2</name>
          <description>Secondary Color Register</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COLOR2_ALPHA</name>
              <description>Alpha channel of color2</description>
              <bitRange>[31:24]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transparent</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xFF</name>
                  <description>Opaque</description>
                  <value>0xFF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COLOR2_RED</name>
              <description>Red channel of color2</description>
              <bitRange>[23:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>COLOR2_GREEN</name>
              <description>Green channel of color2</description>
              <bitRange>[15:8]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>COLOR2_BLUE</name>
              <description>Blue channel of color2</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_PATTERN</name>
          <description>Pattern Register</description>
          <addressOffset>0x70</addressOffset>
          <size>8</size>
          <access>write-only</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>PATTERN</name>
              <description>Bitmap of the pattern. Each bit in this field is interpreted as a reference to one of the two color registers ('0' = GPU2D_COLOR1; '1' = GPU2D_COLOR2).</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_SIZE</name>
          <description>Bounding Box Dimension Register</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SIZEY</name>
              <description>Height of the bounding box</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>SIZEX</name>
              <description>Width of the bounding box</description>
              <bitRange>[15:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_PITCH</name>
          <description>Framebuffer Pitch and Spanstore Delay Register</description>
          <addressOffset>0x7C</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SSD</name>
              <description>Span store delay</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PITCH</name>
              <description>Pitch of the framebuffer. A negative width can be used to render bottom-up instead of top-down.</description>
              <bitRange>[15:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_ORIGIN</name>
          <description>Address of the First Pixel in Framebuffer Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ORIGIN</name>
              <description>Address of the first pixel in framebuffer.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_LUSTART</name>
          <description>Texture Mapping Register</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LUSTART</name>
              <description>U-limiter start value. The start value is a 16:16 fixed-point number valid at the first pixel of the bounding box.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_LUXADD</name>
          <description>Texture Mapping Register</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LUXADD</name>
              <description>U-limiter X-axis increment (XADD) value. The XADD value is a 16:16 fixed-point number valid at the first pixel of the bounding box.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_LUYADD</name>
          <description>Texture Mapping Register</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LUYADD</name>
              <description>U-limiter Y-axis increment (YADD) value. The YADD value is a 16:16 fixed-point number valid at the first pixel of the bounding box.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_LVSTARTI</name>
          <description>Texture Mapping Register</description>
          <addressOffset>0x9C</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LVSTARTI</name>
              <description>V-limiter start value, integer part.
The start value of the V-limiter is a 32:16 fixed-point number valid at the first pixel of the bounding box. 
GPU2D_LVSTARTF[LVSTARTF] is used for the fractional part.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_LVSTARTF</name>
          <description>Texture Mapping Register</description>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LVSTARTF</name>
              <description>V-limiter start value, fractional part.
The start value of the V-limiter is a 32:16 fixed-point number valid at the first pixel of the bounding box.
GPU2D_LVSTARTI[LVSTARTI] is used for the integer part.</description>
              <bitRange>[15:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_LVXADDI</name>
          <description>Texture Mapping Register</description>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LVXADDI</name>
              <description>V-limiter X-axis increment (XADD) value, integer part.
The XADD value for the V-limiter is the 32:16 fixed-point difference between two samples with a distance of 1 pixel along the X-axis.
GPU2D_LVYXADDF[LVXADDF] is used for the fractional part.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_LVYADDI</name>
          <description>Texture Mapping Register</description>
          <addressOffset>0xA8</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LVYADDI</name>
              <description>V-limiter Y-axis increment (YADD) value, integer part.
The YADD value for the V-limiter is the 32:16 fixed-point difference between two samples with a distance of 1 pixel along the Y-axis.
GPU2D_LVYXADDF[LVYADDF] is used for the fractional part.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_LVYXADDF</name>
          <description>Texture Mapping Register</description>
          <addressOffset>0xAC</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LVYADDF</name>
              <description>V-limiter YADD, fractional part.</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>LVXADDF</name>
              <description>V-limiter XADD, fractional part.</description>
              <bitRange>[15:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_TEXPITCH</name>
          <description>Texels per Texture Line Register</description>
          <addressOffset>0xB4</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TEXPITCH</name>
              <description>Texels per texture line.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_TEXMASK</name>
          <description>U/V Texture Mask Register</description>
          <addressOffset>0xB8</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TEXUMASK</name>
              <description>V mask</description>
              <bitRange>[31:11]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>TEXVMASK</name>
              <description>U mask</description>
              <bitRange>[10:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_TEXORIGIN</name>
          <description>Texture Base Address Register</description>
          <addressOffset>0xBC</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TEXORIGIN</name>
              <description>Texture base address</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_IRQCTL</name>
          <description>Interrupt Control Register</description>
          <addressOffset>0xC0</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2IRQCTL_CLR_BUS_ERROR</name>
              <bitRange>[5:5]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Leave bus error interrupt untouched</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clear bus error interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2IRQCTL_ENABLE_BUS_ERROR</name>
              <bitRange>[4:4]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable bus error interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable bus error interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2IRQCTL_CLR_FINISH_DLIST</name>
              <bitRange>[3:3]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Leave display list interrupt untouched</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clear display list interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2IRQCTL_CLR_FINISH_ENUM</name>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Leave enumeration interrupt untouched</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clear enumeration interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2IRQCTL_ENABLE_FINISH_DLIST</name>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable display list finished interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable display list finished interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2IRQCTL_ENABLE_FINISH_ENUM</name>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable enumeration finished interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable enumeration finished interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_CACHECTL</name>
          <description>Cache Control Register</description>
          <addressOffset>0xC4</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2C_CACHECTL_FLUSH_TX</name>
              <bitRange>[3:3]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Do not flush the texture cache</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Flush the texture cache</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_CACHECTL_ENABLE_TX</name>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable the texture cache</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable the texture cache</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_CACHECTL_FLUSH_FB</name>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Do not flush the framebuffer cache</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Flush the framebuffer cache</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_CACHECTL_ENABLE_FB</name>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable the framebuffer cache</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable the framebuffer cache</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_DLISTSTART</name>
          <description>Display List Start Address Register</description>
          <addressOffset>0xC8</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DLISTSTART</name>
              <description>Display list start address
Setting a new display list base address triggers execution of the new display list.
Note that once the display list is started, the display list reader is the master for all register writes to the core. No register write must be done via the slave bus as long as the display list execution is ongoing. Otherwise, commands from the display list may be lost and rendering artifacts as well as core hangups can occur.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_PERFCOUNT1</name>
          <description>Performance Counter 1 Register</description>
          <addressOffset>0xCC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PERFCOUNT1</name>
              <description>Performance counter 1 value. GPU2D will increment the counter on every event selected by GPU2D_PERFTRIGGER[PERFTRIGGER1].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_PERFCOUNT2</name>
          <description>Performance Counter 2 Register</description>
          <addressOffset>0xD0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PERFCOUNT2</name>
              <description>Performance counter 2 value. GPU2D will increment the counter on every event selected by GPU2D_PERFTRIGGER[PERFTRIGGER2].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_PERFTRIGGER</name>
          <description>Performance Counter Control Register</description>
          <addressOffset>0xD4</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PERFTRIGGER2</name>
              <description>Select the internal event that will increment GPU2D_PERFCOUNT2 register.</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable performance counter (D2PC_NONE)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>GPU2D active cycles (D2PC_DAVECYCLES)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Framebuffer read access (D2PC_FBREADS)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Framebuffer write access (D2PC_FBWRITES)</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Texture read access (D2PC_TXREADS)</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>Invisible pixels (enumerated but selected with alpha 0%) (D2PC_INVPIXELS)</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>Invisible pixels while internal fifo is empty (lost cycles) (D2PC_INVPIXELS_MISS)</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>Display list reader active cycles (D2PC_DLRCYCLES)</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>Framebuffer read hits (D2PC_FBREADHITS)</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>Framebuffer read misses (D2PC_FBREADMISSES)</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>Framebuffer write hits (D2PC_FBWRITEMISSES)</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>Framebuffer write misses (D2PC_FBWRITEMISSES) </description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>Texture read hits (D2PC_TEXREADHITS)</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xD</name>
                  <description>Texture read misses (D2PC_TEXREADMISSES)</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x14</name>
                  <description>RLE rewind count (D2PC_RLEREWIND)</description>
                  <value>0x14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1F</name>
                  <description>Every clock cycle (D2PC_CLKCYCLES)</description>
                  <value>0x1F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PERFTRIGGER1</name>
              <description>Select the internal event that will increment GPU2D_PERFCOUNT1 register.</description>
              <bitRange>[15:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable performance counter (D2PC_NONE)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>GPU2D active cycles (D2PC_DAVECYCLES)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Framebuffer read access (D2PC_FBREADS)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Framebuffer write access (D2PC_FBWRITES)</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Texture read access (D2PC_TXREADS)</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>Invisible pixels (enumerated but selected with alpha 0%) (D2PC_INVPIXELS)</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>Invisible pixels while internal fifo is empty (lost cycles) (D2PC_INVPIXELS_MISS)</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>Display list reader active cycles (D2PC_DLRCYCLES)</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>Framebuffer read hits (D2PC_FBREADHITS)</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>Framebuffer read misses (D2PC_FBREADMISSES)</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>Framebuffer write hits (D2PC_FBWRITEMISSES)</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>Framebuffer write misses (D2PC_FBWRITEMISSES) </description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>Texture read hits (D2PC_TEXREADHITS)</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xD</name>
                  <description>Texture read misses (D2PC_TEXREADMISSES)</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x14</name>
                  <description>RLE rewind count (D2PC_RLEREWIND)</description>
                  <value>0x14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1F</name>
                  <description>Every clock cycle (D2PC_CLKCYCLES)</description>
                  <value>0x1F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_TEXCLUT</name>
          <description>CLUT Index Texture Format Register</description>
          <addressOffset>0xD8</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLUT_INDEX</name>
              <description>Index of CLUT entry to write.</description>
              <bitRange>[31:24]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLUT_ENTRY</name>
              <description>RGB888 CLUT entry.</description>
              <bitRange>[23:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_TEXCLUT_ADDR</name>
          <description>CLUT Write Address Register</description>
          <addressOffset>0xDC</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLUT_ADDR</name>
              <description>CLUT write address</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_TEXCLUT_DATA</name>
          <description>CLUT Write Data Register</description>
          <addressOffset>0xE0</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLUT_DATA</name>
              <description>For ARGB8888 format:
- Bits 31-0: CLUT data
For RGB565 format:
- Bits 31-16: CLUT data for (index x 2) + 1
- Bits 15-0: CLUT data for index x 2</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_TEXCLUT_OFFSET</name>
          <description>CLUT Offset Access for Index of Texture Register</description>
          <addressOffset>0xE4</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLUT_OFFSET</name>
              <description>CLUT offset</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_COLKEY</name>
          <description>Color Keying Register</description>
          <addressOffset>0xE8</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COLORKEY</name>
              <description>RGB888 color value for color keying.</description>
              <bitRange>[23:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>NPU_HG</name>
      <baseAddress>0x49042000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>5024</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>NPU85_ID</name>
          <description>ID Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x20007001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ARCH_MAJOR_REV</name>
              <description>This value is the major architecture version number, a in the architecture version a.b</description>
              <bitRange>[31:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ARCH_MINOR_REV</name>
              <description>This value is the minor architecture version number, b in the architecture version a.b</description>
              <bitRange>[27:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ARCH_PATCH_REV</name>
              <description>This value is the patch number of the architecture version a.b</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PRODUCT_MAJOR</name>
              <description>Product major ID number (unique per base product)</description>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VERSION_MAJOR</name>
              <description>This value is the n for the R part of an RnPn release number</description>
              <bitRange>[11:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VERSION_MINOR</name>
              <description>This value is the n for the P part of an RnPn release number</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VERSION_STATUS</name>
              <description>This value is the version of the product</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_STATUS</name>
          <description>STATUS Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000008</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IRQ_HISTORY_MASK</name>
              <description>The IRQ History mask</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FAULTING_CHANNEL</name>
              <description>The faulting channel on a bus abort</description>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FAULTING_INTERFACE</name>
              <description>The faulting interface on bus abort</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RES1</name>
              <description>Reserved field</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BRANCH_FAULT</name>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>No branch fault. 1 = Branch fault detected</description>
                  <value>0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ECC_FAULT</name>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>No ECC fault detected. 1 = ECC fault detected</description>
                  <value>0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PMU_IRQ_RAISED</name>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>No PMU IRQ raised. 1 = PMU IRQ raised</description>
                  <value>0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_END_REACHED</name>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Command stream end is not reached. 1 = Command stream end is reached</description>
                  <value>0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_PARSE_ERROR</name>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>No parsing error. 1 = Command stream parsing error detected</description>
                  <value>0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESET_STATUS</name>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>No reset in progress. 1 = Reset in progress</description>
                  <value>0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUS_STATUS</name>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>No bus fault. 1 = Bus abort detected and processing halted</description>
                  <value>0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IRQ_RAISED</name>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>IRQ not raised. 1 = IRQ raised</description>
                  <value>0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STATE</name>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>NPU is in stopped state. 1 = NPU is in running state</description>
                  <value>0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_CMD</name>
          <description>CMD Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000000C</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLEAR_IRQ_HISTORY</name>
              <description>Clears the IRQ history mask</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[15:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STOP_REQUEST</name>
              <description>Write 1 to this bit to request STOP after completing any already-started commands</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POWER_Q_ENABLE</name>
              <description>Write 1 to this bit to enable power off using power q-interface</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLOCK_Q_ENABLE</name>
              <description>Write 1 to this bit to enable clock off using clock q-interface and enable the requester clock gate</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR_IRQ</name>
              <description>Write 1 to clear the IRQ status in the NPU85_STATUS register. Writing 0 has no effect</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRANSITION_TO_RUNNING_STATE</name>
              <description>Write 1 to transition the NPU to running state. Writing 0 has no effect</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_RESET</name>
          <description>RESET Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[31:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PENDING_CSL</name>
              <description>Current security level. 0 = Secure and 1 = Non-secure</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PENDING_CPL</name>
              <description>Current privilege level. 0 = User and 1 = Privileged</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_QBASE</name>
          <description>QBASE Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET</name>
              <description>Offset</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_QBASE_HI</name>
          <description>QBASE_hi Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[31:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OFFSET</name>
              <description>Offset</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_QREAD</name>
          <description>QREAD Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QREAD</name>
              <description>The read offset of the current command under execution</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_QCONFIG</name>
          <description>QCONFIG Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[31:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_REGION0</name>
              <description>The command region configuration number</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_QSIZE</name>
          <description>QSIZE Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QSIZE</name>
              <description>The size of the next command stream to be executed by the NPU</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PROT</name>
          <description>PROT Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[31:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACTIVE_CSL</name>
              <description>The current security level 0=Secure 1=Non secure</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACTIVE_CPL</name>
              <description>The current privilege level. 0 = User and 1 = Privileged</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_CONFIG</name>
          <description>CONFIG Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x20000118</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRODUCT</name>
              <description>The product configuration</description>
              <bitRange>[31:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CUSTOM_DMA</name>
              <description>The custom DMA configuration</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RES1</name>
              <description>Reserved field</description>
              <bitRange>[26:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NUM_WD</name>
              <description>The log2 of the number of standard weight decoders</description>
              <bitRange>[13:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NUM_AXI_EXT</name>
              <description>The log2 of the number of AXI External memory interfaces</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NUM_AXI_SRAM</name>
              <description>The log2 of the number of AXI SRAM interfaces</description>
              <bitRange>[9:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_STREAM_VERSION</name>
              <description>The command stream version accepted by this NPU</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MACS_PER_CC</name>
              <description>The log2(macs/clock cycle)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_COND_STATUS</name>
          <description>COND_STATUS Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[31:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RESULT_FLAG</name>
              <description>The tensor result flag. For OFM with a single element, this is bit 0 of the value. Otherwise UNPREDICTABLE</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_POWER_CTRL</name>
          <description>POWER_CTRL Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[31:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAC_STEP_CYCLES</name>
              <description>MAC power ramping up/down control</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_REGIONCFG</name>
          <description>REGIONCFG Register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REGION7</name>
              <description>Bits for Region7 Configuration</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGION6</name>
              <description>Bits for Region6 Configuration</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGION5</name>
              <description>Bits for Region5 Configuration</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGION4</name>
              <description>Bits for Region4 Configuration</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGION3</name>
              <description>Bits for Region3 Configuration</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGION2</name>
              <description>Bits for Region2 Configuration</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGION1</name>
              <description>Bits for Region1 Configuration</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGION0</name>
              <description>Bits for Region0 Configuration</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_MEM_ATTR0</name>
          <description>MEM_ATTR0 Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES1</name>
              <description>Reserved field</description>
              <bitRange>[31:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MEMTYPE</name>
              <description>Memtype to be used to encode AxCACHE signals</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>AXI_PORT</name>
              <description>AXI port select</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEM_DOMAIN</name>
              <description>Memory domain</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_MEM_ATTR1</name>
          <description>MEM_ATTR1 Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES1</name>
              <description>Reserved field</description>
              <bitRange>[31:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MEMTYPE</name>
              <description>Memtype to be used to encode AxCACHE signals</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>AXI_PORT</name>
              <description>AXI port select</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEM_DOMAIN</name>
              <description>Memory domain</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_MEM_ATTR2</name>
          <description>MEM_ATTR2 Register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES1</name>
              <description>Reserved field</description>
              <bitRange>[31:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MEMTYPE</name>
              <description>Memtype to be used to encode AxCACHE signals</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>AXI_PORT</name>
              <description>AXI port select</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEM_DOMAIN</name>
              <description>Memory domain</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_MEM_ATTR3</name>
          <description>MEM_ATTR3 Register</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES1</name>
              <description>Reserved field</description>
              <bitRange>[31:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MEMTYPE</name>
              <description>Memtype to be used to encode AxCACHE signals</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>AXI_PORT</name>
              <description>AXI port select</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEM_DOMAIN</name>
              <description>Memory domain</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_AXI_SRAM</name>
          <description>AXI_SRAM Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES2</name>
              <description>Reserved field</description>
              <bitRange>[31:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAX_BEATS</name>
              <description>Burst split alignment</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES1</name>
              <description>Reserved field</description>
              <bitRange>[15:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAX_OUTSTANDING_WRITE_M1</name>
              <description>Maximum number of outstanding AXI write transactions per port - 1</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[7:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAX_OUTSTANDING_READ_M1</name>
              <description>Maximum number of outstanding AXI read transactions per port - 1</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_AXI_EXT</name>
          <description>AXI_EXT Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES2</name>
              <description>Reserved field</description>
              <bitRange>[31:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAX_BEATS</name>
              <description>Burst split alignment</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES1</name>
              <description>Reserved field</description>
              <bitRange>[15:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAX_OUTSTANDING_WRITE_M1</name>
              <description>Maximum number of outstanding AXI write transactions per port - 1</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[7:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAX_OUTSTANDING_READ_M1</name>
              <description>Maximum number of outstanding AXI read transactions per port - 1</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_CFG_SRAM_CAP</name>
          <description>CFG_SRAM_CAP Register</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES2</name>
              <description>Reserved field</description>
              <bitRange>[31:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAX_BEATS</name>
              <description>Burst split alignment</description>
              <bitRange>[17:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RES1</name>
              <description>Reserved field</description>
              <bitRange>[15:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAX_OUTSTANDING_WRITE_M1</name>
              <description>Maximum number of outstanding AXI write transactions per port - 1</description>
              <bitRange>[12:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[7:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAX_OUTSTANDING_READ_M1</name>
              <description>Maximum number of outstanding AXI read transactions per port - 1</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_CFG_EXT_CAP</name>
          <description>CFG_EXT_CAP Register</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES2</name>
              <description>Reserved field</description>
              <bitRange>[31:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAX_BEATS</name>
              <description>Burst split alignment</description>
              <bitRange>[17:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RES1</name>
              <description>Reserved field</description>
              <bitRange>[15:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAX_OUTSTANDING_WRITE_M1</name>
              <description>Maximum number of outstanding AXI write transactions per port - 1</description>
              <bitRange>[12:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[7:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAX_OUTSTANDING_READ_M1</name>
              <description>Maximum number of outstanding AXI read transactions per port - 1</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_CFG_SRAM_HASH0</name>
          <description>CFG_SRAM_HASH0 Register</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HASH</name>
              <description>Hash function</description>
              <bitRange>[31:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ZERO</name>
              <description>Must be zero</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_CFG_SRAM_HASH0_HI</name>
          <description>CFG_SRAM_HASH0_hi Register</description>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[31:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HASH</name>
              <description>Hash function</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_CFG_SRAM_HASH1</name>
          <description>CFG_SRAM_HASH1 Register</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HASH</name>
              <description>Hash function</description>
              <bitRange>[31:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ZERO</name>
              <description>Must be zero</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_CFG_SRAM_HASH1_HI</name>
          <description>CFG_SRAM_HASH1_hi Register</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[31:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HASH</name>
              <description>Hash function</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_CFG_EXT_HASH0</name>
          <description>CFG_EXT_HASH0 Register</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HASH</name>
              <description>Hash function</description>
              <bitRange>[31:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ZERO</name>
              <description>Must be zero</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_CFG_EXT_HASH0_HI</name>
          <description>CFG_EXT_HASH0_hi Register</description>
          <addressOffset>0x7C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[31:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HASH</name>
              <description>Hash function</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_BASEP0</name>
          <description>BASEP0 Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET</name>
              <description>Offset</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_BASEP0_HI</name>
          <description>BASEP0_hi Register</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[31:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OFFSET</name>
              <description>Offset</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_BASEP1</name>
          <description>BASEP1 Register</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET</name>
              <description>Offset</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_BASEP1_HI</name>
          <description>BASEP1_hi Register</description>
          <addressOffset>0x8C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[31:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OFFSET</name>
              <description>Offset</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_BASEP2</name>
          <description>BASEP2 Register</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET</name>
              <description>Offset</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_BASEP2_HI</name>
          <description>BASEP2_hi Register</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[31:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OFFSET</name>
              <description>Offset</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_BASEP3</name>
          <description>BASEP3 Register</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET</name>
              <description>Offset</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_BASEP3_HI</name>
          <description>BASEP3_hi Register</description>
          <addressOffset>0x9C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[31:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OFFSET</name>
              <description>Offset</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_BASEP4</name>
          <description>BASEP4 Register</description>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET</name>
              <description>Offset</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_BASEP4_HI</name>
          <description>BASEP4_hi Register</description>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[31:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OFFSET</name>
              <description>Offset</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_BASEP5</name>
          <description>BASEP5 Register</description>
          <addressOffset>0xA8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET</name>
              <description>Offset</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_BASEP5_HI</name>
          <description>BASEP5_hi Register</description>
          <addressOffset>0xAC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[31:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OFFSET</name>
              <description>Offset</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_BASEP6</name>
          <description>BASEP6 Register</description>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET</name>
              <description>Offset</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_BASEP6_HI</name>
          <description>BASEP6_hi Register</description>
          <addressOffset>0xB4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[31:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OFFSET</name>
              <description>Offset</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_BASEP7</name>
          <description>BASEP7 Register</description>
          <addressOffset>0xB8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET</name>
              <description>Offset</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_BASEP7_HI</name>
          <description>BASEP7_hi Register</description>
          <addressOffset>0xBC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[31:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OFFSET</name>
              <description>Offset</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PID4</name>
          <description>PID4 Register</description>
          <addressOffset>0xFD0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PID4</name>
              <description>Byte 4 of Peripheral NPU85_ID (Lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PID5</name>
          <description>PID5 Register</description>
          <addressOffset>0xFD4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PID5</name>
              <description>Byte 5 of Peripheral NPU85_ID (Lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PID6</name>
          <description>PID6 Register</description>
          <addressOffset>0xFD8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PID6</name>
              <description>Byte 6 of Peripheral NPU85_ID (Lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PID7</name>
          <description>PID7 Register</description>
          <addressOffset>0xFDC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PID7</name>
              <description>Byte 7 of Peripheral NPU85_ID (Lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PID0</name>
          <description>PID0 Register</description>
          <addressOffset>0xFE0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000082</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PID0</name>
              <description>Byte 0 of Peripheral NPU85_ID (Lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PID1</name>
          <description>PID1 Register</description>
          <addressOffset>0xFE4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000B5</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PID1</name>
              <description>Byte 1 of Peripheral NPU85_ID (Lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PID2</name>
          <description>PID2 Register</description>
          <addressOffset>0xFE8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0000000B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PID2</name>
              <description>Byte 2 of Peripheral NPU85_ID (Lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PID3</name>
          <description>PID3 Register</description>
          <addressOffset>0xFEC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PID3</name>
              <description>Byte 1 of Peripheral NPU85_ID (Lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_CID0</name>
          <description>CID0 Register</description>
          <addressOffset>0xFF0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0000000D</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CID0</name>
              <description>Byte 0 of Component NPU85_ID (Lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_CID1</name>
          <description>CID1 Register</description>
          <addressOffset>0xFF4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000F0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CID1</name>
              <description>Byte 1 of Component NPU85_ID (Lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_CID2</name>
          <description>CID2 Register</description>
          <addressOffset>0xFF8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CID2</name>
              <description>Byte 2 of Component NPU85_ID (Lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_CID3</name>
          <description>CID3 Register</description>
          <addressOffset>0xFFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000B1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CID3</name>
              <description>Byte 3 of Component NPU85_ID (Lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PMCR</name>
          <description>PMCR Register</description>
          <addressOffset>0x1180</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00004000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES1</name>
              <description>Reserved field</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NUM_EVENT_CNT</name>
              <description>Number of event counters</description>
              <bitRange>[15:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[10:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MASK_EN</name>
              <description>PMU can be enabled/disabled by command stream operation NPU_OP_PMU_MASK</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CYCLE_CNT_RST</name>
              <description>Reset cycle counter</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_RST</name>
              <description>Reset event counter</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CNT_EN</name>
              <description>Enable counter</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PMCNTENSET</name>
          <description>PMCNTENSET Register</description>
          <addressOffset>0x1184</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE_CNT</name>
              <description>NPU85_PMCCNTR enable bit</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[30:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EVENT_CNT_7</name>
              <description>Event counter enable bit for NPU85_PMEVCNTR7</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_6</name>
              <description>Event counter enable bit for NPU85_PMEVCNTR6</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_5</name>
              <description>Event counter enable bit for NPU85_PMEVCNTR5</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_4</name>
              <description>Event counter enable bit for NPU85_PMEVCNTR4</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_3</name>
              <description>Event counter enable bit for NPU85_PMEVCNTR3</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_2</name>
              <description>Event counter enable bit for NPU85_PMEVCNTR2</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_1</name>
              <description>Event counter enable bit for NPU85_PMEVCNTR1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_0</name>
              <description>Event counter enable bit for NPU85_PMEVCNTR0</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PMCNTENCLR</name>
          <description>PMCNTENCLR Register</description>
          <addressOffset>0x1188</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE_CNT</name>
              <description>NPU85_PMCCNTR disable bit</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[30:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EVENT_CNT_7</name>
              <description>Event counter disable bit for NPU85_PMEVCNTR7</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_6</name>
              <description>Event counter disable bit for NPU85_PMEVCNTR6</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_5</name>
              <description>Event counter disable bit for NPU85_PMEVCNTR5</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_4</name>
              <description>Event counter disable bit for NPU85_PMEVCNTR4</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_3</name>
              <description>Event counter disable bit for NPU85_PMEVCNTR3</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_2</name>
              <description>Event counter disable bit for NPU85_PMEVCNTR2</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_1</name>
              <description>Event counter disable bit for NPU85_PMEVCNTR1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_0</name>
              <description>Event counter disable bit for NPU85_PMEVCNTR0</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PMOVSSET</name>
          <description>PMOVSSET Register</description>
          <addressOffset>0x118C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE_CNT_OVF</name>
              <description>NPU85_PMCCNTR overflow set bit</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[30:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EVENT_CNT_7_OVF</name>
              <description>Event counter overflow set bit for NPU85_PMEVCNTR7</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_6_OVF</name>
              <description>Event counter overflow set bit for NPU85_PMEVCNTR6</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_5_OVF</name>
              <description>Event counter overflow set bit for NPU85_PMEVCNTR5</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_4_OVF</name>
              <description>Event counter overflow set bit for NPU85_PMEVCNTR4</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_3_OVF</name>
              <description>Event counter overflow set bit for NPU85_PMEVCNTR3</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_2_OVF</name>
              <description>Event counter overflow set bit for NPU85_PMEVCNTR2</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_1_OVF</name>
              <description>Event counter overflow set bit for NPU85_PMEVCNTR1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_0_OVF</name>
              <description>Event counter overflow set bit for NPU85_PMEVCNTR0</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PMOVSCLR</name>
          <description>PMOVSCLR Register</description>
          <addressOffset>0x1190</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE_CNT_OVF</name>
              <description>NPU85_PMCCNTR overflow clear bit</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[30:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EVENT_CNT_7_OVF</name>
              <description>Event counter overflow clear bit for NPU85_PMEVCNTR7</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_6_OVF</name>
              <description>Event counter overflow clear bit for NPU85_PMEVCNTR6</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_5_OVF</name>
              <description>Event counter overflow clear bit for NPU85_PMEVCNTR5</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_4_OVF</name>
              <description>Event counter overflow clear bit for NPU85_PMEVCNTR4</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_3_OVF</name>
              <description>Event counter overflow clear bit for NPU85_PMEVCNTR3</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_2_OVF</name>
              <description>Event counter overflow clear bit for NPU85_PMEVCNTR2</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_1_OVF</name>
              <description>Event counter overflow clear bit for NPU85_PMEVCNTR1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_0_OVF</name>
              <description>Event counter overflow clear bit for NPU85_PMEVCNTR0</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PMINTSET</name>
          <description>PMINTSET Register</description>
          <addressOffset>0x1194</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE_CNT_INT</name>
              <description>NPU85_PMCCNTR overflow interrupt request enable bit</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[30:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EVENT_CNT_7_INT</name>
              <description>Event counter overflow interrupt request enable bit for NPU85_PMEVCNTR7</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_6_INT</name>
              <description>Event counter overflow interrupt request enable bit for NPU85_PMEVCNTR6</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_5_INT</name>
              <description>Event counter overflow interrupt request enable bit for NPU85_PMEVCNTR5</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_4_INT</name>
              <description>Event counter overflow interrupt request enable bit for NPU85_PMEVCNTR4</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_3_INT</name>
              <description>Event counter overflow interrupt request enable bit for NPU85_PMEVCNTR3</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_2_INT</name>
              <description>Event counter overflow interrupt request enable bit for NPU85_PMEVCNTR2</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_1_INT</name>
              <description>Event counter overflow interrupt request enable bit for NPU85_PMEVCNTR1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_0_INT</name>
              <description>Event counter overflow interrupt request enable bit for NPU85_PMEVCNTR0</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PMINTCLR</name>
          <description>PMINTCLR Register</description>
          <addressOffset>0x1198</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE_CNT_INT</name>
              <description>NPU85_PMCCNTR overflow interrupt request disable bit</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[30:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EVENT_CNT_7_INT</name>
              <description>Event counter overflow interrupt request disable bit for NPU85_PMEVCNTR7</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_6_INT</name>
              <description>Event counter overflow interrupt request disable bit for NPU85_PMEVCNTR6</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_5_INT</name>
              <description>Event counter overflow interrupt request disable bit for NPU85_PMEVCNTR5</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_4_INT</name>
              <description>Event counter overflow interrupt request disable bit for NPU85_PMEVCNTR4</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_3_INT</name>
              <description>Event counter overflow interrupt request disable bit for NPU85_PMEVCNTR3</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_2_INT</name>
              <description>Event counter overflow interrupt request disable bit for NPU85_PMEVCNTR2</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_1_INT</name>
              <description>Event counter overflow interrupt request disable bit for NPU85_PMEVCNTR1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_CNT_0_INT</name>
              <description>Event counter overflow interrupt request disable bit for NPU85_PMEVCNTR0</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PMCCNTR</name>
          <description>PMCCNTR Register</description>
          <addressOffset>0x11A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE_CNT</name>
              <description>Cycle count</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PMCCNTR_HI</name>
          <description>PMCCNTR_hi Register</description>
          <addressOffset>0x11A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CYCLE_CNT</name>
              <description>Cycle count</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PMCAXI_CHAN</name>
          <description>PMCAXI_CHAN Register</description>
          <addressOffset>0x11AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES2</name>
              <description>Reserved field</description>
              <bitRange>[31:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BW_CH_SEL_EN</name>
              <description>Bandwidth channel selector</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES1</name>
              <description>Reserved field</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>AXI_SEL</name>
              <description>AXI port select for latency measurements</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CH_SEL</name>
              <description>Channel select for latency measurements</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PMCLUT</name>
          <description>PMCLUT Register</description>
          <addressOffset>0x11B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PMC_LUT_0</name>
              <description>PMU lookup table for event counter 0</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[15:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PCM_LUT_EN_0</name>
              <description>PMU lookup table enable for event counter 0</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PMEVCNTR0</name>
          <description>PMEVCNTR0 Register</description>
          <addressOffset>0x1300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT</name>
              <description>Count word</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PMEVCNTR1</name>
          <description>PMEVCNTR1 Register</description>
          <addressOffset>0x1304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT</name>
              <description>Count word</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PMEVCNTR2</name>
          <description>PMEVCNTR2 Register</description>
          <addressOffset>0x1308</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT</name>
              <description>Count word</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PMEVCNTR3</name>
          <description>PMEVCNTR3 Register</description>
          <addressOffset>0x130C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT</name>
              <description>Count word</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PMEVCNTR4</name>
          <description>PMEVCNTR4 Register</description>
          <addressOffset>0x1310</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT</name>
              <description>Count word</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PMEVCNTR5</name>
          <description>PMEVCNTR5 Register</description>
          <addressOffset>0x1314</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT</name>
              <description>Count word</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PMEVCNTR6</name>
          <description>PMEVCNTR6 Register</description>
          <addressOffset>0x1318</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT</name>
              <description>Count word</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PMEVCNTR7</name>
          <description>PMEVCNTR7 Register</description>
          <addressOffset>0x131C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT</name>
              <description>Count word</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PMEVTYPER0</name>
          <description>PMEVTYPER0 Register</description>
          <addressOffset>0x1380</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES1</name>
              <description>Reserved field</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>D3</name>
              <description>Counting disabled for AXI port 3</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>D2</name>
              <description>Counting disabled for AXI port 2</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>D1</name>
              <description>Counting disabled for AXI port 1</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>D0</name>
              <description>Counting disabled for AXI port 0</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[11:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EV_TYPE</name>
              <description>Event Type</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PMEVTYPER1</name>
          <description>PMEVTYPER1 Register</description>
          <addressOffset>0x1384</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES1</name>
              <description>Reserved field</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>D3</name>
              <description>Counting disabled for AXI port 3</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>D2</name>
              <description>Counting disabled for AXI port 2</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>D1</name>
              <description>Counting disabled for AXI port 1</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>D0</name>
              <description>Counting disabled for AXI port 0</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[11:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EV_TYPE</name>
              <description>Event Type</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PMEVTYPER2</name>
          <description>PMEVTYPER2 Register</description>
          <addressOffset>0x1388</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES1</name>
              <description>Reserved field</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>D3</name>
              <description>Counting disabled for AXI port 3</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>D2</name>
              <description>Counting disabled for AXI port 2</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>D1</name>
              <description>Counting disabled for AXI port 1</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>D0</name>
              <description>Counting disabled for AXI port 0</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[11:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EV_TYPE</name>
              <description>Event Type</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PMEVTYPER3</name>
          <description>PMEVTYPER3 Register</description>
          <addressOffset>0x138C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES1</name>
              <description>Reserved field</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>D3</name>
              <description>Counting disabled for AXI port 3</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>D2</name>
              <description>Counting disabled for AXI port 2</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>D1</name>
              <description>Counting disabled for AXI port 1</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>D0</name>
              <description>Counting disabled for AXI port 0</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[11:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EV_TYPE</name>
              <description>Event Type</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PMEVTYPER4</name>
          <description>PMEVTYPER4 Register</description>
          <addressOffset>0x1390</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES1</name>
              <description>Reserved field</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>D3</name>
              <description>Counting disabled for AXI port 3</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>D2</name>
              <description>Counting disabled for AXI port 2</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>D1</name>
              <description>Counting disabled for AXI port 1</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>D0</name>
              <description>Counting disabled for AXI port 0</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[11:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EV_TYPE</name>
              <description>Event Type</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PMEVTYPER5</name>
          <description>PMEVTYPER5 Register</description>
          <addressOffset>0x1394</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES1</name>
              <description>Reserved field</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>D3</name>
              <description>Counting disabled for AXI port 3</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>D2</name>
              <description>Counting disabled for AXI port 2</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>D1</name>
              <description>Counting disabled for AXI port 1</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>D0</name>
              <description>Counting disabled for AXI port 0</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[11:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EV_TYPE</name>
              <description>Event Type</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PMEVTYPER6</name>
          <description>PMEVTYPER6 Register</description>
          <addressOffset>0x1398</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES1</name>
              <description>Reserved field</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>D3</name>
              <description>Counting disabled for AXI port 3</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>D2</name>
              <description>Counting disabled for AXI port 2</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>D1</name>
              <description>Counting disabled for AXI port 1</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>D0</name>
              <description>Counting disabled for AXI port 0</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[11:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EV_TYPE</name>
              <description>Event Type</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPU85_PMEVTYPER7</name>
          <description>PMEVTYPER7 Register</description>
          <addressOffset>0x139C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RES1</name>
              <description>Reserved field</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>D3</name>
              <description>Counting disabled for AXI port 3</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>D2</name>
              <description>Counting disabled for AXI port 2</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>D1</name>
              <description>Counting disabled for AXI port 1</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>D0</name>
              <description>Counting disabled for AXI port 0</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES0</name>
              <description>Reserved field</description>
              <bitRange>[11:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EV_TYPE</name>
              <description>Event Type</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>JPEG</name>
      <baseAddress>0x49044000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>2048</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>JPEG_SWREG0</name>
          <description>swreg0 register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x90001000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_PRODUCT_ID</name>
              <description>Product ID</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_MAJOR_NUMBER</name>
              <description>Major number</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_MINOR_NUMBER</name>
              <description>Minor number</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG1</name>
          <description>swreg1 register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x01F00800</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESERVED_HIGHT</name>
              <description>reserved hight field</description>
              <bitRange>[31:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_IRQ_TYPE_SW_RESET</name>
              <description>Irq type sw reset mask.0=normal interruption. 1=abnormal interruption</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_IRQ_TYPE_FUSE_ERROR</name>
              <description>Irq type fuse error mask.0=normal interruption. 1=abnormal interruption</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_IRQ_TYPE_BUFFER_FULL</name>
              <description>Irq type fuse buffer full mask.0=normal interruption. 1=abnormal interruption</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_IRQ_TYPE_BUS_ERROR</name>
              <description>Irq type bus error mask.0=normal interruption. 1=abnormal interruption</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_IRQ_TYPE_TIMEOUT</name>
              <description>Irq type timeout mask. 0=normal interruption. 1=abnormal interruption</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_IRQ_TYPE_STRM_SEGMENT</name>
              <description>Irq type stream segment mask. 0=normal interruption. 1=abnormal interruption.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_IRQ_TYPE_LINE_BUFFER</name>
              <description>Irq type line buffer mask. 0=normal interruption. 1=abnormal interruption.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_IRQ_TYPE_SLICE_RDY</name>
              <description>Irq type slice ready mask. 0=normal interruption. 1=abnormal interruption.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_IRQ_TYPE_FRAME_RDY</name>
              <description>Irq type frame ready mask. 0=normal interruption. 1=abnormal interruption.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESERVED11</name>
              <description>reserved field11</description>
              <bitRange>[15:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_STRM_SEGMENT_RDY_INT</name>
              <description>Output stream segment IRQ. When high stream segment requests an interrupt. SW will reset this after interrupt is handled. It is clear by writing 1.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_TIMEOUT_INT</name>
              <description>enable timeout interrupt when 1</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESERVED9</name>
              <description>reserved field9</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_IRQ_FUSE_ERROR</name>
              <description>Interrupt Interrupt status bit encoder. When this bit is high encoder has a FUSE error. SW try to setup feature but HW miss the feature set. It is clear by writing 1.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_SLICE_RDY_STATUS</name>
              <description>Interrupt status bit encoder. When this bit is high encoder has encoded a slice. It is clear by writing 1.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_IRQ_LINE_BUFFER</name>
              <description>Interrupt status bit encoder linebuffer empty. When setting. Encoder has finished encoding input buffers. It is clear by writing 1.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_TIMEOUT</name>
              <description>Interrupt status bit encoder timeout. When high the encoder has been idling for too long. Possible only if timeout interrupt is enabled. It is clear by writing 1.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_BUFFER_FULL</name>
              <description>IRQ buffer full status bit. bufferFullInterrupt. It is clear by writing 1.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_SW_RESET</name>
              <description>IRQ SW reset status bit. It is clear by writing 1.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_BUS_ERROR_STATUS</name>
              <description>Interrupt status bit bus. Error response from bus. It is clear by writing 1.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_FRAME_RDY_STATUS</name>
              <description>Interrupt status bit encoder. When this bit is high encoder has encoded a picture. It is clear by writing 1.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_IRQ_DIS</name>
              <description>Encoder IRQ disable. When high there are no interrupts concerning encoder from HW. Polling must be used to see the interrupt statuses.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_IRQ</name>
              <description>Encoder IRQ. When high encoder requests an interrupt. SW will reset this after interrupt is handled. It is clear by writing 1.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG2</name>
          <description>swreg2 register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_AXI_WRITE_ID</name>
              <description>AXI Write ID</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_AXI_READ_ID</name>
              <description>AXI Read ID</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_STRM_SWAP</name>
              <description>byte swap config for output stream data.4 Bit byte order vector to control byte locations inside HW internal 128 bit data vector. For 64 and 32 bit external bus widths the data is first gathered to 128 bit width and then bytes swapped accordingly</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_PIC_SWAP</name>
              <description>Byte swap configuration for picture data (encoder input)</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_ROI_MAP_QP_DELTA_MAP_SWAP</name>
              <description>Byte swap configuration for qp delta of ROI map (include jpeg roimap)</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESERVED_LOW</name>
              <description>reserved low field</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG3</name>
          <description>swreg3 register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFF000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_CLOCK_GATE_ENCODER_E</name>
              <description>ASIC encoder clock gating control. 0=clock always on. 1=hardware clock gating control</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_CLOCK_GATE_ENCODER_H265_E</name>
              <description>ASIC encoder clock gating control for h265. 0=clock always on. 1=hardware clock gating control</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_CLOCK_GATE_ENCODER_H264_E</name>
              <description>ASIC encoder clock gating control for h264. 0=clock always on. 1=hardware clock gating control</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_CLOCK_GATE_INTER_E</name>
              <description>ASIC inter clock gating control. 0=clock always on. 1=hardware clock gating control</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_CLOCK_GATE_INTER_H265_E</name>
              <description>ASIC inter clock gating control for h265. 0=clock always on. 1=hardware clock gating control</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_CLOCK_GATE_INTER_H264_E</name>
              <description>ASIC inter clock gating control for h264. 0=clock always on. 1=hardware clock gating control</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_AXI_WR_ID_E</name>
              <description>axi write enable 0=disable. 1=enable.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_AXI_RD_ID_E</name>
              <description>axi read enable 0=disable. 1=enable.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>reserved field15</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_SRAM_POWER_DOWN_DISABLE</name>
              <description>SRAM power down mode disable</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>SRAM power always on</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>go into power down mode when clock is gated</description>
                  <value>0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_ENC_RAMSD_HW_MODE</name>
              <description>SRAM SD HW controlled mode</description>
              <bitRange>[18:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESERVED12</name>
              <description>reserved field12</description>
              <bitRange>[16:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_RAMSD_STATE_IDLE</name>
              <description>SRAM SD process idle state 0=some srams are in the sd process. 1=all sram have completed sd process</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_RAMSD_ROP_TIMEOUT_FLAG</name>
              <description>Flags the timeout status of the sram SD_ROP signal.0=the sram SD_ROP signal has not timed out.1=the sram SD_ROP signal has timed out</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_AXI_AR_QOS</name>
              <description>AXI Qos identifier sent on the read address channel for read transaction</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_AXI_AW_QOS</name>
              <description>AXI Qos identifier sent on the write address channel for write transaction</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_SLICE_INT</name>
              <description>enable slice interrupt when 1</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_LINE_BUFFER_INT</name>
              <description>enable line buffer interrupt when 1</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_STRM_SEGMENT_INT</name>
              <description>enable stream segment interrupt when 1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESERVED_LOW</name>
              <description>reserved low field</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG4</name>
          <description>swreg4 register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_MODE</name>
              <description>Encoding mode. streamType.1=hevc. 2=h264. 3=av1. 4=jpeg. 5=Reserved. 6=cutree. 7=vp9</description>
              <bitRange>[31:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESERVED_LOW</name>
              <description>reserved low field</description>
              <bitRange>[28:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG5</name>
          <description>swreg5 register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_PIC_WIDTH</name>
              <description>Encoded jpeg width. jpgLumWidth(unit 8 pixels)</description>
              <bitRange>[31:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_PIC_HEIGHT</name>
              <description>Encoded jpeg height. jpgLumHeight(unit 8 pixels):Max width x height is 16384 x 16384</description>
              <bitRange>[19:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>reserved field0</description>
              <bitRange>[7:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_E</name>
              <description>encoder enable. Setting this bit high will start the encoding operation. HW will reset this when picture is processed or bus error or timeout interrupt is given.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG8</name>
          <description>swreg8 register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OUTPUT_STRM_BASE</name>
              <description>stream output buffer0 base address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG9</name>
          <description>swreg9 register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OUTPUT_STRM_BUFFER_LIMIT</name>
              <description>Stream buffer0 limit / Output stream size (bytes). If buffer0 limit is reached and sw_enc_HWStreamBufChain=0 buffer_full_IRQ will be generated. Output stream size will be updated here when a slice or frame is finished</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG12</name>
          <description>swreg12 register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_INPUT_Y_BASE</name>
              <description>input image lum base address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG13</name>
          <description>swreg13 register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_INPUT_CB_BASE</name>
              <description>input image cb base address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG14</name>
          <description>swreg14 register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_INPUT_CR_BASE</name>
              <description>input image cr base address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG18</name>
          <description>swreg18 register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_STRM_STARTOFFSET</name>
              <description>Stream start offset = amount of StrmHdrRem (bits) [0..63]</description>
              <bitRange>[31:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_SLICE</name>
              <description>JPEG slice enable. 0=picture ends with EOI. 1=slice ends with RST</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_MODE</name>
              <description>JPEG mode. 0=4:2:0 (4lum+2chr blocks/MCU). 1=4:2:2 (2lum+2chr blocks/MCU)</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_RSTINT</name>
              <description>JPEG restart marker interval when slices are disabled (mb rows) [0..255]</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_RST</name>
              <description>JPEG restart marker for first RST. incremented by HW for next RST</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG19</name>
          <description>swreg19 register</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_STRM_HDRREM1</name>
              <description>Stream header remainder bits MSB (MSB aligned)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG20</name>
          <description>swreg20 register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_ROWLENGTH</name>
              <description>JPEG Input luminance row length. jpgLumWidthSrc (pixels) [96..16384]</description>
              <bitRange>[31:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_LJPEG_EN</name>
              <description>JPEG enable lossless JPEG with Huffman coding</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_LJPEG_FORMAT</name>
              <description>JPEG CodingMode 0:420 1:422 2:lumaonly</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_LJPEG_PSV</name>
              <description>JPEG prediction selection value for lossless</description>
              <bitRange>[13:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_LJPEG_PT</name>
              <description>JPEG point transform value for lossless</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESERVED_LOW</name>
              <description>reserved low field</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG21</name>
          <description>swreg21 register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_STRM_HDRREM2</name>
              <description>Stream header remainder bits LSB (MSB aligned)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG37</name>
          <description>swreg37 register</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESERVED_HIGHT</name>
              <description>reserved hight field</description>
              <bitRange>[31:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_CHROFFSET</name>
              <description>Input chrominance offset (bytes) [0..15]</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG38</name>
          <description>swreg38 register</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_INPUT_FORMAT</name>
              <description>Input image format. inputFormat. 0=YUV420P/1=YUV420SP/2=YUYV422/3=UYVY422/4=RGB565/5=RGB555/6=RGB444/7=RGB888/8=RGB101010/9=I010/10=P010/11=PACKED10BITPLANAR/12=Y0L2/13=TILE32/14=TILE16PCK4</description>
              <bitRange>[31:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_INPUT_ROTATION</name>
              <description>Input image rotation. 0=disabled. 1=90 degrees right. 2=90 degrees left.3=180 degree right.</description>
              <bitRange>[27:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESERVED9</name>
              <description>reserved field9</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_LUMOFFSET</name>
              <description>Input luminance offset (bytes) [0..15]</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESERVED5</name>
              <description>reserved field5</description>
              <bitRange>[19:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_XFILL</name>
              <description>Overfill pixels on right edge of image div2 [0.1.2.3]</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_YFILL</name>
              <description>Overfill pixels on bottom edge of image. YFill. [0...7]</description>
              <bitRange>[3:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_MIRROR</name>
              <description>mirror or not. [0.1]</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG39</name>
          <description>swreg39 register</description>
          <addressOffset>0x9C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_RGBCOEFFA</name>
              <description>RGB to YUV conversion coefficient A</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_RGBCOEFFB</name>
              <description>RGB to YUV conversion coefficient B</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG40</name>
          <description>swreg40 register</description>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_RGBCOEFFC</name>
              <description>RGB to YUV conversion coefficient C</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_RGBCOEFFE</name>
              <description>RGB to YUV conversion coefficient D</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG41</name>
          <description>swreg41 register</description>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_RGBCOEFFF</name>
              <description>RGB to YUV conversion coefficient E</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_RMASKMSB</name>
              <description>RGB R-component mask MSB bit position [0..31]</description>
              <bitRange>[15:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_GMASKMSB</name>
              <description>RGB G-component mask MSB bit position [0..31]</description>
              <bitRange>[10:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_BMASKMSB</name>
              <description>RGB B-component mask MSB bit position [0..31]</description>
              <bitRange>[5:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESERVED_LOW</name>
              <description>reserved low field</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG44</name>
          <description>swreg44 register</description>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESERVED_HIGHT</name>
              <description>reserved hight field</description>
              <bitRange>[31:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_INPUT_FORMAT_MSB</name>
              <description>Input image format bit[5:4]. inputFormatMsb.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG45</name>
          <description>swreg45 register</description>
          <addressOffset>0xB4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESERVED_HIGHT</name>
              <description>reserved hight field</description>
              <bitRange>[31:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_CHROMA_SWAP</name>
              <description>Swap order of chroma bytes in semiplanar input format.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESERVED_LOW</name>
              <description>reserved low field</description>
              <bitRange>[26:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG53</name>
          <description>swreg53 register</description>
          <addressOffset>0xD4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_INPUT_Y_BASE_MSB</name>
              <description>input lum base address MSB</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG54</name>
          <description>swreg54 register</description>
          <addressOffset>0xD8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_INPUT_CB_BASE_MSB</name>
              <description>input cb base address MSB</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG55</name>
          <description>swreg55 register</description>
          <addressOffset>0xDC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_INPUT_CR_BASE_MSB</name>
              <description>input cr base address MSB</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG59</name>
          <description>swreg59 register</description>
          <addressOffset>0xEC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OUTPUT_STRM_BASE_MSB</name>
              <description>stream output buffer0 address MSB</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG80</name>
          <description>swreg80 register</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00C0C200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_HWH264SUPPORT</name>
              <description>H264 encoding supported by HW. 0=not supported. 1=supported</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_HWSCALINGSUPPORT</name>
              <description>Down-scaling supported by HW. 0=not supported. 1=supported</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_HWBFRAMESUPPORT</name>
              <description>HW bframe support. 0=not support bframe. 1=support bframe</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_HWRGBSUPPORT</name>
              <description>RGB to YUV conversion supported by HW. 0=not supported. 1=supported</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_HWHEVCSUPPORT</name>
              <description>HEVC encoding supported by HW. 0=not supported. 1=supported</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_HWVP9SUPPORT</name>
              <description>VP9 encoding supported by HW. 0=not supported. 1=supported</description>
              <bitRange>[26:26]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_HWDENOISESUPPORT</name>
              <description>denoise supported by HW. 0=not supported. 1=supported</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_HWMAIN10SUPPORT</name>
              <description>main10 supported by HW. 0=main8 supported. 1=main10 supported</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_HWBUS</name>
              <description>Bus connection of HW. 1=AHB. 2=OCP. 3=AXI. 4=PCI. 5=AXIAHB. 6=AXIAPB.</description>
              <bitRange>[23:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RESERVED5</name>
              <description>reserved field5</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_HWLINEBUFSUPPORT</name>
              <description>LineBuffer input mode supported by HW. 0=not supported. 1=supported</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RESERVED4</name>
              <description>reserved field4</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_HWRFCSUPPORT</name>
              <description>Reference frame compression supported by HW. 0=not supported. 1=supported</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_HWTU32SUPPORT</name>
              <description>TU32 supported by HW. 0=not supported. 1=supported</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_HWJPEGSUPPORT</name>
              <description>JPEG encoder supported by HW. 0=not supported. 1=supported</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_HWBUSWIDTH</name>
              <description>Bus width of HW. 0=32b. 1=64b. 2=128b</description>
              <bitRange>[14:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RESERVED_LOW</name>
              <description>reserved low field</description>
              <bitRange>[12:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG81</name>
          <description>swreg81 register</description>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_MAX_BURST</name>
              <description>Maximum AXI burst length.Default value 0x10</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_TIMEOUT_OVERRIDE_E</name>
              <description>enable signal if timeout period is controlled by software Default value: 0x0</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_TIMEOUT_CYCLES</name>
              <description>timeout cycles number default value: 0x0</description>
              <bitRange>[22:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG82</name>
          <description>swreg82 register</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_HW_PERFORMANCE</name>
              <description>record hardware performance(cycles) of current picture</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG83</name>
          <description>swreg83 register</description>
          <addressOffset>0x14C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_0</name>
              <description>jpeg quant table luma entry 0</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_1</name>
              <description>jpeg quant table luma entry 1</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_2</name>
              <description>jpeg quant table luma entry 2</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_3</name>
              <description>jpeg quant table luma entry 3</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG84</name>
          <description>swreg84 register</description>
          <addressOffset>0x150</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_4</name>
              <description>jpeg quant table luma entry 4</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_5</name>
              <description>jpeg quant table luma entry 5</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_6</name>
              <description>jpeg quant table luma entry 6</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_7</name>
              <description>jpeg quant table luma entry 7</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG85</name>
          <description>swreg85 register</description>
          <addressOffset>0x154</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_8</name>
              <description>jpeg quant table luma entry 8</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_9</name>
              <description>jpeg quant table luma entry 9</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_10</name>
              <description>jpeg quant table luma entry 10</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_11</name>
              <description>jpeg quant table luma entry 11</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG86</name>
          <description>swreg86 register</description>
          <addressOffset>0x158</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_12</name>
              <description>jpeg quant table luma entry 12</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_13</name>
              <description>jpeg quant table luma entry 13</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_14</name>
              <description>jpeg quant table luma entry 14</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_15</name>
              <description>jpeg quant table luma entry 15</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG87</name>
          <description>swreg87 register</description>
          <addressOffset>0x15C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_16</name>
              <description>jpeg quant table luma entry 16</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_17</name>
              <description>jpeg quant table luma entry 17</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_18</name>
              <description>jpeg quant table luma entry 18</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_19</name>
              <description>jpeg quant table luma entry 19</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG88</name>
          <description>swreg88 register</description>
          <addressOffset>0x160</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_20</name>
              <description>jpeg quant table luma entry 20</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_21</name>
              <description>jpeg quant table luma entry 21</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_22</name>
              <description>jpeg quant table luma entry 22</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_23</name>
              <description>jpeg quant table luma entry 23</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG89</name>
          <description>swreg89 register</description>
          <addressOffset>0x164</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_24</name>
              <description>jpeg quant table luma entry 24</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_25</name>
              <description>jpeg quant table luma entry 25</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_26</name>
              <description>jpeg quant table luma entry 26</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_27</name>
              <description>jpeg quant table luma entry 27</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG90</name>
          <description>swreg90 register</description>
          <addressOffset>0x168</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_28</name>
              <description>jpeg quant table luma entry 28</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_29</name>
              <description>jpeg quant table luma entry 29</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_30</name>
              <description>jpeg quant table luma entry 30</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_31</name>
              <description>jpeg quant table luma entry 31</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG91</name>
          <description>swreg91 register</description>
          <addressOffset>0x16C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_32</name>
              <description>jpeg quant table luma entry 32</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_33</name>
              <description>jpeg quant table luma entry 33</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_34</name>
              <description>jpeg quant table luma entry 34</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_35</name>
              <description>jpeg quant table luma entry 35</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG92</name>
          <description>swreg92 register</description>
          <addressOffset>0x170</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_36</name>
              <description>jpeg quant table luma entry 36</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_37</name>
              <description>jpeg quant table luma entry 37</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_38</name>
              <description>jpeg quant table luma entry 38</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_39</name>
              <description>jpeg quant table luma entry 39</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG93</name>
          <description>swreg93 register</description>
          <addressOffset>0x174</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_40</name>
              <description>jpeg quant table luma entry 40</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_41</name>
              <description>jpeg quant table luma entry 41</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_42</name>
              <description>jpeg quant table luma entry 42</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_43</name>
              <description>jpeg quant table luma entry 43</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG94</name>
          <description>swreg94 register</description>
          <addressOffset>0x178</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_44</name>
              <description>jpeg quant table luma entry 44</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_45</name>
              <description>jpeg quant table luma entry 45</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_46</name>
              <description>jpeg quant table luma entry 46</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_47</name>
              <description>jpeg quant table luma entry 47</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG95</name>
          <description>swreg95 register</description>
          <addressOffset>0x17C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_48</name>
              <description>jpeg quant table luma entry 48</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_49</name>
              <description>jpeg quant table luma entry 49</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_50</name>
              <description>jpeg quant table luma entry 50</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_51</name>
              <description>jpeg quant table luma entry 51</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG96</name>
          <description>swreg96 register</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_52</name>
              <description>jpeg quant table luma entry 52</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_53</name>
              <description>jpeg quant table luma entry 53</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_54</name>
              <description>jpeg quant table luma entry 54</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_55</name>
              <description>jpeg quant table luma entry 55</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG97</name>
          <description>swreg97 register</description>
          <addressOffset>0x184</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_56</name>
              <description>jpeg quant table luma entry 56</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_57</name>
              <description>jpeg quant table luma entry 57</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_58</name>
              <description>jpeg quant table luma entry 58</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_59</name>
              <description>jpeg quant table luma entry 59</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG98</name>
          <description>swreg98 register</description>
          <addressOffset>0x188</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_60</name>
              <description>jpeg quant table luma entry 60</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_61</name>
              <description>jpeg quant table luma entry 61</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_62</name>
              <description>jpeg quant table luma entry 62</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_LUMA_63</name>
              <description>jpeg quant table luma entry 63</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG99</name>
          <description>swreg99 register</description>
          <addressOffset>0x18C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_0</name>
              <description>jpeg quant table chroma entry 0</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_1</name>
              <description>jpeg quant table chroma entry 1</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_2</name>
              <description>jpeg quant table chroma entry 2</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_3</name>
              <description>jpeg quant table chroma entry 3</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG100</name>
          <description>swreg100 register</description>
          <addressOffset>0x190</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_4</name>
              <description>jpeg quant table chroma entry 4</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_5</name>
              <description>jpeg quant table chroma entry 5</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_6</name>
              <description>jpeg quant table chroma entry 6</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_7</name>
              <description>jpeg quant table chroma entry 7</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG101</name>
          <description>swreg101 register</description>
          <addressOffset>0x194</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_8</name>
              <description>jpeg quant table chroma entry 8</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_9</name>
              <description>jpeg quant table chroma entry 9</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_10</name>
              <description>jpeg quant table chroma entry 10</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_11</name>
              <description>jpeg quant table chroma entry 11</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG102</name>
          <description>swreg102 register</description>
          <addressOffset>0x198</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_12</name>
              <description>jpeg quant table chroma entry 12</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_13</name>
              <description>jpeg quant table chroma entry 13</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_14</name>
              <description>jpeg quant table chroma entry 14</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_15</name>
              <description>jpeg quant table chroma entry 15</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG103</name>
          <description>swreg103 register</description>
          <addressOffset>0x19C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_16</name>
              <description>jpeg quant table chroma entry 16</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_17</name>
              <description>jpeg quant table chroma entry 17</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_18</name>
              <description>jpeg quant table chroma entry 18</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_19</name>
              <description>jpeg quant table chroma entry 19</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG104</name>
          <description>swreg104 register</description>
          <addressOffset>0x1A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_20</name>
              <description>jpeg quant table chroma entry 20</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_21</name>
              <description>jpeg quant table chroma entry 21</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_22</name>
              <description>jpeg quant table chroma entry 22</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_23</name>
              <description>jpeg quant table chroma entry 23</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG105</name>
          <description>swreg105 register</description>
          <addressOffset>0x1A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_24</name>
              <description>jpeg quant table chroma entry 24</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_25</name>
              <description>jpeg quant table chroma entry 25</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_26</name>
              <description>jpeg quant table chroma entry 26</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_27</name>
              <description>jpeg quant table chroma entry 27</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG106</name>
          <description>swreg106 register</description>
          <addressOffset>0x1A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_28</name>
              <description>jpeg quant table chroma entry 28</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_29</name>
              <description>jpeg quant table chroma entry 29</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_30</name>
              <description>jpeg quant table chroma entry 30</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_31</name>
              <description>jpeg quant table chroma entry 31</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG107</name>
          <description>swreg107 register</description>
          <addressOffset>0x1AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_32</name>
              <description>jpeg quant table chroma entry 32</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_33</name>
              <description>jpeg quant table chroma entry 33</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_34</name>
              <description>jpeg quant table chroma entry 34</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_35</name>
              <description>jpeg quant table chroma entry 35</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG108</name>
          <description>swreg108 register</description>
          <addressOffset>0x1B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_36</name>
              <description>jpeg quant table chroma entry 36</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_37</name>
              <description>jpeg quant table chroma entry 37</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_38</name>
              <description>jpeg quant table chroma entry 38</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_39</name>
              <description>jpeg quant table chroma entry 39</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG109</name>
          <description>swreg109 register</description>
          <addressOffset>0x1B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_40</name>
              <description>jpeg quant table chroma entry 40</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_41</name>
              <description>jpeg quant table chroma entry 41</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_42</name>
              <description>jpeg quant table chroma entry 42</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_43</name>
              <description>jpeg quant table chroma entry 43</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG110</name>
          <description>swreg110 register</description>
          <addressOffset>0x1B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_44</name>
              <description>jpeg quant table chroma entry 44</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_45</name>
              <description>jpeg quant table chroma entry 45</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_46</name>
              <description>jpeg quant table chroma entry 46</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_47</name>
              <description>jpeg quant table chroma entry 47</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG111</name>
          <description>swreg111 register</description>
          <addressOffset>0x1BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_48</name>
              <description>jpeg quant table chroma entry 48</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_49</name>
              <description>jpeg quant table chroma entry 49</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_50</name>
              <description>jpeg quant table chroma entry 50</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_51</name>
              <description>jpeg quant table chroma entry 51</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG112</name>
          <description>swreg112 register</description>
          <addressOffset>0x1C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_52</name>
              <description>jpeg quant table chroma entry 52</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_53</name>
              <description>jpeg quant table chroma entry 53</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_54</name>
              <description>jpeg quant table chroma entry 54</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_55</name>
              <description>jpeg quant table chroma entry 55</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG113</name>
          <description>swreg113 register</description>
          <addressOffset>0x1C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_56</name>
              <description>jpeg quant table chroma entry 56</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_57</name>
              <description>jpeg quant table chroma entry 57</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_58</name>
              <description>jpeg quant table chroma entry 58</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_59</name>
              <description>jpeg quant table chroma entry 59</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG114</name>
          <description>swreg114 register</description>
          <addressOffset>0x1C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_60</name>
              <description>jpeg quant table chroma entry 60</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_61</name>
              <description>jpeg quant table chroma entry 61</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_62</name>
              <description>jpeg quant table chroma entry 62</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_QUANT_TABLE_CHROMA_63</name>
              <description>jpeg quant table chroma entry 63</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG127</name>
          <description>swreg127 register</description>
          <addressOffset>0x1FC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_YADDR1</name>
              <description>Overlay 1 input luma buffer address/OSDMap input buffer address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG128</name>
          <description>swreg128 register</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_YADDR1_MSB</name>
              <description>Overlay 1 input luma buffer address MSB part/OSDMap input buffer address MSB part</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG129</name>
          <description>swreg129 register</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_UADDR1</name>
              <description>Overlay 1 input chroma U buffer address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG130</name>
          <description>swreg130 register</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_UADDR1_MSB</name>
              <description>Overlay 1 input chroma U buffer address MSB part</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG131</name>
          <description>swreg131 register</description>
          <addressOffset>0x20C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_VADDR1</name>
              <description>Overlay 1 input chroma V buffer address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG132</name>
          <description>swreg132 register</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_VADDR1_MSB</name>
              <description>Overlay 1 input chroma V buffer address MSB part</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG138</name>
          <description>swreg138 register</description>
          <addressOffset>0x228</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_YADDR2</name>
              <description>Overlay 2 input luma buffer address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG139</name>
          <description>swreg139 register</description>
          <addressOffset>0x22C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_YADDR2_MSB</name>
              <description>Overlay 2 input luma buffer address MSB part</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG140</name>
          <description>swreg140 register</description>
          <addressOffset>0x230</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_UADDR2</name>
              <description>Overlay 2 input chroma U buffer address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG141</name>
          <description>swreg141 register</description>
          <addressOffset>0x234</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_UADDR2_MSB</name>
              <description>Overlay 2 input chroma U buffer address MSB part</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG142</name>
          <description>swreg142 register</description>
          <addressOffset>0x238</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_VADDR2</name>
              <description>Overlay 2 input chroma V buffer address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG143</name>
          <description>swreg143 register</description>
          <addressOffset>0x23C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_VADDR2_MSB</name>
              <description>Overlay 2 input chroma V buffer address MSB part</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG144</name>
          <description>swreg144 register</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_YADDR3</name>
              <description>Overlay 3 input luma buffer address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG145</name>
          <description>swreg145 register</description>
          <addressOffset>0x244</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_YADDR3_MSB</name>
              <description>Overlay 3 input luma buffer address MSB part</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG146</name>
          <description>swreg146 register</description>
          <addressOffset>0x248</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_UADDR3</name>
              <description>Overlay 3 input chroma U buffer address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG147</name>
          <description>swreg147 register</description>
          <addressOffset>0x24C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_UADDR3_MSB</name>
              <description>Overlay 3 input chroma U buffer address MSB part</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG148</name>
          <description>swreg148 register</description>
          <addressOffset>0x250</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_VADDR3</name>
              <description>Overlay 3 input chroma V buffer address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG149</name>
          <description>swreg149 register</description>
          <addressOffset>0x254</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_VADDR3_MSB</name>
              <description>Overlay 3 input chroma V buffer address MSB part</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG150</name>
          <description>swreg150 register</description>
          <addressOffset>0x258</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_YADDR4</name>
              <description>Overlay 4 input luma buffer address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG151</name>
          <description>swreg151 register</description>
          <addressOffset>0x25C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_YADDR4_MSB</name>
              <description>Overlay 4 input luma buffer address MSB part</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG152</name>
          <description>swreg152 register</description>
          <addressOffset>0x260</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_UADDR4</name>
              <description>Overlay 4 input chroma U buffer address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG153</name>
          <description>swreg153 register</description>
          <addressOffset>0x264</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_UADDR4_MSB</name>
              <description>Overlay 4 input chroma U buffer address MSB part</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG154</name>
          <description>swreg154 register</description>
          <addressOffset>0x268</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_VADDR4</name>
              <description>Overlay 4 input chroma V buffer address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG155</name>
          <description>swreg155 register</description>
          <addressOffset>0x26C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_VADDR4_MSB</name>
              <description>Overlay 4 input chroma V buffer address MSB part</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG156</name>
          <description>swreg156 register</description>
          <addressOffset>0x270</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_YADDR5</name>
              <description>Overlay 5 input luma buffer address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG157</name>
          <description>swreg157 register</description>
          <addressOffset>0x274</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_YADDR5_MSB</name>
              <description>Overlay 5 input luma buffer address MSB part</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG158</name>
          <description>swreg158 register</description>
          <addressOffset>0x278</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_UADDR5</name>
              <description>Overlay 5 input chroma U buffer address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG159</name>
          <description>swreg159 register</description>
          <addressOffset>0x27C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_UADDR5_MSB</name>
              <description>Overlay 5 input chroma U buffer address MSB part</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG160</name>
          <description>swreg160 register</description>
          <addressOffset>0x280</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_VADDR5</name>
              <description>Overlay 5 input chroma V buffer address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG161</name>
          <description>swreg161 register</description>
          <addressOffset>0x284</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_VADDR5_MSB</name>
              <description>Overlay 5 input chroma V buffer address MSB part</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG162</name>
          <description>swreg162 register</description>
          <addressOffset>0x288</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_YADDR6</name>
              <description>Overlay 6 input luma buffer address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG163</name>
          <description>swreg163 register</description>
          <addressOffset>0x28C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_YADDR6_MSB</name>
              <description>Overlay 6 input luma buffer address MSB part</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG164</name>
          <description>swreg164 register</description>
          <addressOffset>0x290</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_UADDR6</name>
              <description>Overlay 6 input chroma U buffer address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG165</name>
          <description>swreg165 register</description>
          <addressOffset>0x294</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_UADDR6_MSB</name>
              <description>Overlay 6 input chroma U buffer address MSB part</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG166</name>
          <description>swreg166 register</description>
          <addressOffset>0x298</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_VADDR6</name>
              <description>Overlay 6 input chroma V buffer address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG167</name>
          <description>swreg167 register</description>
          <addressOffset>0x29C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_VADDR6_MSB</name>
              <description>Overlay 6 input chroma V buffer address MSB part</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG168</name>
          <description>swreg168 register</description>
          <addressOffset>0x2A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_YADDR7</name>
              <description>Overlay 7 input luma buffer address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG169</name>
          <description>swreg169 register</description>
          <addressOffset>0x2A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_YADDR7_MSB</name>
              <description>Overlay 7 input luma buffer address MSB part</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG174</name>
          <description>swreg174 register</description>
          <addressOffset>0x2B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_UADDR7</name>
              <description>Overlay 7 input chroma U buffer address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG175</name>
          <description>swreg175 register</description>
          <addressOffset>0x2BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_UADDR7_MSB</name>
              <description>Overlay 7 input chroma U buffer address MSB part</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG176</name>
          <description>swreg176 register</description>
          <addressOffset>0x2C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_VADDR7</name>
              <description>Overlay 7 input chroma V buffer address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG177</name>
          <description>swreg177 register</description>
          <addressOffset>0x2C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_VADDR7_MSB</name>
              <description>Overlay 7 input chroma V buffer address MSB part</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG178</name>
          <description>swreg178 register</description>
          <addressOffset>0x2C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_YADDR8</name>
              <description>Overlay 8 input luma buffer address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG179</name>
          <description>swreg179 register</description>
          <addressOffset>0x2CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_YADDR8_MSB</name>
              <description>Overlay 8 input luma buffer address MSB part</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG180</name>
          <description>swreg180 register</description>
          <addressOffset>0x2D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OVERLAY_INPUT_UADDR8</name>
              <description>Overlay 8 input chroma U buffer address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG185</name>
          <description>swreg185 register</description>
          <addressOffset>0x2E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESERVED_HIGHT</name>
              <description>reserved hight field</description>
              <bitRange>[31:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_TIMEOUT_CYCLES_MSB</name>
              <description>Extend swreg81. Timeout cycles number. Bits 31:23.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG193</name>
          <description>swreg193 register</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESERVED_HIGHT</name>
              <description>reserved hight field</description>
              <bitRange>[31:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_XFILL_MSB</name>
              <description>OverfillMsb pixels on right edge of image div2. XFillMsb[0.1.2.3] (bits[2:3] for H.264)</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_YFILL_MSB</name>
              <description>OverfillMsb pixels on bottom edge of image. YFillMsb [0.1.2.3] (bits[3:4] for H.264)</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESERVED_LOW</name>
              <description>reserved low field</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG196</name>
          <description>swreg196 register</description>
          <addressOffset>0x310</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_LOW_LATENCY_HW_SYNC_EN</name>
              <description>Low Latency Hardware Interface Enable. Use hardware handshaking.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_LOW_LATENCY_EN</name>
              <description>Low Latency Enable</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_INPUT_BUF_LOOPBACK_EN</name>
              <description>Input buffer loopback Enable</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_NUM_CTB_ROWS_PER_SYNC</name>
              <description>Number of CTB rows for every HW sync. Unit is CTB</description>
              <bitRange>[28:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_CTB_ROW_RD_PTR</name>
              <description>The number of CTB rows that has been fetched from Input buffer by encoder</description>
              <bitRange>[19:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_CTB_ROW_WR_PTR</name>
              <description>The number of CTB rows that has been filled into the input buffer by external application</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG197</name>
          <description>swreg197 register</description>
          <addressOffset>0x314</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESERVED_HIGHT</name>
              <description>reserved hight field</description>
              <bitRange>[31:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_CTB_ROW_WR_PTR_JPEG_MSB</name>
              <description>msb of sw_ctb_row_wr_ptr for jpeg</description>
              <bitRange>[9:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_CTB_ROW_RD_PTR_JPEG_MSB</name>
              <description>msb of sw_ctb_row_rd_ptr for jpeg</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG199</name>
          <description>swreg199 register</description>
          <addressOffset>0x31C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESERVED_HIGHT</name>
              <description>reserved hight field</description>
              <bitRange>[31:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_HASH_TYPE</name>
              <description>hash type of frame data. 0=none. 1=crc32. 2=checksum32</description>
              <bitRange>[4:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_HASH_OFFSET</name>
              <description>hash offset (byte offset of processed hashdata)</description>
              <bitRange>[2:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_OSD_ALPHABLEND_ENABLE</name>
              <description>enable OSD Alpha Blending. 0=disable. 1=enable.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG200</name>
          <description>swreg200 register</description>
          <addressOffset>0x320</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_HASH_VAL</name>
              <description>hash value of frame data</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG210</name>
          <description>swreg210 register</description>
          <addressOffset>0x348</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_INPUT_LU_STRIDE</name>
              <description>Luma stride of input frame</description>
              <bitRange>[31:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESERVED_LOW</name>
              <description>reserved low field</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG211</name>
          <description>swreg211 register</description>
          <addressOffset>0x34C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_INPUT_CH_STRIDE</name>
              <description>Chroma stride of input frame</description>
              <bitRange>[31:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESERVED_LOW</name>
              <description>reserved low field</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG214</name>
          <description>swreg214 register</description>
          <addressOffset>0x358</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00400800</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_HWLJPEGSUPPORT</name>
              <description>Lossless JPEG supported by HW. 0=not supported. 1=supported</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_HWABSQPSUPPORT</name>
              <description>Absolute QP in ROI/ROI map supported by HW. 0=not supported. 1=supported</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RESERVED12</name>
              <description>reserved field12</description>
              <bitRange>[29:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_HWMAXVIDEOWIDTHJPEG</name>
              <description>Maximum video width supported by HW for JPEG encoding (unit 8 pixels)</description>
              <bitRange>[12:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG215</name>
          <description>swreg215 register</description>
          <addressOffset>0x35C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_TOTALARLEN</name>
              <description>[AXI] Accumulated ARLEN+1</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG216</name>
          <description>swreg216 register</description>
          <addressOffset>0x360</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_TOTALR</name>
              <description>[AXI] RVALID &amp; RREADY</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG217</name>
          <description>swreg217 register</description>
          <addressOffset>0x364</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_TOTALAR</name>
              <description>[AXI] ARVALID &amp; ARREADY</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG218</name>
          <description>swreg218 register</description>
          <addressOffset>0x368</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_TOTALRLAST</name>
              <description>[AXI] RVALID &amp; RREADY &amp; RLAST</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG219</name>
          <description>swreg219 register</description>
          <addressOffset>0x36C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_TOTALAWLEN</name>
              <description>[AXI] Accumulated AWLEN+1</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG220</name>
          <description>swreg220 register</description>
          <addressOffset>0x370</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_TOTALW</name>
              <description>[AXI] WVALID &amp; WREADY</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG221</name>
          <description>swreg221 register</description>
          <addressOffset>0x374</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_TOTALAW</name>
              <description>[AXI] AWVALID &amp; AWREADY</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG222</name>
          <description>swreg222 register</description>
          <addressOffset>0x378</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_TOTALWLAST</name>
              <description>[AXI] WVALID &amp; WREADY &amp; WLAST</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG223</name>
          <description>swreg223 register</description>
          <addressOffset>0x37C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_TOTALB</name>
              <description>[AXI] BVALID &amp; BREADY</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG224</name>
          <description>swreg224 register</description>
          <addressOffset>0x380</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_CHROMA_CONST_EN</name>
              <description>Force Chroma to be a constant pixel or not. 0=no. 1=yes.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>reserved field19</description>
              <bitRange>[30:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_CR_CONST_PIXEL</name>
              <description>The constant pixel of CR if sw_enc_chroma_const_en=1</description>
              <bitRange>[19:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_CB_CONST_PIXEL</name>
              <description>The constant pixel of CB if sw_enc_chroma_const_en=1</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG226</name>
          <description>swreg226 register</description>
          <addressOffset>0x388</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESERVED_HIGHT</name>
              <description>reserved hight field</description>
              <bitRange>[31:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_HWSTREAMSEGMENTSUPPORT</name>
              <description>Stream segment supported by HW. 0=not supported. 1=supported</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RESERVED_LOW</name>
              <description>reserved low field</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG246</name>
          <description>swreg246 register</description>
          <addressOffset>0x3D8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESERVED_HIGHT</name>
              <description>reserved hight field</description>
              <bitRange>[31:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_AXI_WRITE_OUTSTANDING_NUM</name>
              <description>AXI outstanding number of write operation</description>
              <bitRange>[13:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESERVED_LOW</name>
              <description>reserved low field</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG249</name>
          <description>swreg249 register</description>
          <addressOffset>0x3E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESERVED_HIGHT</name>
              <description>reserved hight field</description>
              <bitRange>[31:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_PIC_WIDTH_MSB</name>
              <description>Encoded jpeg width. jpgLumWidthMSB(unit 8 pixels)</description>
              <bitRange>[10:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_PIC_HEIGHT_MSB</name>
              <description>Encoded jpeg height. jpgLumHeightMSB(unit 8 pixels):Max width x height is 24Kx24K</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_JPEG_ROWLENGTH_MSB</name>
              <description>JPEG Input luminance row length. jpgLumWidthSrcMSB (pixels) [96..16384]</description>
              <bitRange>[6:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESERVED_LOW</name>
              <description>reserved low field</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG261</name>
          <description>swreg261 register</description>
          <addressOffset>0x414</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESERVED_HIGHT</name>
              <description>reserved hight field</description>
              <bitRange>[31:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_RGBLUMAOFFSET</name>
              <description>RGB to YUV conversion luma offset</description>
              <bitRange>[17:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESERVED7</name>
              <description>reserved field7</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_AXI_READ_OUTSTANDING_NUM</name>
              <description>AXI outstanding number of read operation</description>
              <bitRange>[11:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESERVED_LOW</name>
              <description>reserved low field</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG277</name>
          <description>swreg277 register</description>
          <addressOffset>0x454</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESERVED_HIGHT</name>
              <description>reserved hight field</description>
              <bitRange>[31:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_SYN_AMOUNT_PER_LOOPBACK</name>
              <description>Handshake sync amount for every loopback</description>
              <bitRange>[19:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_PRPSBI_ID_0</name>
              <description>id of prp sbi</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG278</name>
          <description>swreg278 register</description>
          <addressOffset>0x458</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OUTPUT_STRM_BUF1_BASE</name>
              <description>stream output buffer1 base address. Only valid if sw_enc_HWStreamBufChain=1.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG279</name>
          <description>swreg279 register</description>
          <addressOffset>0x45C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OUTPUT_STRM_BUF1_BASE_MSB</name>
              <description>stream output buffer1 address MSB</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG280</name>
          <description>swreg280 register</description>
          <addressOffset>0x460</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_OUTPUT_STRM_BUFFER1_LIMIT</name>
              <description>Stream buffer1 limit size (bytes). Only valid if sw_enc_HWStreamBufChain=1. If buffer1 limit is reached buffer_full_IRQ will be generated.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG281</name>
          <description>swreg281 register</description>
          <addressOffset>0x464</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_STRM_SEGMENT_SW_SYNC_EN</name>
              <description>Stream segment software handshake enable. Set 0 will disable this handshake</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_STRM_SEGMENT_EN</name>
              <description>Stream segment function enable</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_STRM_SEGMENT_RD_PTR</name>
              <description>the number of segments that have been read out from output buffer</description>
              <bitRange>[29:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_STRM_SEGMENT_WR_PTR</name>
              <description>the number of segments that have been filled into the output buffer</description>
              <bitRange>[19:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_NUM_CTB_ROWS_PER_SYNC_MSB</name>
              <description>Number MSB of CTB rows for every HW sync. Bit[14:9]. Unit is CTB</description>
              <bitRange>[9:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESERVED_LOW</name>
              <description>reserved low field</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG287</name>
          <description>swreg287 register</description>
          <addressOffset>0x47C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESERVED_HIGHT</name>
              <description>reserved hight field</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_HWCSCEXTENSIONSUPPORT</name>
              <description>RGB to YUV conversion extension. 0=not supported. 1=supported</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>reserved field1</description>
              <bitRange>[29:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_HWVIDEOSTABSUPPORT</name>
              <description>HW supports video stabilization or not. 0=not supported. 1=supported</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>reserved field0</description>
              <bitRange>[18:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_HWOSDSUPPORT</name>
              <description>HW OSD supported by HW. 0=not supported. 1=supported</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RESERVED_LOW</name>
              <description>reserved low field</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG288</name>
          <description>swreg288 register</description>
          <addressOffset>0x480</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESERVED_HIGHT</name>
              <description>reserved hight field</description>
              <bitRange>[31:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_PRPSBI_WRSEGINITNUM</name>
              <description>segment init num of prp sbi write before encoding a new frame</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG289</name>
          <description>swreg289 register</description>
          <addressOffset>0x484</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_RGBCOEFFG</name>
              <description>RGB to YUV conversion coefficient G</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_RGBCOEFFH</name>
              <description>RGB to YUV conversion coefficient H</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG290</name>
          <description>swreg290 register</description>
          <addressOffset>0x488</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_TOTALARLEN2</name>
              <description>[AXI2] Accumulated ARLEN+1</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG291</name>
          <description>swreg291 register</description>
          <addressOffset>0x48C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_TOTALR2</name>
              <description>[AXI2] RVALID &amp; RREADY</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG292</name>
          <description>swreg292 register</description>
          <addressOffset>0x490</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_TOTALAR2</name>
              <description>[AXI2] ARVALID &amp; ARREADY</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG293</name>
          <description>swreg293 register</description>
          <addressOffset>0x494</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_TOTALRLAST2</name>
              <description>[AXI2] RVALID &amp; RREADY &amp; RLAST</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG294</name>
          <description>swreg294 register</description>
          <addressOffset>0x498</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_TOTALAWLEN2</name>
              <description>[AXI2] Accumulated AWLEN+1</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG295</name>
          <description>swreg295 register</description>
          <addressOffset>0x49C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_TOTALW2</name>
              <description>[AXI2] WVALID &amp; WREADY</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG296</name>
          <description>swreg296 register</description>
          <addressOffset>0x4A0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_TOTALAW2</name>
              <description>[AXI2] AWVALID &amp; AWREADY</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG297</name>
          <description>swreg297 register</description>
          <addressOffset>0x4A4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_TOTALWLAST2</name>
              <description>[AXI2] WVALID &amp; WREADY &amp; WLAST</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG298</name>
          <description>swreg298 register</description>
          <addressOffset>0x4A8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_TOTALB2</name>
              <description>[AXI2] BVALID &amp; BREADY</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG308</name>
          <description>swreg308 register</description>
          <addressOffset>0x4D0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_AXI_STRM_WRITE_PENDING</name>
              <description>EMC stream AXI write pending</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG311</name>
          <description>swreg311 register</description>
          <addressOffset>0x4DC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_AXI_PRP_READ_PENDING</name>
              <description>Prp AXI read pending</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG317</name>
          <description>swreg317 register</description>
          <addressOffset>0x4F4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_AXI_TOTAL_PENDING</name>
              <description>Total AXI bus pending</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG319</name>
          <description>swreg319 register</description>
          <addressOffset>0x4FC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_AXI_BURST_ALIGN_FUSE_WR_COMMON</name>
              <description>AXI burst align wr common fuse setting</description>
              <bitRange>[31:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_AXI_BURST_ALIGN_FUSE_WR_STREAM</name>
              <description>AXI burst align wr stream fuse setting</description>
              <bitRange>[27:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_AXI_BURST_ALIGN_FUSE_WR_CHROMA_REF</name>
              <description>AXI burst align wr chroma ref fuse setting</description>
              <bitRange>[23:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_AXI_BURST_ALIGN_FUSE_WR_LUMA_REF</name>
              <description>AXI burst align wr luma ref fuse setting</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_AXI_BURST_ALIGN_FUSE_RD_COMMON</name>
              <description>AXI burst align rd common fuse setting</description>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_AXI_BURST_ALIGN_FUSE_RD_PRP</name>
              <description>AXI burst align rd prp fuse setting</description>
              <bitRange>[11:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_AXI_BURST_ALIGN_FUSE_RD_CH_REF_PREFETCH</name>
              <description>AXI burst align rd ch ref prefetch fuse setting</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_AXI_BURST_ALIGN_FUSE_RD_LU_REF_PREFETCH</name>
              <description>AXI burst align rd lu ref prefetch fuse setting</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG320</name>
          <description>swreg320 register</description>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_AXI_BURST_ALIGN_WR_COMMON</name>
              <description>AXI burst align wr common</description>
              <bitRange>[31:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_AXI_BURST_ALIGN_WR_STREAM</name>
              <description>AXI burst align wr stream</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_AXI_BURST_ALIGN_WR_CHROMA_REF</name>
              <description>AXI burst align wr chroma ref</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_AXI_BURST_ALIGN_WR_LUMA_REF</name>
              <description>AXI burst align wr luma ref</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_AXI_BURST_ALIGN_RD_COMMON</name>
              <description>AXI burst align rd common</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_AXI_BURST_ALIGN_RD_PRP</name>
              <description>AXI burst align rd prp</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_AXI_BURST_ALIGN_RD_CH_REF_PREFETCH</name>
              <description>AXI burst align rd ch ref prefetch</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_AXI_BURST_ALIGN_RD_LU_REF_PREFETCH</name>
              <description>AXI burst align rd lu ref prefetch</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG349</name>
          <description>swreg349 register</description>
          <addressOffset>0x574</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_SBI_WAIT_FRAME_START</name>
              <description>sbi wait for data ready before each frame start</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_SBI_OUT_OF_SYNC</name>
              <description>sbi out of sync indication bit</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_SBI_TIMEOUT</name>
              <description>sbi timeout indication bit</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>reserved field19</description>
              <bitRange>[28:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ENC_OVERLAY_UVSTRIDE1</name>
              <description>Overlay 1 chroma stride</description>
              <bitRange>[19:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG430</name>
          <description>swreg430 register</description>
          <addressOffset>0x6B8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00C00000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESERVED_HIGHT</name>
              <description>reserved hight field</description>
              <bitRange>[31:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_HWJPEGROIMAPSUPPORT</name>
              <description>HW Jpeg support RoiMap. 0=not supported. 1=supported.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_HWBACKGROUNDDETSUPPORT</name>
              <description>HW Back ground detection support. 0=not supported. 1=supported.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>reserved field1</description>
              <bitRange>[27:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_HWNVFORMATONLYSUPPORT</name>
              <description>HW only support nv input format. 0=support all input format. 1=only support nv input format</description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>reserved field0</description>
              <bitRange>[21:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_HWPRPSBISUPPORT</name>
              <description>PSNR calculation supported by HW. 0=not supported. 1=supported</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RESERVED_LOW</name>
              <description>reserved low field</description>
              <bitRange>[16:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG500</name>
          <description>swreg500 register</description>
          <addressOffset>0x7D0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESERVED_HIGHT</name>
              <description>reserved hight field</description>
              <bitRange>[31:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_REQUEST_SEG_NUM_2</name>
              <description>seg num of successful handshaking request channel 2</description>
              <bitRange>[29:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_REQUEST_SEG_NUM_1</name>
              <description>seg num of successful handshaking request channel 1</description>
              <bitRange>[19:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_REQUEST_SEG_NUM_0</name>
              <description>seg num of successful handshaking request channel 0</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG501</name>
          <description>swreg501 register</description>
          <addressOffset>0x7D4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESERVED_HIGHT</name>
              <description>reserved hight field</description>
              <bitRange>[31:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_UPDATE_SEG_NUM_2</name>
              <description>seg num of successful handshaking update channel 2</description>
              <bitRange>[29:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_UPDATE_SEG_NUM_1</name>
              <description>seg num of successful handshaking update channel 1</description>
              <bitRange>[19:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_ENC_UPDATE_SEG_NUM_0</name>
              <description>seg num of successful handshaking update channel 0</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG509</name>
          <description>swreg509 register</description>
          <addressOffset>0x7F4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00002090</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_BUILD_ID</name>
              <description>Build ID</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG510</name>
          <description>swreg510 register</description>
          <addressOffset>0x7F8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x01234567</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_BUILD_CL</name>
              <description>Build CL</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>JPEG_SWREG511</name>
          <description>swreg511 register</description>
          <addressOffset>0x7FC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x20170420</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW_ENC_BUILD_DATE</name>
              <description>Build Date</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="DMA1_SEC">
      <name>DMA0_SEC</name>
      <baseAddress>0x49080000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="DMA1_SEC">
      <name>DMA0_NS</name>
      <baseAddress>0x490A0000</baseAddress>
    </peripheral>
    <peripheral>
      <name>OSPI0</name>
      <groupName>OSPI</groupName>
      <baseAddress>0x83000000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>332</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>OSPI_CTRLR0</name>
          <description>OSPI Control Register 0</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00C00407</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPI_HYPERBUS_EN</name>
              <description>SPI HyperBus Frame Format Enable.
Selects if data frame format for Transmitting/Receiving data is in HyperBus mode.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable HyperBus format.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable HyperBus format.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPI_FRF</name>
              <description>SPI Frame Format
Selects data frame format for Transmitting/Receiving the data. </description>
              <bitRange>[23:22]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Standard SPI format</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Dual SPI format</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Quad SPI format</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Octal SPI format</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSTE</name>
              <description>Slave Select Toggle Enable.
While operating in SPI mode with SCPH set to 0, this bit controls the behavior of the slave select line between data frames.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The slave select line will stay low and OSPI_SCLK will run continuously for the duration of the transfer.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The slave select line will toggle between consecutive data frames, with the serial clock (OSPI_SCLK) being held to its default value while the slave select line is high.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRL</name>
              <description>Shift Register Loop.
Used for testing purposes only. When internally active, connects the transmit shift register output to the receive shift register input. </description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Normal mode operation</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Test mode operation</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TMOD</name>
              <description>Transfer Mode.
Selects the mode of transfer for serial communication. This field does not affect the transfer duplicity. Only indicates whether the receive or transmit data are valid.
In Transmit Only mode, data received from the external device is not valid and is not stored in the receive FIFO memory; it is overwritten on the next transfer.
In Receive Only mode, transmitted data are not valid. After the first write to the transmit FIFO, the same word is retransmitted for the duration of the transfer.
In transmit-and-receive mode, both transmit and receive data are valid. The transfer continues until the transmit FIFO is empty. Data received from the external device are stored into the receive FIFO memory, where it can be accessed by the host processor.</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit and Receive; Not Applicable in enhanced SPI operating mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit Only mode; Or Write in enhanced SPI operating mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Receive Only mode; Or Read in enhanced SPI operating mode.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>EEPROM Read mode; Not Applicable in enhanced SPI operating mode.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SCPOL</name>
              <description>Serial Clock Polarity.
 Used to select the polarity of the inactive serial clock, which is held inactive when the OSPI master is not actively transferring data on the serial bus.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Inactive state of serial clock is low.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Inactive state of serial clock is high.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SCPH</name>
              <description>Serial Clock Phase.
 The serial clock phase selects the relationship of the serial clock with the slave select signal.
When SCPH = 0, data are captured on the first edge of the serial clock. 
When SCPH = 1, the serial clock starts toggling one cycle after the slave select line is activated, and data are captured on the second edge of the serial clock.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Serial clock toggles in middle of first bit.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Serial clock toggles at start of first bit.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FRF</name>
              <description>Frame Format.
Selects which serial protocol transfers the data.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Motorola SPI Frame Format</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFS</name>
              <description>Data Frame Size.
Selects the data frame length. When the data frame size is programmed to be less than 32-bits, the receive data is automatically right-justified by the receive logic, with the upper bits of the receive FIFO zero-padded.
Software must right-justify transmit data before writing into the transmit FIFO. The transmit logic ignores the upper unused bits when transmitting the data.
Note: The DFS value must be multiple of 2 if SPI_FRF = 0x1, multiple of 4 if SPI_FRF = 0x2, and multiple of 8 if SPI_FRF = 0x3.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>04-bit serial data transfer</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>05-bit serial data transfer</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>06-bit serial data transfer</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>07-bit serial data transfer</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>08-bit serial data transfer</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>09-bit serial data transfer</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>10-bit serial data transfer</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>11-bit serial data transfer</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>12-bit serial data transfer</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>13-bit serial data transfer</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xD</name>
                  <description>14-bit serial data transfer</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xE</name>
                  <description>15-bit serial data transfer</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description>16-bit serial data transfer</description>
                  <value>0xF</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x10</name>
                  <description>17-bit serial data transfer</description>
                  <value>0x10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x11</name>
                  <description>18-bit serial data transfer</description>
                  <value>0x11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x12</name>
                  <description>19-bit serial data transfer</description>
                  <value>0x12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x13</name>
                  <description>20-bit serial data transfer</description>
                  <value>0x13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x14</name>
                  <description>21-bit serial data transfer</description>
                  <value>0x14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x15</name>
                  <description>22-bit serial data transfer</description>
                  <value>0x15</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x16</name>
                  <description>23-bit serial data transfer</description>
                  <value>0x16</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x17</name>
                  <description>24-bit serial data transfer</description>
                  <value>0x17</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x18</name>
                  <description>25-bit serial data transfer</description>
                  <value>0x18</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x19</name>
                  <description>26-bit serial data transfer</description>
                  <value>0x19</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1A</name>
                  <description>27-bit serial data transfer</description>
                  <value>0x1A</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1B</name>
                  <description>28-bit serial data transfer</description>
                  <value>0x1B</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1C</name>
                  <description>29-bit serial data transfer</description>
                  <value>0x1C</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1D</name>
                  <description>30-bit serial data transfer</description>
                  <value>0x1D</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1E</name>
                  <description>31-bit serial data transfer</description>
                  <value>0x1E</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1F</name>
                  <description>32-bit serial data transfer</description>
                  <value>0x1F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_CTRLR1</name>
          <description>OSPI Control Register 1</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NDF</name>
              <description>Number of Data Frames.
When OSPI_CTRLR0[TMOD] = 0x2 or 0x3, this bit field sets the number of data frames to be continuously received by the OSPI. The OSPI continues to receive serial data until the number of data frames received is equal to this register value plus 1, which enables to receive up to 256KB of data in a continuous transfer.
When OSPI_CTRLR0[TMOD] = 0x1, this bit field sets the number of data frames to be continuously transmitted by OSPI. If the Transmit FIFO goes empty in-between, OSPI masks the serial clock (OSPI_SCLK) and waits for rest of the data until the programmed amount of frames are transferred successfully.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_ENR</name>
          <description>OSPI Enable Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OSPI_EN</name>
              <description>OSPI Enable.
Enables or disables all OSPI operations. When disabled, all serial transfers are halted immediately. Transmit and receive FIFO buffers are cleared when the device is disabled. It is impossible to program some of the OSPI control registers when enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disables OSPI</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables OSPI</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_SER</name>
          <description>OSPI Slave Enable Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SER</name>
              <description>Slave Select Enable Flag.
Each bit of this bit field corresponds to the slave select line from the OSPI master. When a bit in this bit field is set (0x1), the slave select line from the master is activated when a serial transfer begins. It should be noted that setting or clearing bits in this bit field have no effect on the corresponding slave select output until a transfer is started. Before beginning a transfer, the respective bit in this bit field should be enabled depending which slave select line is desired.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Selected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_BAUDR</name>
          <description>OSPI Baud Rate Select Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCKDV</name>
              <description>OSPI Clock Divider.
This field contains the MSB 15 bits of the 16-bit SPI_CLK divider value. The LSB for this bit field is always set to 0 and is unaffected by a write operation, which ensures the divider is always set to an even value. If this field is set to all 0s, the serial output clock (OSPI_SCLK) is disabled. The frequency of the OSPI_SCLK is derived from the following equation:
FOSPI_SCLK = FOSPI_CLK/BAUDR
Where BAUDR is any even value between 2 and 65534, and BAUDR = SCKDV x 2. For example, for FOSPI_CLK = 3.6864 MHz and SCKDV = 1b'1:
 BAUDR = 2 and FOSPI_SCLK = 3.6864/2 = 1.8432 MHz</description>
              <bitRange>[15:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_TXFTLR</name>
          <description>OSPI Transmit FIFO Threshold Level Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXFTHR</name>
              <description>Transfer Start FIFO Level.
Used to control the level of entries in transmit FIFO above which transfer will start on serial line. This bit field is used to ensure that sufficient data is present in transmit FIFO before starting a write operation on serial line.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TFT</name>
              <description>Transmit FIFO Threshold.
Controls the level of entries (or below) at which the transmit FIFO controller triggers an interrupt. The FIFO depth is 256. If the value in this bit field is greater than or equal to the depth of the FIFO, this bit field is not written and retains its current value. When the number of transmit FIFO entries is less than or equal to this value, the transmit FIFO empty interrupt is triggered.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_RXFTLR</name>
          <description>OSPI Receive FIFO Threshold Level Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFT</name>
              <description>Receive FIFO Threshold.
Controls the level of entries (or above) at which the receive FIFO controller triggers an interrupt. The FIFO depth is 256. If the value in this bit field is greater than the depth of the FIFO, this bit field is not written and retains its current value. When the number of receive FIFO entries is greater than or equal to this value + 1, the receive FIFO full interrupt is triggered.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_TXFLR</name>
          <description>OSPI Transmit FIFO Level Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXTFL</name>
              <description>Transmit FIFO Level.
Contains the number of valid data entries in the transmit FIFO.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_RXFLR</name>
          <description>OSPI Receive FIFO Level Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXTFL</name>
              <description>Receive FIFO Level.
Contains the number of valid data entries in the receive FIFO.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_SR</name>
          <description>OSPI Status Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000006</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPLTD_DF</name>
              <description>Completed Data Frames.
This bit field indicates total data frames transferred in the previous internal DMA transfer.</description>
              <bitRange>[31:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RFF</name>
              <description>Receive FIFO Full.
When the receive FIFO is completely full, this bit is set. When the receive FIFO contains one or more empty location, this bit is cleared.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO is not full.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO is full.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFNE</name>
              <description>Receive FIFO Not Empty.
Set when the receive FIFO contains one or more entries and is cleared when the receive FIFO is empty. This bit can be polled by software to completely empty the receive FIFO.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO is empty.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO is not empty.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TFE</name>
              <description>Transmit FIFO Empty.
When the transmit FIFO is completely empty, this bit is set. When the transmit FIFO contains one or more valid entries, this bit is cleared. This bit field does not request an interrupt.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO is not empty.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO is empty.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TFNF</name>
              <description>Transmit FIFO Not Full.
Set when the transmit FIFO contains one or more empty locations, and is cleared when the FIFO is full.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO is full.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO is not full.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUSY</name>
              <description>OSPI Busy Flag.
When set, indicates that a serial transfer is in progress; when cleared indicates that the OSPI is idle or disabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>OSPI is idle or disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>OSPI is actively transferring data.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_IMR</name>
          <description>OSPI Interrupt Mask Register</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x000000FF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXUIM</name>
              <description>Transmit FIFO Underflow Interrupt Mask</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Underflow interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Underflow interrupt is not masked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFIM</name>
              <description>Receive FIFO Full Interrupt Mask</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Full interrupt is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Full interrupt is not masked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXOIM</name>
              <description>Receive FIFO Overflow Interrupt Mask</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Overflow interrupt is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Overflow interrupt is not masked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXUIM</name>
              <description>Receive FIFO Underflow Interrupt Mask</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Underflow interrupt is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Underflow interrupt is not masked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXOIM</name>
              <description>Transmit FIFO Overflow Interrupt Mask</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Overflow interrupt is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Overflow interrupt is not masked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXEIM</name>
              <description>Transmit FIFO Empty Interrupt Mask</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Empty interrupt is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Empty interrupt is not masked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_ISR</name>
          <description>OSPI Interrupt Status Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXUIS</name>
              <description>Transmit FIFO Underflow Interrupt Status</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Underflow interrupt is not active after masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Underflow interrupt is active after masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFIS</name>
              <description>Receive FIFO Full Interrupt Status.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Full interrupt is not active after masking.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Full interrupt is active after masking.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXOIS</name>
              <description>Receive FIFO Overflow Interrupt Status.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Overflow interrupt is not active after masking.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Overflow interrupt is active after masking.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXUIS</name>
              <description>Receive FIFO Underflow Interrupt Status.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Underflow interrupt is not active after masking.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Underflow interrupt is active after masking.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXOIS</name>
              <description>Transmit FIFO Overflow Interrupt Status.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Overflow interrupt is not active after masking.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Overflow interrupt is active after masking.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXEIS</name>
              <description>Transmit FIFO Empty Interrupt Status.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Empty interrupt is not active after masking.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Empty interrupt is active after masking.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_RISR</name>
          <description>OSPI Raw Interrupt Status Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXUIR</name>
              <description>Transmit FIFO Underflow Interrupt Raw Status</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Underflow interrupt is not active prior masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Underflow interrupt is active prior to masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFIR</name>
              <description>Receive FIFO Full Raw Interrupt Status.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Full interrupt is not active prior masking.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Full interrupt is active prior to masking.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXOIR</name>
              <description>Receive FIFO Overflow Raw Interrupt Status.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Overflow interrupt is not active prior masking.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Overflow interrupt is active prior to masking.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXUIR</name>
              <description>Receive FIFO Underflow Raw Interrupt Status.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Underflow interrupt is not active prior masking.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Underflow interrupt is active prior to masking.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXOIR</name>
              <description>Transmit FIFO Overflow Raw Interrupt Status.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Overflow interrupt is not active prior masking.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Overflow interrupt is active prior to masking.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXEIR</name>
              <description>Transmit FIFO Empty Raw Interrupt Status.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Empty interrupt is not active prior masking.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Empty interrupt is active prior to masking.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_TXEICR</name>
          <description>OSPI Transmit FIFO Error Interrupt Clear Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXEICR</name>
              <description>Clear Transmit FIFO Overflow/Underflow Interrupt.
This bit reflects the status of the interrupt. A read from this bit clears the Transmit FIFO Overflow/Underflow interrupt; writing has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_RXOICR</name>
          <description>OSPI Receive FIFO Overflow Interrupt Clear Register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXOICR</name>
              <description>Clear Receive FIFO Overflow Interrupt.
This bit reflects the status of the interrupt. A read from this bit clears the Receive FIFO Overflow interrupt; writing has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_RXUICR</name>
          <description>OSPI Receive FIFO Underflow Interrupt Clear Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXUICR</name>
              <description>Clear Receive FIFO Underflow Interrupt.
This bit reflects the status of the interrupt. A read from this bit clears the Receive FIFO Underflow
 interrupt; writing has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_ICR</name>
          <description>OSPI Interrupt Clear Register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ICR</name>
              <description>Clear Interrupts.
This bit is set if any of the interrupts below are active. A read clears the Transmit FIFO Underflow, Transmit FIFO Overflow, Receive FIFO Underflow, and Receive FIFO Overflow interrupts. Writing to this bit has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_DMACR</name>
          <description>OSPI DMA Control Register</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDMAE</name>
              <description>Transmit DMA Enable. This bit enables/disables the transmit FIFO DMA channel.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit DMA disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit DMA enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RDMAE</name>
              <description>Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive DMA disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive DMA enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_DMATDLR</name>
          <description>OSPI DMA Transmit Data Level Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMATDL</name>
              <description>Transmit Data Level. This bit field controls the level at which a DMA request is made by the transmit logic. It is equal to the Watermark Level; that is, the OSPI_DMA_TX_REQ signal is generated when the number of valid data entries in the transmit FIFO is equal to or below this field value, and OSPI_DMACR[TDMAE] = 1.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_DMARDLR</name>
          <description>OSPI DMA Receive Data Level Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMARDL</name>
              <description>Receive Data Level.
 This bit field controls the level at which a DMA request is made by the receive logic. The Watermark Level is equal to OSPI_DMARDLR[DMARDL] + 1; that is, OSPI_DMA_RX_REQ is generated when the number of valid data entries in the receive FIFO is equal to or above this field value + 1, and OSPI_DMACR[RDMAE] = 1.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_IDR</name>
          <description>Identification Register</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xC7C5C7C5</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IDCODE</name>
              <description>Identification code</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_VERSION_ID</name>
          <description>Version ID Register</description>
          <addressOffset>0x5C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x3230302A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OSPI_COMP_VERSION</name>
              <description>Component version</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>36</dim>
          <dimIncrement>4</dimIncrement>
          <name>OSPI_DR[%s]</name>
          <description>OSPI Data Register (n)</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DR</name>
              <description>Data Register (n). When writing to this register, the data must be right-justified. Read data are automatically right-justified.
Read = Receive FIFO buffer
Write = Transmit FIFO buffer</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_RX_SAMPLE_DELAY</name>
          <description>OSPI Rx Sample Delay Register</description>
          <addressOffset>0xF0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SE</name>
              <description>RXD Sampling Edge. 
This bit is used to decide the sampling edge for RXD signal with OSPI_CLK. Then this bit is set to 1 then negative edge of OSPI_CLK will be used to sample the incoming data, otherwise positive edge will be used for sampling.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSD</name>
              <description>RXD Sample Delay. 
This bit field is used to delay the sample of the RXD input port. Each value represents a single OSPI_CLK delay on the sample of RXD.
Note: If this bit is programmed with a value that exceeds the depth of the internal shift registers (internal shift register depth = 4) zero delay will be applied to the RXD sample.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_SPI_CTRLR0</name>
          <description>OSPI SPI Control Register 0</description>
          <addressOffset>0xF4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>XIP_PREFETCH_EN</name>
              <description>Enables XIP Pre-fetch functionality in OSPI. 
Once enabled OSPI will pre-fetch data frames from next contiguous location, to reduce the latency for the upcoming contiguous transfer. If the next XIP request is not contiguous then pre-fetched bits will be discarded.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>XIP_MBL</name>
              <description>XIP Mode Bits Length. 
Sets the length of Mode bits in XIP mode of operation. These bits are valid only when OSPI_SPI_CTRLR0[XIP_MD_BIT_EN] is set to 1.</description>
              <bitRange>[27:26]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Mode bits length equal to 2.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Mode bits length equal to 4.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Mode bits length equal to 8.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Mode bits length equal to 16.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPI_RXDS_SIG_EN</name>
              <description>Enable RXDS Signaling during address and command phase of HyperBus transfer.
This bit enables RXDS signaling by HyperBus slave devices during Command-Address (CA) phase. If the RXDS signal is set to 1 during the CA phase of transfer, OSPI transmits [2 x OSPI_SPI_CTRLR0[WAIT_CYCLES]) - 1] wait cycles after the address phase is complete.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DM_EN</name>
              <description>SPI Data Mask Enable bit.
When this bit is enabled, the TXD_DM signal is used to mask the data on the TXD data line.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RXDS_VL_EN</name>
              <description>RXDS Variable Latency Enable bit.
When this bit is set OSPI waits for all the data to be sampled before stopping the OSPI_SCLK clock. This enables the support for devices which support variable latencies during RXDS transfers.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPI_XIP_CONT_XFER_EN</name>
              <description>Enable Continuous Transfer in XIP mode.
 If this bit is set to 1 then continuous transfer mode in XIP is enabled, in this mode OSPI keeps the slave selected until a non-XIP transfer is detected on the AHB interface.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>XIP_INST_EN</name>
              <description>XIP Instruction Enable bit. 
If this bit is set to 1 then XIP transfers also have an instruction phase. The instruction opcodes can be chosen from OSPI_XIP_INCR_INST or OSPI_XIP_WRAP_INST registers bases on AHB transfer type.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>XIP_DFS_HC</name>
              <description>Fix DFS for XIP transfers.
 If this bit is set to 1 then data frame size for XIP transfers is fixed to the programmed value in OSPI_CTRLR0[DFS] bit field. The number of data frames to fetch is determined by transfer size and burst type signals. If this bit is set to 0 then data frame size and number of data frames to fetch are both determined by transfer size and burst type signals.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_RXDS_EN</name>
              <description>Read Data Strobe Enable bit.
Once this bit is set to 1 OSPI uses Read data strobe (RXDS) to capture read data in DDR mode.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INST_DDR_EN</name>
              <description>Instruction DDR Enable bit. 
This bit enables Dual Data-Rate transfer for instruction phase.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DDR_EN</name>
              <description>SPI DDR Enable bit. 
This bit enables Dual Data-Rate transfers in Dual/Quad/Octal frame formats of SPI.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAIT_CYCLES</name>
              <description>Wait cycles in Dual/Quad/Octal mode between control frames transmission and data reception. Specified as number of SPI clock cycles.
Note: If wait cycles during the write transfer are not needed this field can be set to 0x0.</description>
              <bitRange>[15:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INST_L</name>
              <description>Dual/Quad/Octal mode instruction length in bits.
Note: For enhanced SPI modes, INST_L and ADDR_L cannot be both programmed to 0x0 at the same time.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No Instruction.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>4-bit instruction length.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>8-bit instruction length.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>16-bit instruction length.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>XIP_MD_BIT_EN</name>
              <description>Mode bits enable in XIP mode.
 If this bit is set to 0x1, then in XIP mode of operation OSPI inserts Mode bits after the address phase. These bits are set in register OSPI_XIP_MODE_BITS register. The length of Mode bits defaults to 8-bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ADDR_L</name>
              <description>This bit defines Length of Address to be transmitted. Only after this much bits are programmed in to the FIFO the transfer can begin.
Note: For enhanced SPI modes, INST_L and ADDR_L cannot be both programmed to 0x0 at the same time.</description>
              <bitRange>[5:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No address</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>4-bit address length</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>8-bit address length</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>12-bit address length</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>16-bit address length</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>20-bit address length</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>24-bit address length</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>28-bit address length</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>32-bit address length</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>36-bit address length</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>40-bit address length</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>44-bit address length</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>48-bit address length</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xD</name>
                  <description>52-bit address length</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xE</name>
                  <description>56-bit address length</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description>60-bit address length</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRANS_TYPE</name>
              <description>Address and Instruction Transfer format.
Selects whether OSPI will transmit instruction/address either in Standard SPI mode or the SPI mode selected in the OSPI_CTRLR0[SPI_FRF] bit field.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Instruction and Address will be sent in Standard SPI Mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Instruction will be sent in Standard SPI Mode and Address will be sent in the mode specified by the OSPI_CTRLR0[SPI_FRF] bit field.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Both Instruction and Address will be sent in the mode specified by OSPI_CTRLR0[SPI_FRF] bit field.</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_DDR_DRIVE_EDGE</name>
          <description>OSPI Transmit Drive Edge Register</description>
          <addressOffset>0xF8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDE</name>
              <description>TXD Drive Edge register which decided the driving edge of transmit data.
The maximum value of this bit field is equal to [(BAUDR/2) - 1].</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_XIP_MODE_BITS</name>
          <description>OSPI XIP Mode Bits Register</description>
          <addressOffset>0xFC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>XIP_MD_BITS</name>
              <description>XIP Mode bits to be sent after address phase of XIP transfer.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_XIP_INCR_INST</name>
          <description>OSPI XIP INCR Transfer Opcode Register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INCR_INST</name>
              <description>XIP INCR transfer opcode. 
When OSPI_SPI_CTRLR0[XIP_INST_EN] bit is set to 1, OSPI sends instruction for all XIP transfers, this register field stores the instruction opcode to be sent when an INCR type transfer is requested on AHB bus. The number of bits to be send in instruction phase is determined by the OSPI_SPI_CTRLR0[INST_L] bit field.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_XIP_WRAP_INST</name>
          <description>OSPI XIP WRAP Transfer Opcode Register</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRAP_INST</name>
              <description>XIP WRAP transfer opcode. 
When OSPI_SPI_CTRLR0[XIP_INST_EN] bit is set to 1, OSPI sends instruction for all XIP transfers, this register field stores the instruction opcode to be sent when an WRAP type transfer is requested on AHB bus. The number of bits to be send in instruction phase is determined by the OSPI_SPI_CTRLR0[INST_L] bit field.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_XIP_CTRL</name>
          <description>OSPI XIP Control Register</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x08000401</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXDS_VL_EN</name>
              <description>RXDS Variable Latency Enable.
When this bit is set OSPI waits for all the data to be sampled before stopping the OSPI_SCLK clock. This enables the support for devices which support variable latencies during RXDS transfers.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XIP_PREFETCH_EN</name>
              <description>Enables XIP Pre-fetch functionality in OSPI. Once enabled OSPI will pre-fetch data frames from next contiguous location, to reduce the latency for the upcoming contiguous transfer. If the next XIP request is not contiguous then pre-fetched bits will be discarded.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XIP_MBL</name>
              <description>XIP Mode Bits Length. 
Sets the length of Mode bits in XIP mode of operation. These bits are valid only when OSPI_XIP_CTRL[XIP_MD_BIT_EN] is set to 1.</description>
              <bitRange>[27:26]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Mode bits length equal to 2.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Mode bits length equal to 4.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Mode bits length equal to 8.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Mode bits length equal to 16.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXDS_SIG_EN</name>
              <description>Enable RXDS Signaling during address and command phase of HyperBus transfer.
This bit enables RXDS signaling by HyperBus slave devices during Command-Address (CA) phase. If the RXDS signal is set to 1 during the CA phase of transfer, OSPI transmits [2 x OSPI_SPI_CTRLR0[WAIT_CYCLES]) - 1] wait cycles after the address phase is complete.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XIP_HYPERBUS_EN</name>
              <description>SPI Hyperbus Frame format enable for XIP transfers.
Selects if data frame format for XIP transfers is in HyperBus mode.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CONT_XFER_EN</name>
              <description>Enable Continuous Transfer in XIP mode. 
If this bit is set to 1 then continuous transfer mode in XIP will be enabled, in this mode OSPI will keep slave selected until a non-XIP transfer is detected on the AHB interface.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INST_EN</name>
              <description>XIP Instruction Enable bit.
 If this bit is set to 1 then XIP transfers will also have instruction phase. The instruction opcodes can be chosen from OSPI_XIP_INCR_INST or OSPI_XIP_WRAP_INST registers bases on AHB transfer type.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RXDS_EN</name>
              <description>Read Data Strobe Enable bit. 
Once this bit is set to 1, OSPI will use Read data strobe (RXDS) to capture read data in DDR mode.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INST_DDR_EN</name>
              <description>Instruction DDR Enable bit.
 This bit enables Dual Data-Rate transfer for instruction phase</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR_EN</name>
              <description>SPI DDR Enable bit. 
This bit enables Dual Data-Rate transfers in Dual/Quad/Octal frame formats of SPI.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFS_HC</name>
              <description>Fix DFS for XIP transfers. 
If this bit is set to 1 then data frame size for XIP transfers is fixed to the programmed value in OSPI_CTRLR0[DFS] bit field. The number of data frames to fetch is determined by transfer size and burst type signals. If this bit is set to 0 then data frame size and number of data frames to fetch are both determined by transfer size and burst type signals.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAIT_CYCLES</name>
              <description>Wait cycles in Dual/Quad/Octal mode between control frames transmission and data reception. Specified as number of SPI clock cycles.</description>
              <bitRange>[17:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MD_BITS_EN</name>
              <description>Mode bits enable in XIP mode.
 If this bit is set to 1, then in XIP mode of operation OSPI will insert Mode bits after the address phase. These bits are set in register OSPI_XIP_MODE_BITS register. The length of Mode bits defaults to 8-bits.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INST_L</name>
              <description>Dual/Quad/Octal mode instruction length in bits.</description>
              <bitRange>[10:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No Instruction</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>4-bit instruction length</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>8-bit instruction length</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>16-bit instruction length</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADDR_L</name>
              <description>This bit defines Length of Address to be transmitted. Only after this much bits are programmed in to the FIFO the transfer can begin.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No address</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>4-bit address length</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>8-bit address length</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>12-bit address length</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>16-bit address length</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>20-bit address length</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>24-bit address length</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>28-bit address length</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>32-bit address length</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>36-bit address length</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>40-bit address length</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>44-bit address length</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>48-bit address length</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xD</name>
                  <description>52-bit address length</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xE</name>
                  <description>56-bit address length</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description>60-bit address length</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRANS_TYPE</name>
              <description>Address and Instruction Transfer format.
Selects whether OSPI will transmit instruction/address either in Standard SPI mode or the SPI mode selected in the OSPI_XIP_CTRL[FRF] bit field.</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Instruction and Address will be sent in Standard SPI Mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Instruction will be sent in Standard SPI Mode and Address will be sent in the mode specified by OSPI_XIP_CTRL[FRF] bit field.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Both Instruction and Address will be sent in the mode specified by OSPI_XIP_CTRL[FRF] bit field.</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FRF</name>
              <description>SPI Frame Format
Selects data frame format for Receiving the data.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Standard SPI Format</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Dual SPI format</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Quad SPI format</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Octal SPI format</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_XIP_CNT_TIME_OUT</name>
          <description>OSPI XIP Timeout Register for Continuous Transfers</description>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>XTOC</name>
              <description>XIP Timeout Counter
XIP timeout value in terms of HCLK. Once slave is selected in continuous XIP mode this counter will be used to de-select the slave if there is no request for the time specified in the counter.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_SPI_CTRLR1</name>
          <description>OSPI SPI Control Register 1</description>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS_MIN_HIGH</name>
              <description>Chip-Select Minimum High Period.
This field is used to set the minimum time period (in terms of OSPI_CLK) between two back to back SPI operations.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_XIP_WRITE_INCR_INST</name>
          <description>OSPI XIP Write INCR Transfer Opcode Register</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INCR_WRITE_INST</name>
              <description>XIP Write INCR transfer opcode. When OSPI_XIP_WRITE_CTRL[INST_L] is not equal to 0x0, OSPI sends instruction for all XIP write transfers. This field stores the instruction op-code to be sent when an INCR type XIP Write transfer is requested on AHB bus. The number of bits to be send in instruction phase is determined by the OSPI_XIP_WRITE_CTRL[INST_L] field.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_XIP_WRITE_WRAP_INST</name>
          <description>OSPI XIP Write WRAP Transfer Opcode Register</description>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRAP_WRITE_INST</name>
              <description>XIP Write WRAP transfer opcode. When OSPI_XIP_WRITE_CTRL[INST_L] is not equal to 0x0, OSPI sends instruction for all XIP write transfers. This field stores the instruction op-code to be sent when a WRAP type XIP Write transfer is requested on AHB bus. The number of bits to be send in instruction phase is determined by the OSPI_XIP_WRITE_CTRL[INST_L] field.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_XIP_WRITE_CTRL</name>
          <description>OSPI XIP Write Control Register</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00004072</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>XIPWR_DFS_HC</name>
              <description>Fix Data Frame Size (DFS) for XIP transfers. If this bit is set to 0x1, then DFS for XIP transfers will be fixed to the programmed value in OSPI_CTRLR0[DFS]. If this bit is set to 0x0, then data frame size will be determined by HSIZE signal.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XIPWR_WAIT_CYCLES</name>
              <description>Wait cycles in Dual/Quad/Octal mode between control frames transmission and data reception. Specified as number of SPI clock cycles.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XIPWR_DM_EN</name>
              <description>SPI Data Mask Enable bit.
When this bit is enabled, the TXD_DM signal is used to mask the data on the TXD data line.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XIPWR_RXDS_SIG_EN</name>
              <description>Enable RXDS signaling during address and command phase of Hyperbus transfer.
This bit enables RXDS signaling by Hyperbus slave devices during Command-Address (CA) phase. If the RXDS signal is set to 1 during the CA phase of transfer, OSPI transmits (2 x OSPI_XIP_WRITE_CTRL[WAIT_CYCLES] - 1) wait cycles after the address phase is complete.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XIPWR_HYPERBUS_EN</name>
              <description>SPI Hyperbus Frame format enable for XIP Write transfers.
Selects if data frame format for XIP Write transfers is in Hyperbus mode.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WR_INST_DDR_EN</name>
              <description>Instruction DDR Enable bit. This will enable Dual Data-Rate transfer for Instruction phase.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WR_SPI_DDR_EN</name>
              <description>SPI DDR Enable bit. This will enable Dual Data-Rate transfers in Dual/Quad/Octal frame formats of SPI.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WR_INST_L</name>
              <description>Dual/Quad/Octal mode instruction length in bits.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No Instruction</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>4-bit Instruction length</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>8-bit Instruction length</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>16-bit Instruction length</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WR_ADDR_L</name>
              <description>This bit defines Length of Address to be transmitted. Only after this much bits are programmed in to the FIFO the transfer can begin.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>4-bit Address length</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>8-bit Address length</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>12-bit Address length</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>16-bit Address length</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>20-bit Address length</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>24-bit Address length</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>28-bit Address length</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>32-bit Address length</description>
                  <value>0x8</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WR_TRANS_TYPE</name>
              <description>Address and Instruction Transfer format.
Selects whether OSPI will transmit instruction/address either in Standard SPI mode or the SPI mode selected in the OSPI_XIP_WRITE_CTRL[FRF] bit field.</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Instruction and Address will be sent in Standard SPI Mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Instruction will be sent in Standard SPI Mode and Address will be sent in the mode specified by OSPI_XIP_WRITE_CTRL[FRF] bit field.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Both Instruction and Address will be sent in the mode specified by OSPI_XIP_WRITE_CTRL[FRF] bit field.</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WR_FRF</name>
              <description>SPI Frame Format
Selects data frame format for Transmitting the data.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Standard SPI Format</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Dual SPI Format</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Quad SPI Format</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Octal SPI Format</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>AES0</name>
      <groupName>AES</groupName>
      <baseAddress>0x83001000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>124</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>AES_CONTROL</name>
          <description>AES Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LD_KEY</name>
              <description>Write 1 once the new key has been written by the Secure Enclave, so the key can be pre-processed by the AES engine.
Read returns 0x0.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARRAY_MODE</name>
              <description>If 0x1, the address presented to the OSPI logic will be mapped to {ADDR[25:4], 6'h0, ADDR[3:0]} to accommodate memories that use this addressing protocol.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XIP_EN</name>
              <description>When this bit is set, the OSPI can be used in XIP mode directly, with or without intervention from the decryption logic.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_LOGIC</name>
              <description>Reset the AES engine.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DECRYPT_EN</name>
              <description>Decryption Enabled
When set, this bit causes host read accesses to use the decryption logic rather than go directly to the OSPI module. 
 Note that the OSPI module must be programmed to work in XIP mode prior to setting this bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_INTERRUPT</name>
          <description>AES Interrupt Control Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPI_ERR_RESP</name>
              <description>SPI Error Response interrupt enabling.
Set when an error response is received from the OSPI through the AHB bus. Write 1 to clear bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SPI Error Response interrupt is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SPI Error Response interrupt is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REGS_ERR_RESP</name>
              <description>Register Error Response interrupt enabling.
Set when there is an access to an invalid AES register. Write 1 to clear bit.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Register Error Response interrupt is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Register Error Response interrupt is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_INTERRUPT_MASK</name>
          <description>AES Interrupt Mask Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000000C</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPI_ERR_RESP</name>
              <description>Mask for the SPI Error Response interrupt.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SPI Error Response interrupt is not masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SPI Error Response interrupt is masked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REGS_ERR_RESP</name>
              <description>Mask for the Register Error Response interrupt.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Register Error Response interrupt is not masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Register Error Response interrupt is masked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_CLK_DIS</name>
          <description>AES Clock Disable Register</description>
          <alternateRegister>AES_INTERRUPT_MASK</alternateRegister>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>AES_CLK_DIS</name>
              <description>Disable the clock to the AES decryption engine.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_RXDS_DELAY</name>
          <description>OSPI RXDS Delay Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXDS_DELAY_1</name>
              <description>A delay added to the OSPI RXDS[1] input signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RXDS_DELAY_0</name>
              <description>A delay added to the OSPI RXDS[0] input signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_RXD_DELAY_0</name>
          <description>OSPI RXD[3:0] Delay Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1F1F1F1F</resetMask>
          <fields>
            <field>
              <name>RXD_3_DELAY</name>
              <description>A delay added to the RXD[3] input signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[28:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RXD_2_DELAY</name>
              <description>A delay added to the RXD[2] input signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RXD_1_DELAY</name>
              <description>A delay added to the RXD[1] input signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RXD_0_DELAY</name>
              <description>A delay added to the RXD[0] input signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_RXD_DELAY_1</name>
          <description>OSPI RXD[7:4] Delay Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1F1F1F1F</resetMask>
          <fields>
            <field>
              <name>RXD_7_DELAY</name>
              <description>A delay added to the RXD[7] input signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[28:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RXD_6_DELAY</name>
              <description>A delay added to the RXD[6] input signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RXD_5_DELAY</name>
              <description>A delay added to the RXD[5] input signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RXD_4_DELAY</name>
              <description>A delay added to the RXD[4] input signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_RXD_DELAY_2</name>
          <description>OSPI RXD[11:8] Delay Register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1F1F1F1F</resetMask>
          <fields>
            <field>
              <name>RXD_11_DELAY</name>
              <description>A delay added to the RXD[11] input signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[28:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RXD_10_DELAY</name>
              <description>A delay added to the RXD[10] input signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RXD_9_DELAY</name>
              <description>A delay added to the RXD[9] input signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RXD_8_DELAY</name>
              <description>A delay added to the RXD[8] input signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_RXD_DELAY_3</name>
          <description>OSPI RXD[15:12] Delay Register</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1F1F1F1F</resetMask>
          <fields>
            <field>
              <name>RXD_15_DELAY</name>
              <description>A delay added to the RXD[15] input signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[28:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RXD_14_DELAY</name>
              <description>A delay added to the RXD[14] input signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RXD_13_DELAY</name>
              <description>A delay added to the RXD[13] input signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RXD_12_DELAY</name>
              <description>A delay added to the RXD[12] input signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_TXD_DELAY_0</name>
          <description>OSPI TXD[3:0] Delay Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1F1F1F1F</resetMask>
          <fields>
            <field>
              <name>TXD_3_DELAY</name>
              <description>A delay added to the TXD[3] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[28:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TXD_2_DELAY</name>
              <description>A delay added to the TXD[2] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TXD_1_DELAY</name>
              <description>A delay added to the TXD[1] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TXD_0_DELAY</name>
              <description>A delay added to the TXD[0] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_TXD_DELAY_1</name>
          <description>OSPI TXD[7:4] Delay Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1F1F1F1F</resetMask>
          <fields>
            <field>
              <name>TXD_7_DELAY</name>
              <description>A delay added to the TXD[7] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[28:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TXD_6_DELAY</name>
              <description>A delay added to the TXD[6] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TXD_5_DELAY</name>
              <description>A delay added to the TXD[5] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TXD_4_DELAY</name>
              <description>A delay added to the TXD[4] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_TXD_DELAY_2</name>
          <description>OSPI TXD[11:8] Delay Register</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1F1F1F1F</resetMask>
          <fields>
            <field>
              <name>TXD_11_DELAY</name>
              <description>A delay added to the TXD[11] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[28:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TXD_10_DELAY</name>
              <description>A delay added to the TXD[10] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TXD_9_DELAY</name>
              <description>A delay added to the TXD[9] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TXD_8_DELAY</name>
              <description>A delay added to the TXD[8] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_TXD_DELAY_3</name>
          <description>OSPI TXD[15:12] Delay Register</description>
          <addressOffset>0x5C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1F1F1F1F</resetMask>
          <fields>
            <field>
              <name>TXD_15_DELAY</name>
              <description>A delay added to the TXD[15] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[28:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TXD_14_DELAY</name>
              <description>A delay added to the TXD[14] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TXD_13_DELAY</name>
              <description>A delay added to the TXD[13] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TXD_12_DELAY</name>
              <description>A delay added to the TXD[12] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_SSI_OE_N_DELAY_0</name>
          <description>OSPI SSI_OE_N[3:0] Delay Register</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1F1F1F1F</resetMask>
          <fields>
            <field>
              <name>SSI_OE_N_3_DELAY</name>
              <description>A delay added to the SSI_OE_N[3] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[28:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSI_OE_N_2_DELAY</name>
              <description>A delay added to the SSI_OE_N[2] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSI_OE_N_1_DELAY</name>
              <description>A delay added to the SSI_OE_N[1] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSI_OE_N_0_DELAY</name>
              <description>A delay added to the SSI_OE_N[0] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_SSI_OE_N_DELAY_1</name>
          <description>OSPI SSI_OE_N[7:4] Delay Register</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1F1F1F1F</resetMask>
          <fields>
            <field>
              <name>SSI_OE_N_7_DELAY</name>
              <description>A delay added to the SSI_OE_N[7] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[28:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSI_OE_N_6_DELAY</name>
              <description>A delay added to the SSI_OE_N[6] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSI_OE_N_5_DELAY</name>
              <description>A delay added to the SSI_OE_N[5] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSI_OE_N_4_DELAY</name>
              <description>A delay added to the SSI_OE_N[4] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_SSI_OE_N_DELAY_2</name>
          <description>OSPI SSI_OE_N[11:8] Delay Register</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1F1F1F1F</resetMask>
          <fields>
            <field>
              <name>SSI_OE_N_11_DELAY</name>
              <description>A delay added to the SSI_OE_N[11] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[28:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSI_OE_N_10_DELAY</name>
              <description>A delay added to the SSI_OE_N[10] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSI_OE_N_9_DELAY</name>
              <description>A delay added to the SSI_OE_N[9] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSI_OE_N_8_DELAY</name>
              <description>A delay added to the SSI_OE_N[8] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_SSI_OE_N_DELAY_3</name>
          <description>OSPI SSI_OE_N[15:12] Delay Register</description>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1F1F1F1F</resetMask>
          <fields>
            <field>
              <name>SSI_OE_N_15_DELAY</name>
              <description>A delay added to the SSI_OE_N[15] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[28:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSI_OE_N_14_DELAY</name>
              <description>A delay added to the SSI_OE_N[14] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSI_OE_N_13_DELAY</name>
              <description>A delay added to the SSI_OE_N[13] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSI_OE_N_12_DELAY</name>
              <description>A delay added to the SSI_OE_N[12] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_SS_N_DELAY</name>
          <description>OSPI SS_N Delay Register</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001F1F</resetMask>
          <fields>
            <field>
              <name>SSI_N_1_DELAY</name>
              <description>A delay added to the SSI_N[1] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSI_N_0_DELAY</name>
              <description>A delay added to the SSI_N[0] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_TXD_DM_DELAY</name>
          <description>OSPI TXD_DM Delay Register</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1F1F1F1F</resetMask>
          <fields>
            <field>
              <name>TXD_DM_OE_N_DELAY_1</name>
              <description>A delay added to the TXD_DM_OE_N[1] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[28:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TXD_DM_OE_N_DELAY_0</name>
              <description>A delay added to the TXD_DM_OE_N[0] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TXD_DM_DELAY_1</name>
              <description>A delay added to the TXD_DM[1] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TXD_DM_DELAY_0</name>
              <description>A delay added to the TXD_DM[0] output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_SCLK_DELAY</name>
          <description>OSPI SLCK Delay Register</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001F1F</resetMask>
          <fields>
            <field>
              <name>SCLK_N_DELAY</name>
              <description>A delay added to the SCLK_N output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCLK_DELAY</name>
              <description>A delay added to the SCLK output signal. Each increment adds approximately 350 ps to the delay. The maximum value is 23.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="OSPI0">
      <name>OSPI1</name>
      <baseAddress>0x83002000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="AES0">
      <name>AES1</name>
      <baseAddress>0x83003000</baseAddress>
    </peripheral>
    <peripheral>
      <name>M55HP_NVIC_S</name>
      <groupName>M55HP</groupName>
      <baseAddress>0xE000E100</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>1248</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <dim>15</dim>
          <dimIncrement>4</dimIncrement>
          <name>NVIC_ISER[%s]</name>
          <description>Interrupt Set-Enable Register (n)</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SETENA</name>
              <description>Allows to enable an interrupt or read the status. For each bit:
Read 0x0: Interrupt is disabled
Read 0x1: Interrupt is enabled
Write 0x0: No effect
Write 0x1: Enable interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>15</dim>
          <dimIncrement>4</dimIncrement>
          <name>NVIC_ICER[%s]</name>
          <description>Interrupt Clear-Enable Register (n)</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLRENA</name>
              <description>Allows to disable an interrupt or read the status. For each bit:
Read 0x0: Interrupt is disabled
Read 0x1: Interrupt is enabled
Write 0x0: No effect
Write 0x1: Disable interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>15</dim>
          <dimIncrement>4</dimIncrement>
          <name>NVIC_ISPR[%s]</name>
          <description>Interrupt Set-Pending Register (n)</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SETPEND</name>
              <description>Allows to set an interrupt to pending state or read the status. For each bit:
Read 0x0: Interrupt is not pending
Read 0x1: Interrupt is pending
Write 0x0: No effect
Write 0x1: Set interrupt to pending state</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>15</dim>
          <dimIncrement>4</dimIncrement>
          <name>NVIC_ICPR[%s]</name>
          <description>Interrupt Clear-Pending Register (n)</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLRPEND</name>
              <description>Allows to clear an interrupt to not pending state or read the status. For each bit:
Read 0x0: Interrupt is not pending
Read 0x1: Interrupt is pending
Write 0x0: No effect
Write 0x1: Clear pending state of interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>15</dim>
          <dimIncrement>4</dimIncrement>
          <name>NVIC_IABR[%s]</name>
          <description>Interrupt Active Bit Register (n)</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACTIVE</name>
              <description>Indicates the active state of an interrupt. For each bit:</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Interrupt is not active</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <dim>15</dim>
          <dimIncrement>4</dimIncrement>
          <name>NVIC_ITNS[%s]</name>
          <description>Interrupt Target Non-Secure Register (n)</description>
          <addressOffset>0x280</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ITNS</name>
              <description>Determines whether an interrupt targets non-secure or secure state. For each bit:</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Interrupt targets secure state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Interrupt targets non-secure state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <dim>120</dim>
          <dimIncrement>4</dimIncrement>
          <name>NVIC_IPR[%s]</name>
          <description>Interrupt Priority Register (n)</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_N3</name>
              <description>Allows to set or read the priority level for interrupt 3</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_N2</name>
              <description>Allows to set or read the priority level for interrupt 2</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_N1</name>
              <description>Allows to set or read the priority level for interrupt 1</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_N0</name>
              <description>Allows to set or read the priority level for interrupt 0</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Priority level is 0 (highest)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Priority level is 1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xFF</name>
                  <description>Priority level is 255 (lowest)</description>
                  <value>0xFF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="M55HP_NVIC_S">
      <name>M55HP_NVIC_NS</name>
      <baseAddress>0xE002E100</baseAddress>
    </peripheral>
  </peripherals>
</device>
